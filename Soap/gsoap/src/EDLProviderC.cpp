/* EDLProviderC.cpp
   Generated by gSOAP 2.8.17r from D:\Sandbox\EdlProvider\Soap\gsoap\src\EDLProviderInterface.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "EDLProviderH.h"

SOAP_SOURCE_STAMP("@(#) EDLProviderC.cpp ver 2.8.17r 2014-04-11 20:00:34 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType:
		return soap_in__fims__QueryServiceDescriptionRequestType_responseType(soap, NULL, NULL, "fims:QueryServiceDescriptionRequestType-responseType");
	case SOAP_TYPE_fims__JobInfoSelectionType:
		return soap_in_fims__JobInfoSelectionType(soap, NULL, NULL, "fims:JobInfoSelectionType");
	case SOAP_TYPE_fims__ErrorCodeType:
		return soap_in_fims__ErrorCodeType(soap, NULL, NULL, "fims:ErrorCodeType");
	case SOAP_TYPE_fims__BitRateModeType:
		return soap_in_fims__BitRateModeType(soap, NULL, NULL, "fims:BitRateModeType");
	case SOAP_TYPE_fims__ScanningOrderType:
		return soap_in_fims__ScanningOrderType(soap, NULL, NULL, "fims:ScanningOrderType");
	case SOAP_TYPE_fims__ScanningFormatType:
		return soap_in_fims__ScanningFormatType(soap, NULL, NULL, "fims:ScanningFormatType");
	case SOAP_TYPE_fims__AudioSampleType:
		return soap_in_fims__AudioSampleType(soap, NULL, NULL, "fims:AudioSampleType");
	case SOAP_TYPE_fims__JobStatusType:
		return soap_in_fims__JobStatusType(soap, NULL, NULL, "fims:JobStatusType");
	case SOAP_TYPE_fims__HashFunctionTypes:
		return soap_in_fims__HashFunctionTypes(soap, NULL, NULL, "fims:HashFunctionTypes");
	case SOAP_TYPE_fims__JobCommandType:
		return soap_in_fims__JobCommandType(soap, NULL, NULL, "fims:JobCommandType");
	case SOAP_TYPE_fims__QueueCommandType:
		return soap_in_fims__QueueCommandType(soap, NULL, NULL, "fims:QueueCommandType");
	case SOAP_TYPE_fims__StorageTypes:
		return soap_in_fims__StorageTypes(soap, NULL, NULL, "fims:StorageTypes");
	case SOAP_TYPE_fims__PriorityType:
		return soap_in_fims__PriorityType(soap, NULL, NULL, "fims:PriorityType");
	case SOAP_TYPE_fims__QueueStatusType:
		return soap_in_fims__QueueStatusType(soap, NULL, NULL, "fims:QueueStatusType");
	case SOAP_TYPE_edlprovider__EDLProviderErrorCodeType:
		return soap_in_edlprovider__EDLProviderErrorCodeType(soap, NULL, NULL, "edlprovider:EDLProviderErrorCodeType");
	case SOAP_TYPE_fims__TimecodeDuration:
		return soap_in_fims__TimecodeDuration(soap, NULL, NULL, "fims:TimecodeDuration");
	case SOAP_TYPE_fims__Timecode:
		return soap_in_fims__Timecode(soap, NULL, NULL, "fims:Timecode");
	case SOAP_TYPE_fims__RevisionIDType:
		return soap_in_fims__RevisionIDType(soap, NULL, NULL, "fims:RevisionIDType");
	case SOAP_TYPE_fims__ResourceIDType:
		return soap_in_fims__ResourceIDType(soap, NULL, NULL, "fims:ResourceIDType");
	case SOAP_TYPE_fims__EmptyID:
		return soap_in_fims__EmptyID(soap, NULL, NULL, "fims:EmptyID");
	case SOAP_TYPE_fims__UL:
		return soap_in_fims__UL(soap, NULL, NULL, "fims:UL");
	case SOAP_TYPE_fims__UMID:
		return soap_in_fims__UMID(soap, NULL, NULL, "fims:UMID");
	case SOAP_TYPE_fims__UUID:
		return soap_in_fims__UUID(soap, NULL, NULL, "fims:UUID");
	case SOAP_TYPE_fims__UID:
		return soap_in_fims__UID(soap, NULL, NULL, "fims:UID");
	case SOAP_TYPE_fimsdescription__languageType:
		return soap_in_fimsdescription__languageType(soap, NULL, NULL, "fimsdescription:languageType");
	case SOAP_TYPE_fimsdescription__addressType:
		return soap_in_fimsdescription__addressType(soap, NULL, NULL, "fimsdescription:addressType");
	case SOAP_TYPE_fimsdescription__detailsType:
		return soap_in_fimsdescription__detailsType(soap, NULL, NULL, "fimsdescription:detailsType");
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		return soap_in_fimsdescription__organisationDetailsType(soap, NULL, NULL, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		return soap_in_fimsdescription__contactDetailsType(soap, NULL, NULL, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_fimsdescription__entityType:
		return soap_in_fimsdescription__entityType(soap, NULL, NULL, "fimsdescription:entityType");
	case SOAP_TYPE_fimsdescription__dateType:
		return soap_in_fimsdescription__dateType(soap, NULL, NULL, "fimsdescription:dateType");
	case SOAP_TYPE_fimsdescription__textElementType:
		return soap_in_fimsdescription__textElementType(soap, NULL, NULL, "fimsdescription:textElementType");
	case SOAP_TYPE_fimsdescription__rightsType:
		return soap_in_fimsdescription__rightsType(soap, NULL, NULL, "fimsdescription:rightsType");
	case SOAP_TYPE_fimsdescription__coverageType:
		return soap_in_fimsdescription__coverageType(soap, NULL, NULL, "fimsdescription:coverageType");
	case SOAP_TYPE_fimsdescription__descriptionType:
		return soap_in_fimsdescription__descriptionType(soap, NULL, NULL, "fimsdescription:descriptionType");
	case SOAP_TYPE_fimsdescription__typeType:
		return soap_in_fimsdescription__typeType(soap, NULL, NULL, "fimsdescription:typeType");
	case SOAP_TYPE_fimsdescription__subjectType:
		return soap_in_fimsdescription__subjectType(soap, NULL, NULL, "fimsdescription:subjectType");
	case SOAP_TYPE_fimsdescription__identifierType:
		return soap_in_fimsdescription__identifierType(soap, NULL, NULL, "fimsdescription:identifierType");
	case SOAP_TYPE_fimsdescription__titleType:
		return soap_in_fimsdescription__titleType(soap, NULL, NULL, "fimsdescription:titleType");
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		return soap_in_fimsdescription__bmContentDescriptionType(soap, NULL, NULL, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE_fims__DescriptionsType:
		return soap_in_fims__DescriptionsType(soap, NULL, NULL, "fims:DescriptionsType");
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		return soap_in_fims__BMEssenceLocatorsType(soap, NULL, NULL, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_fims__BMContentFormatsType:
		return soap_in_fims__BMContentFormatsType(soap, NULL, NULL, "fims:BMContentFormatsType");
	case SOAP_TYPE_fims__BMContentsType:
		return soap_in_fims__BMContentsType(soap, NULL, NULL, "fims:BMContentsType");
	case SOAP_TYPE_fims__BMObjectsType:
		return soap_in_fims__BMObjectsType(soap, NULL, NULL, "fims:BMObjectsType");
	case SOAP_TYPE_fims__DataFormatsType:
		return soap_in_fims__DataFormatsType(soap, NULL, NULL, "fims:DataFormatsType");
	case SOAP_TYPE_fims__ContainerFormatsType:
		return soap_in_fims__ContainerFormatsType(soap, NULL, NULL, "fims:ContainerFormatsType");
	case SOAP_TYPE_fims__AudioFormatsType:
		return soap_in_fims__AudioFormatsType(soap, NULL, NULL, "fims:AudioFormatsType");
	case SOAP_TYPE_fims__VideoFormatsType:
		return soap_in_fims__VideoFormatsType(soap, NULL, NULL, "fims:VideoFormatsType");
	case SOAP_TYPE_fims__JobsType:
		return soap_in_fims__JobsType(soap, NULL, NULL, "fims:JobsType");
	case SOAP_TYPE_fims__QueuesType:
		return soap_in_fims__QueuesType(soap, NULL, NULL, "fims:QueuesType");
	case SOAP_TYPE_fims__ServicesType:
		return soap_in_fims__ServicesType(soap, NULL, NULL, "fims:ServicesType");
	case SOAP_TYPE_fims__ProfilesType:
		return soap_in_fims__ProfilesType(soap, NULL, NULL, "fims:ProfilesType");
	case SOAP_TYPE_fims__ResourcesType:
		return soap_in_fims__ResourcesType(soap, NULL, NULL, "fims:ResourcesType");
	case SOAP_TYPE_fims__InnerFaultType:
		return soap_in_fims__InnerFaultType(soap, NULL, NULL, "fims:InnerFaultType");
	case SOAP_TYPE_fims__FaultType:
		return soap_in_fims__FaultType(soap, NULL, NULL, "fims:FaultType");
	case SOAP_TYPE_fims__ListFilterType:
		return soap_in_fims__ListFilterType(soap, NULL, NULL, "fims:ListFilterType");
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		return soap_in_fims__QueryServiceDescriptionResponseType(soap, NULL, NULL, "fims:QueryServiceDescriptionResponseType");
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		return soap_in_fims__QueryServiceDescriptionRequestType(soap, NULL, NULL, "fims:QueryServiceDescriptionRequestType");
	case SOAP_TYPE_fims__QueryJobResponseType:
		return soap_in_fims__QueryJobResponseType(soap, NULL, NULL, "fims:QueryJobResponseType");
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		return soap_in_fims__QueryJobRequestByFilterType(soap, NULL, NULL, "fims:QueryJobRequestByFilterType");
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		return soap_in_fims__QueryJobRequestByIDType(soap, NULL, NULL, "fims:QueryJobRequestByIDType");
	case SOAP_TYPE_fims__QueryJobRequestType:
		return soap_in_fims__QueryJobRequestType(soap, NULL, NULL, "fims:QueryJobRequestType");
	case SOAP_TYPE_fims__ManageQueueResponseType:
		return soap_in_fims__ManageQueueResponseType(soap, NULL, NULL, "fims:ManageQueueResponseType");
	case SOAP_TYPE_fims__ManageQueueRequestType:
		return soap_in_fims__ManageQueueRequestType(soap, NULL, NULL, "fims:ManageQueueRequestType");
	case SOAP_TYPE_fims__ManageJobResponseType:
		return soap_in_fims__ManageJobResponseType(soap, NULL, NULL, "fims:ManageJobResponseType");
	case SOAP_TYPE_fims__ManageJobRequestType:
		return soap_in_fims__ManageJobRequestType(soap, NULL, NULL, "fims:ManageJobRequestType");
	case SOAP_TYPE_fims__StartJobByLatestType:
		return soap_in_fims__StartJobByLatestType(soap, NULL, NULL, "fims:StartJobByLatestType");
	case SOAP_TYPE_fims__StartJobByTimeType:
		return soap_in_fims__StartJobByTimeType(soap, NULL, NULL, "fims:StartJobByTimeType");
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		return soap_in_fims__StartJobByNoWaitType(soap, NULL, NULL, "fims:StartJobByNoWaitType");
	case SOAP_TYPE_fims__StartJobType:
		return soap_in_fims__StartJobType(soap, NULL, NULL, "fims:StartJobType");
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		return soap_in_fims__StopProcessByOpenEndType(soap, NULL, NULL, "fims:StopProcessByOpenEndType");
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		return soap_in_fims__StopProcessByServiceDefinedTimeType(soap, NULL, NULL, "fims:StopProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		return soap_in_fims__StopProcessByTimeMarkType(soap, NULL, NULL, "fims:StopProcessByTimeMarkType");
	case SOAP_TYPE_fims__StopProcessByDurationType:
		return soap_in_fims__StopProcessByDurationType(soap, NULL, NULL, "fims:StopProcessByDurationType");
	case SOAP_TYPE_fims__StopProcessByTimeType:
		return soap_in_fims__StopProcessByTimeType(soap, NULL, NULL, "fims:StopProcessByTimeType");
	case SOAP_TYPE_fims__StopProcessType:
		return soap_in_fims__StopProcessType(soap, NULL, NULL, "fims:StopProcessType");
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		return soap_in_fims__StartProcessByServiceDefinedTimeType(soap, NULL, NULL, "fims:StartProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		return soap_in_fims__StartProcessByTimeMarkType(soap, NULL, NULL, "fims:StartProcessByTimeMarkType");
	case SOAP_TYPE_fims__StartProcessByTimeType:
		return soap_in_fims__StartProcessByTimeType(soap, NULL, NULL, "fims:StartProcessByTimeType");
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		return soap_in_fims__StartProcessByNoWaitType(soap, NULL, NULL, "fims:StartProcessByNoWaitType");
	case SOAP_TYPE_fims__StartProcessType:
		return soap_in_fims__StartProcessType(soap, NULL, NULL, "fims:StartProcessType");
	case SOAP_TYPE_fims__HashFunctionType:
		return soap_in_fims__HashFunctionType(soap, NULL, NULL, "fims:HashFunctionType");
	case SOAP_TYPE_fims__StorageType:
		return soap_in_fims__StorageType(soap, NULL, NULL, "fims:StorageType");
	case SOAP_TYPE_fims__TimeType:
		return soap_in_fims__TimeType(soap, NULL, NULL, "fims:TimeType");
	case SOAP_TYPE_fims__DurationType:
		return soap_in_fims__DurationType(soap, NULL, NULL, "fims:DurationType");
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		return soap_in_fims__ProcessedInfoByFramesType(soap, NULL, NULL, "fims:ProcessedInfoByFramesType");
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		return soap_in_fims__ProcessedInfoByBytesType(soap, NULL, NULL, "fims:ProcessedInfoByBytesType");
	case SOAP_TYPE_fims__ProcessedInfoType:
		return soap_in_fims__ProcessedInfoType(soap, NULL, NULL, "fims:ProcessedInfoType");
	case SOAP_TYPE_fims__EditUnitNumberType:
		return soap_in_fims__EditUnitNumberType(soap, NULL, NULL, "fims:EditUnitNumberType");
	case SOAP_TYPE_fims__HashType:
		return soap_in_fims__HashType(soap, NULL, NULL, "fims:HashType");
	case SOAP_TYPE_fims__RationalType:
		return soap_in_fims__RationalType(soap, NULL, NULL, "fims:RationalType");
	case SOAP_TYPE_fims__LengthType:
		return soap_in_fims__LengthType(soap, NULL, NULL, "fims:LengthType");
	case SOAP_TYPE_fims__TechnicalAttributeType:
		return soap_in_fims__TechnicalAttributeType(soap, NULL, NULL, "fims:TechnicalAttributeType");
	case SOAP_TYPE_fims__TransformAtomType:
		return soap_in_fims__TransformAtomType(soap, NULL, NULL, "fims:TransformAtomType");
	case SOAP_TYPE_fims__TransferAtomType:
		return soap_in_fims__TransferAtomType(soap, NULL, NULL, "fims:TransferAtomType");
	case SOAP_TYPE_fims__FolderLocatorType:
		return soap_in_fims__FolderLocatorType(soap, NULL, NULL, "fims:FolderLocatorType");
	case SOAP_TYPE_fims__ListFileLocatorType:
		return soap_in_fims__ListFileLocatorType(soap, NULL, NULL, "fims:ListFileLocatorType");
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		return soap_in_fims__SimpleFileLocatorType(soap, NULL, NULL, "fims:SimpleFileLocatorType");
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		return soap_in_fims__BMEssenceLocatorType(soap, NULL, NULL, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_fims__BMContentFormatType:
		return soap_in_fims__BMContentFormatType(soap, NULL, NULL, "fims:BMContentFormatType");
	case SOAP_TYPE_fims__DescriptionType:
		return soap_in_fims__DescriptionType(soap, NULL, NULL, "fims:DescriptionType");
	case SOAP_TYPE_fims__BMContentType:
		return soap_in_fims__BMContentType(soap, NULL, NULL, "fims:BMContentType");
	case SOAP_TYPE_fims__BMObjectType:
		return soap_in_fims__BMObjectType(soap, NULL, NULL, "fims:BMObjectType");
	case SOAP_TYPE_fims__CodecType:
		return soap_in_fims__CodecType(soap, NULL, NULL, "fims:CodecType");
	case SOAP_TYPE_fims__BMTrackType:
		return soap_in_fims__BMTrackType(soap, NULL, NULL, "fims:BMTrackType");
	case SOAP_TYPE_fims__ContainerFormatType:
		return soap_in_fims__ContainerFormatType(soap, NULL, NULL, "fims:ContainerFormatType");
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		return soap_in_fims__AncillaryDataFormatType(soap, NULL, NULL, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_fims__CaptioningFormatType:
		return soap_in_fims__CaptioningFormatType(soap, NULL, NULL, "fims:CaptioningFormatType");
	case SOAP_TYPE_fims__DataFormatType:
		return soap_in_fims__DataFormatType(soap, NULL, NULL, "fims:DataFormatType");
	case SOAP_TYPE_fims__AudioFormatType:
		return soap_in_fims__AudioFormatType(soap, NULL, NULL, "fims:AudioFormatType");
	case SOAP_TYPE_fims__VideoFormatType:
		return soap_in_fims__VideoFormatType(soap, NULL, NULL, "fims:VideoFormatType");
	case SOAP_TYPE_fims__FormatType:
		return soap_in_fims__FormatType(soap, NULL, NULL, "fims:FormatType");
	case SOAP_TYPE_fims__JobType:
		return soap_in_fims__JobType(soap, NULL, NULL, "fims:JobType");
	case SOAP_TYPE_fims__QueueType:
		return soap_in_fims__QueueType(soap, NULL, NULL, "fims:QueueType");
	case SOAP_TYPE_fims__ProfileType:
		return soap_in_fims__ProfileType(soap, NULL, NULL, "fims:ProfileType");
	case SOAP_TYPE_fims__ServiceType:
		return soap_in_fims__ServiceType(soap, NULL, NULL, "fims:ServiceType");
	case SOAP_TYPE_fims__AsyncEndpointType:
		return soap_in_fims__AsyncEndpointType(soap, NULL, NULL, "fims:AsyncEndpointType");
	case SOAP_TYPE_fims__ResourceType:
		return soap_in_fims__ResourceType(soap, NULL, NULL, "fims:ResourceType");
	case SOAP_TYPE_fims__ResourceReferenceType:
		return soap_in_fims__ResourceReferenceType(soap, NULL, NULL, "fims:ResourceReferenceType");
	case SOAP_TYPE_fims__ExtensionAttributes:
		return soap_in_fims__ExtensionAttributes(soap, NULL, NULL, "fims:ExtensionAttributes");
	case SOAP_TYPE_fims__ExtensionGroup:
		return soap_in_fims__ExtensionGroup(soap, NULL, NULL, "fims:ExtensionGroup");
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		return soap_in_edlprovider__EdlProviderFaultType(soap, NULL, NULL, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		return soap_in_edlprovider__EdlCreateResponseType(soap, NULL, NULL, "edlprovider:EdlCreateResponseType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		return soap_in_edlprovider__EdlCreateRequestDoubleType(soap, NULL, NULL, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		return soap_in_edlprovider__EdlCreateRequestType(soap, NULL, NULL, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		return soap_in_edlprovider__EdlCreateRequestBaseType(soap, NULL, NULL, "edlprovider:EdlCreateRequestBaseType");
	case SOAP_TYPE_edlprovider__ClipType:
		return soap_in_edlprovider__ClipType(soap, NULL, NULL, "edlprovider:ClipType");
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		return soap_in_edlprovider__ArrayOfClips(soap, NULL, NULL, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		return soap_in_edlprovider__ArrayOfstring(soap, NULL, NULL, "edlprovider:ArrayOfstring");
	case SOAP_TYPE_xsd__time:
		return soap_in_xsd__time(soap, NULL, NULL, "xsd:time");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_in_xsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__language:
		return soap_in_xsd__language(soap, NULL, NULL, "xsd:language");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__gYear:
		return soap_in_xsd__gYear(soap, NULL, NULL, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_in_xsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_std__wstring:
		return soap_in_std__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, NULL, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType:
		return soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(soap, NULL, NULL, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateResponseType:
		return soap_in_PointerToedlprovider__EdlCreateResponseType(soap, NULL, NULL, "edlprovider:EdlCreateResponseType");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType:
		return soap_in_PointerToedlprovider__EdlCreateRequestType(soap, NULL, NULL, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_PointerToedlprovider__ArrayOfstring:
		return soap_in_PointerToedlprovider__ArrayOfstring(soap, NULL, NULL, "edlprovider:ArrayOfstring");
	case SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType:
		return soap_in_PointerToedlprovider__EdlProviderFaultType(soap, NULL, NULL, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat:
		return soap_in_PointerTo_fims__ContainerFormatType_containerFormat(soap, NULL, NULL, "fims:ContainerFormatType-containerFormat");
	case SOAP_TYPE_PointerTofims__AncillaryDataFormatType:
		return soap_in_PointerTofims__AncillaryDataFormatType(soap, NULL, NULL, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_PointerTofims__CaptioningFormatType:
		return soap_in_PointerTofims__CaptioningFormatType(soap, NULL, NULL, "fims:CaptioningFormatType");
	case SOAP_TYPE_PointerTofims__AudioSampleType:
		return soap_in_PointerTofims__AudioSampleType(soap, NULL, NULL, "fims:AudioSampleType");
	case SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration:
		return soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(soap, NULL, NULL, "fims:AudioFormatType-trackConfiguration");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_in_PointerToxsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_PointerTofims__ScanningOrderType:
		return soap_in_PointerTofims__ScanningOrderType(soap, NULL, NULL, "fims:ScanningOrderType");
	case SOAP_TYPE_PointerTofims__ScanningFormatType:
		return soap_in_PointerTofims__ScanningFormatType(soap, NULL, NULL, "fims:ScanningFormatType");
	case SOAP_TYPE_PointerTofims__BitRateModeType:
		return soap_in_PointerTofims__BitRateModeType(soap, NULL, NULL, "fims:BitRateModeType");
	case SOAP_TYPE_PointerTofims__BMTrackType:
		return soap_in_PointerTofims__BMTrackType(soap, NULL, NULL, "fims:BMTrackType");
	case SOAP_TYPE_PointerTofims__CodecType:
		return soap_in_PointerTofims__CodecType(soap, NULL, NULL, "fims:CodecType");
	case SOAP_TYPE_PointerTofims__RationalType:
		return soap_in_PointerTofims__RationalType(soap, NULL, NULL, "fims:RationalType");
	case SOAP_TYPE_PointerTofims__LengthType:
		return soap_in_PointerTofims__LengthType(soap, NULL, NULL, "fims:LengthType");
	case SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType:
		return soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, NULL, NULL, "fims:BMEssenceLocatorType-containerMimeType");
	case SOAP_TYPE_PointerTofims__StorageType:
		return soap_in_PointerTofims__StorageType(soap, NULL, NULL, "fims:StorageType");
	case SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType:
		return soap_in_PointerTo_fims__BMContentFormatType_mimeType(soap, NULL, NULL, "fims:BMContentFormatType-mimeType");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_in_PointerTounsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTofims__HashType:
		return soap_in_PointerTofims__HashType(soap, NULL, NULL, "fims:HashType");
	case SOAP_TYPE_PointerTo_fims__formatCollection:
		return soap_in_PointerTo_fims__formatCollection(soap, NULL, NULL, "fims:formatCollection");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorsType:
		return soap_in_PointerTofims__BMEssenceLocatorsType(soap, NULL, NULL, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType:
		return soap_in_PointerTofimsdescription__bmContentDescriptionType(soap, NULL, NULL, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE_PointerTofims__DescriptionsType:
		return soap_in_PointerTofims__DescriptionsType(soap, NULL, NULL, "fims:DescriptionsType");
	case SOAP_TYPE_PointerTofims__BMContentFormatsType:
		return soap_in_PointerTofims__BMContentFormatsType(soap, NULL, NULL, "fims:BMContentFormatsType");
	case SOAP_TYPE_PointerTofims__BMContentsType:
		return soap_in_PointerTofims__BMContentsType(soap, NULL, NULL, "fims:BMContentsType");
	case SOAP_TYPE_PointerTofims__TechnicalAttributeType:
		return soap_in_PointerTofims__TechnicalAttributeType(soap, NULL, NULL, "fims:TechnicalAttributeType");
	case SOAP_TYPE_PointerTofims__ProcessedInfoType:
		return soap_in_PointerTofims__ProcessedInfoType(soap, NULL, NULL, "fims:ProcessedInfoType");
	case SOAP_TYPE_PointerTofims__StartJobType:
		return soap_in_PointerTofims__StartJobType(soap, NULL, NULL, "fims:StartJobType");
	case SOAP_TYPE_PointerTofims__BMObjectsType:
		return soap_in_PointerTofims__BMObjectsType(soap, NULL, NULL, "fims:BMObjectsType");
	case SOAP_TYPE_PointerTofims__JobStatusType:
		return soap_in_PointerTofims__JobStatusType(soap, NULL, NULL, "fims:JobStatusType");
	case SOAP_TYPE_PointerTofims__QueueStatusType:
		return soap_in_PointerTofims__QueueStatusType(soap, NULL, NULL, "fims:QueueStatusType");
	case SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription:
		return soap_in_PointerTo_fims__ServiceType_serviceDescription(soap, NULL, NULL, "fims:ServiceType-serviceDescription");
	case SOAP_TYPE_PointerTofims__ListFilterType:
		return soap_in_PointerTofims__ListFilterType(soap, NULL, NULL, "fims:ListFilterType");
	case SOAP_TYPE_PointerTofims__DurationType:
		return soap_in_PointerTofims__DurationType(soap, NULL, NULL, "fims:DurationType");
	case SOAP_TYPE_PointerTofims__TimeType:
		return soap_in_PointerTofims__TimeType(soap, NULL, NULL, "fims:TimeType");
	case SOAP_TYPE_PointerTofims__AsyncEndpointType:
		return soap_in_PointerTofims__AsyncEndpointType(soap, NULL, NULL, "fims:AsyncEndpointType");
	case SOAP_TYPE_PointerToedlprovider__EDLProviderErrorCodeType:
		return soap_in_PointerToedlprovider__EDLProviderErrorCodeType(soap, NULL, NULL, "edlprovider:EDLProviderErrorCodeType");
	case SOAP_TYPE_PointerTo_fimsdescription__addressType_country:
		return soap_in_PointerTo_fimsdescription__addressType_country(soap, NULL, NULL, "fimsdescription:addressType-country");
	case SOAP_TYPE_PointerTofimsdescription__addressType:
		return soap_in_PointerTofimsdescription__addressType(soap, NULL, NULL, "fimsdescription:addressType");
	case SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment:
		return soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, NULL, NULL, "fimsdescription:organisationDetailsType-organisationDepartment");
	case SOAP_TYPE_PointerTofimsdescription__detailsType:
		return soap_in_PointerTofimsdescription__detailsType(soap, NULL, NULL, "fimsdescription:detailsType");
	case SOAP_TYPE_PointerTofimsdescription__organisationDetailsType:
		return soap_in_PointerTofimsdescription__organisationDetailsType(soap, NULL, NULL, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative:
		return soap_in_PointerTo_fimsdescription__dateType_alternative(soap, NULL, NULL, "fimsdescription:dateType-alternative");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_issued:
		return soap_in_PointerTo_fimsdescription__dateType_issued(soap, NULL, NULL, "fimsdescription:dateType-issued");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_modified:
		return soap_in_PointerTo_fimsdescription__dateType_modified(soap, NULL, NULL, "fimsdescription:dateType-modified");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_created:
		return soap_in_PointerTo_fimsdescription__dateType_created(soap, NULL, NULL, "fimsdescription:dateType-created");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_in_PointerToxsd__date(soap, NULL, NULL, "xsd:date");
	case SOAP_TYPE_PointerToxsd__gYear:
		return soap_in_PointerToxsd__gYear(soap, NULL, NULL, "xsd:gYear");
	case SOAP_TYPE_PointerTofimsdescription__contactDetailsType:
		return soap_in_PointerTofimsdescription__contactDetailsType(soap, NULL, NULL, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial:
		return soap_in_PointerTo_fimsdescription__coverageType_spatial(soap, NULL, NULL, "fimsdescription:coverageType-spatial");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates:
		return soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, NULL, NULL, "fimsdescription:coverageType-spatial-coordinates");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal:
		return soap_in_PointerTo_fimsdescription__coverageType_temporal(soap, NULL, NULL, "fimsdescription:coverageType-temporal");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_in_PointerTo_xml__lang(soap, NULL, NULL, "xml:lang");
	case SOAP_TYPE_PointerTofimsdescription__rightsType:
		return soap_in_PointerTofimsdescription__rightsType(soap, NULL, NULL, "fimsdescription:rightsType");
	case SOAP_TYPE_PointerTofimsdescription__coverageType:
		return soap_in_PointerTofimsdescription__coverageType(soap, NULL, NULL, "fimsdescription:coverageType");
	case SOAP_TYPE_PointerTofimsdescription__languageType:
		return soap_in_PointerTofimsdescription__languageType(soap, NULL, NULL, "fimsdescription:languageType");
	case SOAP_TYPE_PointerTofimsdescription__identifierType:
		return soap_in_PointerTofimsdescription__identifierType(soap, NULL, NULL, "fimsdescription:identifierType");
	case SOAP_TYPE_PointerTofimsdescription__typeType:
		return soap_in_PointerTofimsdescription__typeType(soap, NULL, NULL, "fimsdescription:typeType");
	case SOAP_TYPE_PointerTofimsdescription__dateType:
		return soap_in_PointerTofimsdescription__dateType(soap, NULL, NULL, "fimsdescription:dateType");
	case SOAP_TYPE_PointerTofimsdescription__descriptionType:
		return soap_in_PointerTofimsdescription__descriptionType(soap, NULL, NULL, "fimsdescription:descriptionType");
	case SOAP_TYPE_PointerTofimsdescription__subjectType:
		return soap_in_PointerTofimsdescription__subjectType(soap, NULL, NULL, "fimsdescription:subjectType");
	case SOAP_TYPE_PointerTofimsdescription__entityType:
		return soap_in_PointerTofimsdescription__entityType(soap, NULL, NULL, "fimsdescription:entityType");
	case SOAP_TYPE_PointerTofimsdescription__titleType:
		return soap_in_PointerTofimsdescription__titleType(soap, NULL, NULL, "fimsdescription:titleType");
	case SOAP_TYPE_PointerTofimsdescription__textElementType:
		return soap_in_PointerTofimsdescription__textElementType(soap, NULL, NULL, "fimsdescription:textElementType");
	case SOAP_TYPE_PointerTofims__DescriptionType:
		return soap_in_PointerTofims__DescriptionType(soap, NULL, NULL, "fims:DescriptionType");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorType:
		return soap_in_PointerTofims__BMEssenceLocatorType(soap, NULL, NULL, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_PointerTofims__BMContentFormatType:
		return soap_in_PointerTofims__BMContentFormatType(soap, NULL, NULL, "fims:BMContentFormatType");
	case SOAP_TYPE_PointerTofims__BMContentType:
		return soap_in_PointerTofims__BMContentType(soap, NULL, NULL, "fims:BMContentType");
	case SOAP_TYPE_PointerTofims__BMObjectType:
		return soap_in_PointerTofims__BMObjectType(soap, NULL, NULL, "fims:BMObjectType");
	case SOAP_TYPE_PointerTofims__DataFormatType:
		return soap_in_PointerTofims__DataFormatType(soap, NULL, NULL, "fims:DataFormatType");
	case SOAP_TYPE_PointerTofims__ProfileType:
		return soap_in_PointerTofims__ProfileType(soap, NULL, NULL, "fims:ProfileType");
	case SOAP_TYPE_PointerTofims__ResourceType:
		return soap_in_PointerTofims__ResourceType(soap, NULL, NULL, "fims:ResourceType");
	case SOAP_TYPE_PointerTofims__InnerFaultType:
		return soap_in_PointerTofims__InnerFaultType(soap, NULL, NULL, "fims:InnerFaultType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTofims__ServiceType:
		return soap_in_PointerTofims__ServiceType(soap, NULL, NULL, "fims:ServiceType");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTofims__JobsType:
		return soap_in_PointerTofims__JobsType(soap, NULL, NULL, "fims:JobsType");
	case SOAP_TYPE_PointerTofims__QueueType:
		return soap_in_PointerTofims__QueueType(soap, NULL, NULL, "fims:QueueType");
	case SOAP_TYPE_PointerTofims__JobType:
		return soap_in_PointerTofims__JobType(soap, NULL, NULL, "fims:JobType");
	case SOAP_TYPE_PointerTofims__PriorityType:
		return soap_in_PointerTofims__PriorityType(soap, NULL, NULL, "fims:PriorityType");
	case SOAP_TYPE_PointerToxsd__time:
		return soap_in_PointerToxsd__time(soap, NULL, NULL, "xsd:time");
	case SOAP_TYPE_PointerTofims__Timecode:
		return soap_in_PointerTofims__Timecode(soap, NULL, NULL, "fims:Timecode");
	case SOAP_TYPE_PointerTofims__EditUnitNumberType:
		return soap_in_PointerTofims__EditUnitNumberType(soap, NULL, NULL, "fims:EditUnitNumberType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTofims__TimecodeDuration:
		return soap_in_PointerTofims__TimecodeDuration(soap, NULL, NULL, "fims:TimecodeDuration");
	case SOAP_TYPE_PointerTofims__HashFunctionType:
		return soap_in_PointerTofims__HashFunctionType(soap, NULL, NULL, "fims:HashFunctionType");
	case SOAP_TYPE_PointerTofims__ContainerFormatType:
		return soap_in_PointerTofims__ContainerFormatType(soap, NULL, NULL, "fims:ContainerFormatType");
	case SOAP_TYPE_PointerTofims__AudioFormatType:
		return soap_in_PointerTofims__AudioFormatType(soap, NULL, NULL, "fims:AudioFormatType");
	case SOAP_TYPE_PointerTofims__VideoFormatType:
		return soap_in_PointerTofims__VideoFormatType(soap, NULL, NULL, "fims:VideoFormatType");
	case SOAP_TYPE_PointerToxsd__language:
		return soap_in_PointerToxsd__language(soap, NULL, NULL, "xsd:language");
	case SOAP_TYPE_PointerTofims__UID:
		return soap_in_PointerTofims__UID(soap, NULL, NULL, "fims:UID");
	case SOAP_TYPE_PointerTofims__ExtensionAttributes:
		return soap_in_PointerTofims__ExtensionAttributes(soap, NULL, NULL, "fims:ExtensionAttributes");
	case SOAP_TYPE_PointerTofims__ExtensionGroup:
		return soap_in_PointerTofims__ExtensionGroup(soap, NULL, NULL, "fims:ExtensionGroup");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTofims__RevisionIDType:
		return soap_in_PointerTofims__RevisionIDType(soap, NULL, NULL, "fims:RevisionIDType");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_in_PointerTostd__wstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToedlprovider__ArrayOfClips:
		return soap_in_PointerToedlprovider__ArrayOfClips(soap, NULL, NULL, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_PointerToedlprovider__ClipType:
		return soap_in_PointerToedlprovider__ClipType(soap, NULL, NULL, "edlprovider:ClipType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "fims:TimecodeDuration"))
		{	*type = SOAP_TYPE_fims__TimecodeDuration;
			return soap_in_fims__TimecodeDuration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:Timecode"))
		{	*type = SOAP_TYPE_fims__Timecode;
			return soap_in_fims__Timecode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:RevisionIDType"))
		{	*type = SOAP_TYPE_fims__RevisionIDType;
			return soap_in_fims__RevisionIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourceIDType"))
		{	*type = SOAP_TYPE_fims__ResourceIDType;
			return soap_in_fims__ResourceIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EmptyID"))
		{	*type = SOAP_TYPE_fims__EmptyID;
			return soap_in_fims__EmptyID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:UL"))
		{	*type = SOAP_TYPE_fims__UL;
			return soap_in_fims__UL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:UMID"))
		{	*type = SOAP_TYPE_fims__UMID;
			return soap_in_fims__UMID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:UUID"))
		{	*type = SOAP_TYPE_fims__UUID;
			return soap_in_fims__UUID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:UID"))
		{	*type = SOAP_TYPE_fims__UID;
			return soap_in_fims__UID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:languageType"))
		{	*type = SOAP_TYPE_fimsdescription__languageType;
			return soap_in_fimsdescription__languageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:addressType"))
		{	*type = SOAP_TYPE_fimsdescription__addressType;
			return soap_in_fimsdescription__addressType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:detailsType"))
		{	*type = SOAP_TYPE_fimsdescription__detailsType;
			return soap_in_fimsdescription__detailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:organisationDetailsType"))
		{	*type = SOAP_TYPE_fimsdescription__organisationDetailsType;
			return soap_in_fimsdescription__organisationDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:contactDetailsType"))
		{	*type = SOAP_TYPE_fimsdescription__contactDetailsType;
			return soap_in_fimsdescription__contactDetailsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:entityType"))
		{	*type = SOAP_TYPE_fimsdescription__entityType;
			return soap_in_fimsdescription__entityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType"))
		{	*type = SOAP_TYPE_fimsdescription__dateType;
			return soap_in_fimsdescription__dateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:textElementType"))
		{	*type = SOAP_TYPE_fimsdescription__textElementType;
			return soap_in_fimsdescription__textElementType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:rightsType"))
		{	*type = SOAP_TYPE_fimsdescription__rightsType;
			return soap_in_fimsdescription__rightsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType"))
		{	*type = SOAP_TYPE_fimsdescription__coverageType;
			return soap_in_fimsdescription__coverageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:descriptionType"))
		{	*type = SOAP_TYPE_fimsdescription__descriptionType;
			return soap_in_fimsdescription__descriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType"))
		{	*type = SOAP_TYPE_fimsdescription__typeType;
			return soap_in_fimsdescription__typeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:subjectType"))
		{	*type = SOAP_TYPE_fimsdescription__subjectType;
			return soap_in_fimsdescription__subjectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:identifierType"))
		{	*type = SOAP_TYPE_fimsdescription__identifierType;
			return soap_in_fimsdescription__identifierType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:titleType"))
		{	*type = SOAP_TYPE_fimsdescription__titleType;
			return soap_in_fimsdescription__titleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:bmContentDescriptionType"))
		{	*type = SOAP_TYPE_fimsdescription__bmContentDescriptionType;
			return soap_in_fimsdescription__bmContentDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DescriptionsType"))
		{	*type = SOAP_TYPE_fims__DescriptionsType;
			return soap_in_fims__DescriptionsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorsType"))
		{	*type = SOAP_TYPE_fims__BMEssenceLocatorsType;
			return soap_in_fims__BMEssenceLocatorsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentFormatsType"))
		{	*type = SOAP_TYPE_fims__BMContentFormatsType;
			return soap_in_fims__BMContentFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentsType"))
		{	*type = SOAP_TYPE_fims__BMContentsType;
			return soap_in_fims__BMContentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMObjectsType"))
		{	*type = SOAP_TYPE_fims__BMObjectsType;
			return soap_in_fims__BMObjectsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DataFormatsType"))
		{	*type = SOAP_TYPE_fims__DataFormatsType;
			return soap_in_fims__DataFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContainerFormatsType"))
		{	*type = SOAP_TYPE_fims__ContainerFormatsType;
			return soap_in_fims__ContainerFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioFormatsType"))
		{	*type = SOAP_TYPE_fims__AudioFormatsType;
			return soap_in_fims__AudioFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:VideoFormatsType"))
		{	*type = SOAP_TYPE_fims__VideoFormatsType;
			return soap_in_fims__VideoFormatsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobsType"))
		{	*type = SOAP_TYPE_fims__JobsType;
			return soap_in_fims__JobsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueuesType"))
		{	*type = SOAP_TYPE_fims__QueuesType;
			return soap_in_fims__QueuesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ServicesType"))
		{	*type = SOAP_TYPE_fims__ServicesType;
			return soap_in_fims__ServicesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProfilesType"))
		{	*type = SOAP_TYPE_fims__ProfilesType;
			return soap_in_fims__ProfilesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourcesType"))
		{	*type = SOAP_TYPE_fims__ResourcesType;
			return soap_in_fims__ResourcesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:InnerFaultType"))
		{	*type = SOAP_TYPE_fims__InnerFaultType;
			return soap_in_fims__InnerFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:FaultType"))
		{	*type = SOAP_TYPE_fims__FaultType;
			return soap_in_fims__FaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ListFilterType"))
		{	*type = SOAP_TYPE_fims__ListFilterType;
			return soap_in_fims__ListFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryServiceDescriptionResponseType"))
		{	*type = SOAP_TYPE_fims__QueryServiceDescriptionResponseType;
			return soap_in_fims__QueryServiceDescriptionResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryServiceDescriptionRequestType"))
		{	*type = SOAP_TYPE_fims__QueryServiceDescriptionRequestType;
			return soap_in_fims__QueryServiceDescriptionRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobResponseType"))
		{	*type = SOAP_TYPE_fims__QueryJobResponseType;
			return soap_in_fims__QueryJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobRequestByFilterType"))
		{	*type = SOAP_TYPE_fims__QueryJobRequestByFilterType;
			return soap_in_fims__QueryJobRequestByFilterType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobRequestByIDType"))
		{	*type = SOAP_TYPE_fims__QueryJobRequestByIDType;
			return soap_in_fims__QueryJobRequestByIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryJobRequestType"))
		{	*type = SOAP_TYPE_fims__QueryJobRequestType;
			return soap_in_fims__QueryJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageQueueResponseType"))
		{	*type = SOAP_TYPE_fims__ManageQueueResponseType;
			return soap_in_fims__ManageQueueResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageQueueRequestType"))
		{	*type = SOAP_TYPE_fims__ManageQueueRequestType;
			return soap_in_fims__ManageQueueRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageJobResponseType"))
		{	*type = SOAP_TYPE_fims__ManageJobResponseType;
			return soap_in_fims__ManageJobResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ManageJobRequestType"))
		{	*type = SOAP_TYPE_fims__ManageJobRequestType;
			return soap_in_fims__ManageJobRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobByLatestType"))
		{	*type = SOAP_TYPE_fims__StartJobByLatestType;
			return soap_in_fims__StartJobByLatestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobByTimeType"))
		{	*type = SOAP_TYPE_fims__StartJobByTimeType;
			return soap_in_fims__StartJobByTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobByNoWaitType"))
		{	*type = SOAP_TYPE_fims__StartJobByNoWaitType;
			return soap_in_fims__StartJobByNoWaitType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartJobType"))
		{	*type = SOAP_TYPE_fims__StartJobType;
			return soap_in_fims__StartJobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByOpenEndType"))
		{	*type = SOAP_TYPE_fims__StopProcessByOpenEndType;
			return soap_in_fims__StopProcessByOpenEndType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByServiceDefinedTimeType"))
		{	*type = SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType;
			return soap_in_fims__StopProcessByServiceDefinedTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByTimeMarkType"))
		{	*type = SOAP_TYPE_fims__StopProcessByTimeMarkType;
			return soap_in_fims__StopProcessByTimeMarkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByDurationType"))
		{	*type = SOAP_TYPE_fims__StopProcessByDurationType;
			return soap_in_fims__StopProcessByDurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessByTimeType"))
		{	*type = SOAP_TYPE_fims__StopProcessByTimeType;
			return soap_in_fims__StopProcessByTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StopProcessType"))
		{	*type = SOAP_TYPE_fims__StopProcessType;
			return soap_in_fims__StopProcessType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByServiceDefinedTimeType"))
		{	*type = SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType;
			return soap_in_fims__StartProcessByServiceDefinedTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByTimeMarkType"))
		{	*type = SOAP_TYPE_fims__StartProcessByTimeMarkType;
			return soap_in_fims__StartProcessByTimeMarkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByTimeType"))
		{	*type = SOAP_TYPE_fims__StartProcessByTimeType;
			return soap_in_fims__StartProcessByTimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessByNoWaitType"))
		{	*type = SOAP_TYPE_fims__StartProcessByNoWaitType;
			return soap_in_fims__StartProcessByNoWaitType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StartProcessType"))
		{	*type = SOAP_TYPE_fims__StartProcessType;
			return soap_in_fims__StartProcessType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:HashFunctionType"))
		{	*type = SOAP_TYPE_fims__HashFunctionType;
			return soap_in_fims__HashFunctionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StorageType"))
		{	*type = SOAP_TYPE_fims__StorageType;
			return soap_in_fims__StorageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:TimeType"))
		{	*type = SOAP_TYPE_fims__TimeType;
			return soap_in_fims__TimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DurationType"))
		{	*type = SOAP_TYPE_fims__DurationType;
			return soap_in_fims__DurationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProcessedInfoByFramesType"))
		{	*type = SOAP_TYPE_fims__ProcessedInfoByFramesType;
			return soap_in_fims__ProcessedInfoByFramesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProcessedInfoByBytesType"))
		{	*type = SOAP_TYPE_fims__ProcessedInfoByBytesType;
			return soap_in_fims__ProcessedInfoByBytesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProcessedInfoType"))
		{	*type = SOAP_TYPE_fims__ProcessedInfoType;
			return soap_in_fims__ProcessedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:EditUnitNumberType"))
		{	*type = SOAP_TYPE_fims__EditUnitNumberType;
			return soap_in_fims__EditUnitNumberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:HashType"))
		{	*type = SOAP_TYPE_fims__HashType;
			return soap_in_fims__HashType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:RationalType"))
		{	*type = SOAP_TYPE_fims__RationalType;
			return soap_in_fims__RationalType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:LengthType"))
		{	*type = SOAP_TYPE_fims__LengthType;
			return soap_in_fims__LengthType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:TechnicalAttributeType"))
		{	*type = SOAP_TYPE_fims__TechnicalAttributeType;
			return soap_in_fims__TechnicalAttributeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:TransformAtomType"))
		{	*type = SOAP_TYPE_fims__TransformAtomType;
			return soap_in_fims__TransformAtomType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:TransferAtomType"))
		{	*type = SOAP_TYPE_fims__TransferAtomType;
			return soap_in_fims__TransferAtomType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:FolderLocatorType"))
		{	*type = SOAP_TYPE_fims__FolderLocatorType;
			return soap_in_fims__FolderLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ListFileLocatorType"))
		{	*type = SOAP_TYPE_fims__ListFileLocatorType;
			return soap_in_fims__ListFileLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:SimpleFileLocatorType"))
		{	*type = SOAP_TYPE_fims__SimpleFileLocatorType;
			return soap_in_fims__SimpleFileLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorType"))
		{	*type = SOAP_TYPE_fims__BMEssenceLocatorType;
			return soap_in_fims__BMEssenceLocatorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentFormatType"))
		{	*type = SOAP_TYPE_fims__BMContentFormatType;
			return soap_in_fims__BMContentFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DescriptionType"))
		{	*type = SOAP_TYPE_fims__DescriptionType;
			return soap_in_fims__DescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentType"))
		{	*type = SOAP_TYPE_fims__BMContentType;
			return soap_in_fims__BMContentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMObjectType"))
		{	*type = SOAP_TYPE_fims__BMObjectType;
			return soap_in_fims__BMObjectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CodecType"))
		{	*type = SOAP_TYPE_fims__CodecType;
			return soap_in_fims__CodecType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMTrackType"))
		{	*type = SOAP_TYPE_fims__BMTrackType;
			return soap_in_fims__BMTrackType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ContainerFormatType"))
		{	*type = SOAP_TYPE_fims__ContainerFormatType;
			return soap_in_fims__ContainerFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AncillaryDataFormatType"))
		{	*type = SOAP_TYPE_fims__AncillaryDataFormatType;
			return soap_in_fims__AncillaryDataFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:CaptioningFormatType"))
		{	*type = SOAP_TYPE_fims__CaptioningFormatType;
			return soap_in_fims__CaptioningFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:DataFormatType"))
		{	*type = SOAP_TYPE_fims__DataFormatType;
			return soap_in_fims__DataFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioFormatType"))
		{	*type = SOAP_TYPE_fims__AudioFormatType;
			return soap_in_fims__AudioFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:VideoFormatType"))
		{	*type = SOAP_TYPE_fims__VideoFormatType;
			return soap_in_fims__VideoFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:FormatType"))
		{	*type = SOAP_TYPE_fims__FormatType;
			return soap_in_fims__FormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobType"))
		{	*type = SOAP_TYPE_fims__JobType;
			return soap_in_fims__JobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueueType"))
		{	*type = SOAP_TYPE_fims__QueueType;
			return soap_in_fims__QueueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ProfileType"))
		{	*type = SOAP_TYPE_fims__ProfileType;
			return soap_in_fims__ProfileType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ServiceType"))
		{	*type = SOAP_TYPE_fims__ServiceType;
			return soap_in_fims__ServiceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AsyncEndpointType"))
		{	*type = SOAP_TYPE_fims__AsyncEndpointType;
			return soap_in_fims__AsyncEndpointType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourceType"))
		{	*type = SOAP_TYPE_fims__ResourceType;
			return soap_in_fims__ResourceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ResourceReferenceType"))
		{	*type = SOAP_TYPE_fims__ResourceReferenceType;
			return soap_in_fims__ResourceReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ExtensionAttributes"))
		{	*type = SOAP_TYPE_fims__ExtensionAttributes;
			return soap_in_fims__ExtensionAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ExtensionGroup"))
		{	*type = SOAP_TYPE_fims__ExtensionGroup;
			return soap_in_fims__ExtensionGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlProviderFaultType"))
		{	*type = SOAP_TYPE_edlprovider__EdlProviderFaultType;
			return soap_in_edlprovider__EdlProviderFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateResponseType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateResponseType;
			return soap_in_edlprovider__EdlCreateResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateRequestDoubleType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType;
			return soap_in_edlprovider__EdlCreateRequestDoubleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateRequestType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateRequestType;
			return soap_in_edlprovider__EdlCreateRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EdlCreateRequestBaseType"))
		{	*type = SOAP_TYPE_edlprovider__EdlCreateRequestBaseType;
			return soap_in_edlprovider__EdlCreateRequestBaseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:ClipType"))
		{	*type = SOAP_TYPE_edlprovider__ClipType;
			return soap_in_edlprovider__ClipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:ArrayOfClips"))
		{	*type = SOAP_TYPE_edlprovider__ArrayOfClips;
			return soap_in_edlprovider__ArrayOfClips(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:ArrayOfstring"))
		{	*type = SOAP_TYPE_edlprovider__ArrayOfstring;
			return soap_in_edlprovider__ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:time"))
		{	*type = SOAP_TYPE_xsd__time;
			return soap_in_xsd__time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_xsd__positiveInteger;
			return soap_in_xsd__positiveInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:language"))
		{	*type = SOAP_TYPE_xsd__language;
			return soap_in_xsd__language(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:gYear"))
		{	*type = SOAP_TYPE_xsd__gYear;
			return soap_in_xsd__gYear(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	*type = SOAP_TYPE_xsd__date;
			return soap_in_xsd__date(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	*type = SOAP_TYPE_xsd__NMTOKEN;
			return soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__wstring;
			return soap_in_std__wstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueryServiceDescriptionRequestType-responseType"))
		{	*type = SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType;
			return soap_in__fims__QueryServiceDescriptionRequestType_responseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobInfoSelectionType"))
		{	*type = SOAP_TYPE_fims__JobInfoSelectionType;
			return soap_in_fims__JobInfoSelectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ErrorCodeType"))
		{	*type = SOAP_TYPE_fims__ErrorCodeType;
			return soap_in_fims__ErrorCodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BitRateModeType"))
		{	*type = SOAP_TYPE_fims__BitRateModeType;
			return soap_in_fims__BitRateModeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ScanningOrderType"))
		{	*type = SOAP_TYPE_fims__ScanningOrderType;
			return soap_in_fims__ScanningOrderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ScanningFormatType"))
		{	*type = SOAP_TYPE_fims__ScanningFormatType;
			return soap_in_fims__ScanningFormatType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioSampleType"))
		{	*type = SOAP_TYPE_fims__AudioSampleType;
			return soap_in_fims__AudioSampleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobStatusType"))
		{	*type = SOAP_TYPE_fims__JobStatusType;
			return soap_in_fims__JobStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:HashFunctionTypes"))
		{	*type = SOAP_TYPE_fims__HashFunctionTypes;
			return soap_in_fims__HashFunctionTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:JobCommandType"))
		{	*type = SOAP_TYPE_fims__JobCommandType;
			return soap_in_fims__JobCommandType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueueCommandType"))
		{	*type = SOAP_TYPE_fims__QueueCommandType;
			return soap_in_fims__QueueCommandType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:StorageTypes"))
		{	*type = SOAP_TYPE_fims__StorageTypes;
			return soap_in_fims__StorageTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:PriorityType"))
		{	*type = SOAP_TYPE_fims__PriorityType;
			return soap_in_fims__PriorityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:QueueStatusType"))
		{	*type = SOAP_TYPE_fims__QueueStatusType;
			return soap_in_fims__QueueStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "edlprovider:EDLProviderErrorCodeType"))
		{	*type = SOAP_TYPE_edlprovider__EDLProviderErrorCodeType;
			return soap_in_edlprovider__EDLProviderErrorCodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "fims:ContainerFormatType-containerFormat"))
		{	*type = SOAP_TYPE__fims__ContainerFormatType_containerFormat;
			return soap_in__fims__ContainerFormatType_containerFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:AudioFormatType-trackConfiguration"))
		{	*type = SOAP_TYPE__fims__AudioFormatType_trackConfiguration;
			return soap_in__fims__AudioFormatType_trackConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMEssenceLocatorType-containerMimeType"))
		{	*type = SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType;
			return soap_in__fims__BMEssenceLocatorType_containerMimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:BMContentFormatType-mimeType"))
		{	*type = SOAP_TYPE__fims__BMContentFormatType_mimeType;
			return soap_in__fims__BMContentFormatType_mimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:ServiceType-serviceDescription"))
		{	*type = SOAP_TYPE__fims__ServiceType_serviceDescription;
			return soap_in__fims__ServiceType_serviceDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:addressType-country"))
		{	*type = SOAP_TYPE__fimsdescription__addressType_country;
			return soap_in__fimsdescription__addressType_country(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:organisationDetailsType-organisationDepartment"))
		{	*type = SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment;
			return soap_in__fimsdescription__organisationDetailsType_organisationDepartment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:entityType-role"))
		{	*type = SOAP_TYPE__fimsdescription__entityType_role;
			return soap_in__fimsdescription__entityType_role(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-alternative"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_alternative;
			return soap_in__fimsdescription__dateType_alternative(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-issued"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_issued;
			return soap_in__fimsdescription__dateType_issued(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-modified"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_modified;
			return soap_in__fimsdescription__dateType_modified(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:dateType-created"))
		{	*type = SOAP_TYPE__fimsdescription__dateType_created;
			return soap_in__fimsdescription__dateType_created(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-spatial-coordinates"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates;
			return soap_in__fimsdescription__coverageType_spatial_coordinates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-spatial-locationName"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_spatial_locationName;
			return soap_in__fimsdescription__coverageType_spatial_locationName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-spatial"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_spatial;
			return soap_in__fimsdescription__coverageType_spatial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:coverageType-temporal"))
		{	*type = SOAP_TYPE__fimsdescription__coverageType_temporal;
			return soap_in__fimsdescription__coverageType_temporal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType-targetAudience"))
		{	*type = SOAP_TYPE__fimsdescription__typeType_targetAudience;
			return soap_in__fimsdescription__typeType_targetAudience(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType-objectType"))
		{	*type = SOAP_TYPE__fimsdescription__typeType_objectType;
			return soap_in__fimsdescription__typeType_objectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fimsdescription:typeType-genre"))
		{	*type = SOAP_TYPE__fimsdescription__typeType_genre;
			return soap_in__fimsdescription__typeType_genre(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "fims:formatCollection"))
		{	*type = SOAP_TYPE__fims__formatCollection;
			return soap_in__fims__formatCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType:
		return soap_out__fims__QueryServiceDescriptionRequestType_responseType(soap, tag, id, (const enum _fims__QueryServiceDescriptionRequestType_responseType *)ptr, "fims:QueryServiceDescriptionRequestType-responseType");
	case SOAP_TYPE_fims__JobInfoSelectionType:
		return soap_out_fims__JobInfoSelectionType(soap, tag, id, (const enum fims__JobInfoSelectionType *)ptr, "fims:JobInfoSelectionType");
	case SOAP_TYPE_fims__ErrorCodeType:
		return soap_out_fims__ErrorCodeType(soap, tag, id, (const enum fims__ErrorCodeType *)ptr, "fims:ErrorCodeType");
	case SOAP_TYPE_fims__BitRateModeType:
		return soap_out_fims__BitRateModeType(soap, tag, id, (const enum fims__BitRateModeType *)ptr, "fims:BitRateModeType");
	case SOAP_TYPE_fims__ScanningOrderType:
		return soap_out_fims__ScanningOrderType(soap, tag, id, (const enum fims__ScanningOrderType *)ptr, "fims:ScanningOrderType");
	case SOAP_TYPE_fims__ScanningFormatType:
		return soap_out_fims__ScanningFormatType(soap, tag, id, (const enum fims__ScanningFormatType *)ptr, "fims:ScanningFormatType");
	case SOAP_TYPE_fims__AudioSampleType:
		return soap_out_fims__AudioSampleType(soap, tag, id, (const enum fims__AudioSampleType *)ptr, "fims:AudioSampleType");
	case SOAP_TYPE_fims__JobStatusType:
		return soap_out_fims__JobStatusType(soap, tag, id, (const enum fims__JobStatusType *)ptr, "fims:JobStatusType");
	case SOAP_TYPE_fims__HashFunctionTypes:
		return soap_out_fims__HashFunctionTypes(soap, tag, id, (const enum fims__HashFunctionTypes *)ptr, "fims:HashFunctionTypes");
	case SOAP_TYPE_fims__JobCommandType:
		return soap_out_fims__JobCommandType(soap, tag, id, (const enum fims__JobCommandType *)ptr, "fims:JobCommandType");
	case SOAP_TYPE_fims__QueueCommandType:
		return soap_out_fims__QueueCommandType(soap, tag, id, (const enum fims__QueueCommandType *)ptr, "fims:QueueCommandType");
	case SOAP_TYPE_fims__StorageTypes:
		return soap_out_fims__StorageTypes(soap, tag, id, (const enum fims__StorageTypes *)ptr, "fims:StorageTypes");
	case SOAP_TYPE_fims__PriorityType:
		return soap_out_fims__PriorityType(soap, tag, id, (const enum fims__PriorityType *)ptr, "fims:PriorityType");
	case SOAP_TYPE_fims__QueueStatusType:
		return soap_out_fims__QueueStatusType(soap, tag, id, (const enum fims__QueueStatusType *)ptr, "fims:QueueStatusType");
	case SOAP_TYPE_edlprovider__EDLProviderErrorCodeType:
		return soap_out_edlprovider__EDLProviderErrorCodeType(soap, tag, id, (const enum edlprovider__EDLProviderErrorCodeType *)ptr, "edlprovider:EDLProviderErrorCodeType");
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		return ((_fims__ContainerFormatType_containerFormat *)ptr)->soap_out(soap, "fims:ContainerFormatType-containerFormat", id, NULL);
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		return ((_fims__AudioFormatType_trackConfiguration *)ptr)->soap_out(soap, "fims:AudioFormatType-trackConfiguration", id, NULL);
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		return ((_fims__BMEssenceLocatorType_containerMimeType *)ptr)->soap_out(soap, "fims:BMEssenceLocatorType-containerMimeType", id, NULL);
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		return ((_fims__BMContentFormatType_mimeType *)ptr)->soap_out(soap, "fims:BMContentFormatType-mimeType", id, NULL);
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		return ((_fims__ServiceType_serviceDescription *)ptr)->soap_out(soap, "fims:ServiceType-serviceDescription", id, NULL);
	case SOAP_TYPE__fimsdescription__addressType_country:
		return ((_fimsdescription__addressType_country *)ptr)->soap_out(soap, "fimsdescription:addressType-country", id, NULL);
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		return ((_fimsdescription__organisationDetailsType_organisationDepartment *)ptr)->soap_out(soap, "fimsdescription:organisationDetailsType-organisationDepartment", id, NULL);
	case SOAP_TYPE__fimsdescription__entityType_role:
		return ((_fimsdescription__entityType_role *)ptr)->soap_out(soap, "fimsdescription:entityType-role", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		return ((_fimsdescription__dateType_alternative *)ptr)->soap_out(soap, "fimsdescription:dateType-alternative", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_issued:
		return ((_fimsdescription__dateType_issued *)ptr)->soap_out(soap, "fimsdescription:dateType-issued", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_modified:
		return ((_fimsdescription__dateType_modified *)ptr)->soap_out(soap, "fimsdescription:dateType-modified", id, NULL);
	case SOAP_TYPE__fimsdescription__dateType_created:
		return ((_fimsdescription__dateType_created *)ptr)->soap_out(soap, "fimsdescription:dateType-created", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		return ((_fimsdescription__coverageType_spatial_coordinates *)ptr)->soap_out(soap, "fimsdescription:coverageType-spatial-coordinates", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		return ((_fimsdescription__coverageType_spatial_locationName *)ptr)->soap_out(soap, "fimsdescription:coverageType-spatial-locationName", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		return ((_fimsdescription__coverageType_spatial *)ptr)->soap_out(soap, "fimsdescription:coverageType-spatial", id, NULL);
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		return ((_fimsdescription__coverageType_temporal *)ptr)->soap_out(soap, "fimsdescription:coverageType-temporal", id, NULL);
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		return ((_fimsdescription__typeType_targetAudience *)ptr)->soap_out(soap, "fimsdescription:typeType-targetAudience", id, NULL);
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		return ((_fimsdescription__typeType_objectType *)ptr)->soap_out(soap, "fimsdescription:typeType-objectType", id, NULL);
	case SOAP_TYPE__fimsdescription__typeType_genre:
		return ((_fimsdescription__typeType_genre *)ptr)->soap_out(soap, "fimsdescription:typeType-genre", id, NULL);
	case SOAP_TYPE_fims__TimecodeDuration:
		return soap_out_fims__TimecodeDuration(soap, tag, id, (const std::wstring *)ptr, "fims:TimecodeDuration");
	case SOAP_TYPE_fims__Timecode:
		return soap_out_fims__Timecode(soap, tag, id, (const std::wstring *)ptr, "fims:Timecode");
	case SOAP_TYPE_fims__RevisionIDType:
		return soap_out_fims__RevisionIDType(soap, tag, id, (const std::wstring *)ptr, "fims:RevisionIDType");
	case SOAP_TYPE_fims__ResourceIDType:
		return soap_out_fims__ResourceIDType(soap, tag, id, (const std::wstring *)ptr, "fims:ResourceIDType");
	case SOAP_TYPE_fims__EmptyID:
		return soap_out_fims__EmptyID(soap, tag, id, (const std::wstring *)ptr, "fims:EmptyID");
	case SOAP_TYPE_fims__UL:
		return soap_out_fims__UL(soap, tag, id, (const std::wstring *)ptr, "fims:UL");
	case SOAP_TYPE_fims__UMID:
		return soap_out_fims__UMID(soap, tag, id, (const std::wstring *)ptr, "fims:UMID");
	case SOAP_TYPE_fims__UUID:
		return soap_out_fims__UUID(soap, tag, id, (const std::wstring *)ptr, "fims:UUID");
	case SOAP_TYPE_fims__UID:
		return soap_out_fims__UID(soap, tag, id, (const std::wstring *)ptr, "fims:UID");
	case SOAP_TYPE_fimsdescription__languageType:
		return ((fimsdescription__languageType *)ptr)->soap_out(soap, tag, id, "fimsdescription:languageType");
	case SOAP_TYPE_fimsdescription__addressType:
		return ((fimsdescription__addressType *)ptr)->soap_out(soap, tag, id, "fimsdescription:addressType");
	case SOAP_TYPE_fimsdescription__detailsType:
		return ((fimsdescription__detailsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:detailsType");
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		return ((fimsdescription__organisationDetailsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		return ((fimsdescription__contactDetailsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_fimsdescription__entityType:
		return ((fimsdescription__entityType *)ptr)->soap_out(soap, tag, id, "fimsdescription:entityType");
	case SOAP_TYPE_fimsdescription__dateType:
		return ((fimsdescription__dateType *)ptr)->soap_out(soap, tag, id, "fimsdescription:dateType");
	case SOAP_TYPE_fimsdescription__textElementType:
		return ((fimsdescription__textElementType *)ptr)->soap_out(soap, tag, id, "fimsdescription:textElementType");
	case SOAP_TYPE_fimsdescription__rightsType:
		return ((fimsdescription__rightsType *)ptr)->soap_out(soap, tag, id, "fimsdescription:rightsType");
	case SOAP_TYPE_fimsdescription__coverageType:
		return ((fimsdescription__coverageType *)ptr)->soap_out(soap, tag, id, "fimsdescription:coverageType");
	case SOAP_TYPE_fimsdescription__descriptionType:
		return ((fimsdescription__descriptionType *)ptr)->soap_out(soap, tag, id, "fimsdescription:descriptionType");
	case SOAP_TYPE_fimsdescription__typeType:
		return ((fimsdescription__typeType *)ptr)->soap_out(soap, tag, id, "fimsdescription:typeType");
	case SOAP_TYPE_fimsdescription__subjectType:
		return ((fimsdescription__subjectType *)ptr)->soap_out(soap, tag, id, "fimsdescription:subjectType");
	case SOAP_TYPE_fimsdescription__identifierType:
		return ((fimsdescription__identifierType *)ptr)->soap_out(soap, tag, id, "fimsdescription:identifierType");
	case SOAP_TYPE_fimsdescription__titleType:
		return ((fimsdescription__titleType *)ptr)->soap_out(soap, tag, id, "fimsdescription:titleType");
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		return ((fimsdescription__bmContentDescriptionType *)ptr)->soap_out(soap, tag, id, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE__fims__formatCollection:
		return ((_fims__formatCollection *)ptr)->soap_out(soap, "fims:formatCollection", id, NULL);
	case SOAP_TYPE_fims__DescriptionsType:
		return ((fims__DescriptionsType *)ptr)->soap_out(soap, tag, id, "fims:DescriptionsType");
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		return ((fims__BMEssenceLocatorsType *)ptr)->soap_out(soap, tag, id, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_fims__BMContentFormatsType:
		return ((fims__BMContentFormatsType *)ptr)->soap_out(soap, tag, id, "fims:BMContentFormatsType");
	case SOAP_TYPE_fims__BMContentsType:
		return ((fims__BMContentsType *)ptr)->soap_out(soap, tag, id, "fims:BMContentsType");
	case SOAP_TYPE_fims__BMObjectsType:
		return ((fims__BMObjectsType *)ptr)->soap_out(soap, tag, id, "fims:BMObjectsType");
	case SOAP_TYPE_fims__DataFormatsType:
		return ((fims__DataFormatsType *)ptr)->soap_out(soap, tag, id, "fims:DataFormatsType");
	case SOAP_TYPE_fims__ContainerFormatsType:
		return ((fims__ContainerFormatsType *)ptr)->soap_out(soap, tag, id, "fims:ContainerFormatsType");
	case SOAP_TYPE_fims__AudioFormatsType:
		return ((fims__AudioFormatsType *)ptr)->soap_out(soap, tag, id, "fims:AudioFormatsType");
	case SOAP_TYPE_fims__VideoFormatsType:
		return ((fims__VideoFormatsType *)ptr)->soap_out(soap, tag, id, "fims:VideoFormatsType");
	case SOAP_TYPE_fims__JobsType:
		return ((fims__JobsType *)ptr)->soap_out(soap, tag, id, "fims:JobsType");
	case SOAP_TYPE_fims__QueuesType:
		return ((fims__QueuesType *)ptr)->soap_out(soap, tag, id, "fims:QueuesType");
	case SOAP_TYPE_fims__ServicesType:
		return ((fims__ServicesType *)ptr)->soap_out(soap, tag, id, "fims:ServicesType");
	case SOAP_TYPE_fims__ProfilesType:
		return ((fims__ProfilesType *)ptr)->soap_out(soap, tag, id, "fims:ProfilesType");
	case SOAP_TYPE_fims__ResourcesType:
		return ((fims__ResourcesType *)ptr)->soap_out(soap, tag, id, "fims:ResourcesType");
	case SOAP_TYPE_fims__InnerFaultType:
		return ((fims__InnerFaultType *)ptr)->soap_out(soap, tag, id, "fims:InnerFaultType");
	case SOAP_TYPE_fims__FaultType:
		return ((fims__FaultType *)ptr)->soap_out(soap, tag, id, "fims:FaultType");
	case SOAP_TYPE_fims__ListFilterType:
		return ((fims__ListFilterType *)ptr)->soap_out(soap, tag, id, "fims:ListFilterType");
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		return ((fims__QueryServiceDescriptionResponseType *)ptr)->soap_out(soap, tag, id, "fims:QueryServiceDescriptionResponseType");
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		return ((fims__QueryServiceDescriptionRequestType *)ptr)->soap_out(soap, tag, id, "fims:QueryServiceDescriptionRequestType");
	case SOAP_TYPE_fims__QueryJobResponseType:
		return ((fims__QueryJobResponseType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobResponseType");
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		return ((fims__QueryJobRequestByFilterType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobRequestByFilterType");
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		return ((fims__QueryJobRequestByIDType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobRequestByIDType");
	case SOAP_TYPE_fims__QueryJobRequestType:
		return ((fims__QueryJobRequestType *)ptr)->soap_out(soap, tag, id, "fims:QueryJobRequestType");
	case SOAP_TYPE_fims__ManageQueueResponseType:
		return ((fims__ManageQueueResponseType *)ptr)->soap_out(soap, tag, id, "fims:ManageQueueResponseType");
	case SOAP_TYPE_fims__ManageQueueRequestType:
		return ((fims__ManageQueueRequestType *)ptr)->soap_out(soap, tag, id, "fims:ManageQueueRequestType");
	case SOAP_TYPE_fims__ManageJobResponseType:
		return ((fims__ManageJobResponseType *)ptr)->soap_out(soap, tag, id, "fims:ManageJobResponseType");
	case SOAP_TYPE_fims__ManageJobRequestType:
		return ((fims__ManageJobRequestType *)ptr)->soap_out(soap, tag, id, "fims:ManageJobRequestType");
	case SOAP_TYPE_fims__StartJobByLatestType:
		return ((fims__StartJobByLatestType *)ptr)->soap_out(soap, tag, id, "fims:StartJobByLatestType");
	case SOAP_TYPE_fims__StartJobByTimeType:
		return ((fims__StartJobByTimeType *)ptr)->soap_out(soap, tag, id, "fims:StartJobByTimeType");
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		return ((fims__StartJobByNoWaitType *)ptr)->soap_out(soap, tag, id, "fims:StartJobByNoWaitType");
	case SOAP_TYPE_fims__StartJobType:
		return ((fims__StartJobType *)ptr)->soap_out(soap, tag, id, "fims:StartJobType");
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		return ((fims__StopProcessByOpenEndType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByOpenEndType");
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		return ((fims__StopProcessByServiceDefinedTimeType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		return ((fims__StopProcessByTimeMarkType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByTimeMarkType");
	case SOAP_TYPE_fims__StopProcessByDurationType:
		return ((fims__StopProcessByDurationType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByDurationType");
	case SOAP_TYPE_fims__StopProcessByTimeType:
		return ((fims__StopProcessByTimeType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessByTimeType");
	case SOAP_TYPE_fims__StopProcessType:
		return ((fims__StopProcessType *)ptr)->soap_out(soap, tag, id, "fims:StopProcessType");
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		return ((fims__StartProcessByServiceDefinedTimeType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByServiceDefinedTimeType");
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		return ((fims__StartProcessByTimeMarkType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByTimeMarkType");
	case SOAP_TYPE_fims__StartProcessByTimeType:
		return ((fims__StartProcessByTimeType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByTimeType");
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		return ((fims__StartProcessByNoWaitType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessByNoWaitType");
	case SOAP_TYPE_fims__StartProcessType:
		return ((fims__StartProcessType *)ptr)->soap_out(soap, tag, id, "fims:StartProcessType");
	case SOAP_TYPE_fims__HashFunctionType:
		return ((fims__HashFunctionType *)ptr)->soap_out(soap, tag, id, "fims:HashFunctionType");
	case SOAP_TYPE_fims__StorageType:
		return ((fims__StorageType *)ptr)->soap_out(soap, tag, id, "fims:StorageType");
	case SOAP_TYPE_fims__TimeType:
		return ((fims__TimeType *)ptr)->soap_out(soap, tag, id, "fims:TimeType");
	case SOAP_TYPE_fims__DurationType:
		return ((fims__DurationType *)ptr)->soap_out(soap, tag, id, "fims:DurationType");
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		return ((fims__ProcessedInfoByFramesType *)ptr)->soap_out(soap, tag, id, "fims:ProcessedInfoByFramesType");
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		return ((fims__ProcessedInfoByBytesType *)ptr)->soap_out(soap, tag, id, "fims:ProcessedInfoByBytesType");
	case SOAP_TYPE_fims__ProcessedInfoType:
		return ((fims__ProcessedInfoType *)ptr)->soap_out(soap, tag, id, "fims:ProcessedInfoType");
	case SOAP_TYPE_fims__EditUnitNumberType:
		return ((fims__EditUnitNumberType *)ptr)->soap_out(soap, tag, id, "fims:EditUnitNumberType");
	case SOAP_TYPE_fims__HashType:
		return ((fims__HashType *)ptr)->soap_out(soap, tag, id, "fims:HashType");
	case SOAP_TYPE_fims__RationalType:
		return ((fims__RationalType *)ptr)->soap_out(soap, tag, id, "fims:RationalType");
	case SOAP_TYPE_fims__LengthType:
		return ((fims__LengthType *)ptr)->soap_out(soap, tag, id, "fims:LengthType");
	case SOAP_TYPE_fims__TechnicalAttributeType:
		return ((fims__TechnicalAttributeType *)ptr)->soap_out(soap, tag, id, "fims:TechnicalAttributeType");
	case SOAP_TYPE_fims__TransformAtomType:
		return ((fims__TransformAtomType *)ptr)->soap_out(soap, tag, id, "fims:TransformAtomType");
	case SOAP_TYPE_fims__TransferAtomType:
		return ((fims__TransferAtomType *)ptr)->soap_out(soap, tag, id, "fims:TransferAtomType");
	case SOAP_TYPE_fims__FolderLocatorType:
		return ((fims__FolderLocatorType *)ptr)->soap_out(soap, tag, id, "fims:FolderLocatorType");
	case SOAP_TYPE_fims__ListFileLocatorType:
		return ((fims__ListFileLocatorType *)ptr)->soap_out(soap, tag, id, "fims:ListFileLocatorType");
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		return ((fims__SimpleFileLocatorType *)ptr)->soap_out(soap, tag, id, "fims:SimpleFileLocatorType");
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		return ((fims__BMEssenceLocatorType *)ptr)->soap_out(soap, tag, id, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_fims__BMContentFormatType:
		return ((fims__BMContentFormatType *)ptr)->soap_out(soap, tag, id, "fims:BMContentFormatType");
	case SOAP_TYPE_fims__DescriptionType:
		return ((fims__DescriptionType *)ptr)->soap_out(soap, tag, id, "fims:DescriptionType");
	case SOAP_TYPE_fims__BMContentType:
		return ((fims__BMContentType *)ptr)->soap_out(soap, tag, id, "fims:BMContentType");
	case SOAP_TYPE_fims__BMObjectType:
		return ((fims__BMObjectType *)ptr)->soap_out(soap, tag, id, "fims:BMObjectType");
	case SOAP_TYPE_fims__CodecType:
		return ((fims__CodecType *)ptr)->soap_out(soap, tag, id, "fims:CodecType");
	case SOAP_TYPE_fims__BMTrackType:
		return ((fims__BMTrackType *)ptr)->soap_out(soap, tag, id, "fims:BMTrackType");
	case SOAP_TYPE_fims__ContainerFormatType:
		return ((fims__ContainerFormatType *)ptr)->soap_out(soap, tag, id, "fims:ContainerFormatType");
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		return ((fims__AncillaryDataFormatType *)ptr)->soap_out(soap, tag, id, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_fims__CaptioningFormatType:
		return ((fims__CaptioningFormatType *)ptr)->soap_out(soap, tag, id, "fims:CaptioningFormatType");
	case SOAP_TYPE_fims__DataFormatType:
		return ((fims__DataFormatType *)ptr)->soap_out(soap, tag, id, "fims:DataFormatType");
	case SOAP_TYPE_fims__AudioFormatType:
		return ((fims__AudioFormatType *)ptr)->soap_out(soap, tag, id, "fims:AudioFormatType");
	case SOAP_TYPE_fims__VideoFormatType:
		return ((fims__VideoFormatType *)ptr)->soap_out(soap, tag, id, "fims:VideoFormatType");
	case SOAP_TYPE_fims__FormatType:
		return ((fims__FormatType *)ptr)->soap_out(soap, tag, id, "fims:FormatType");
	case SOAP_TYPE_fims__JobType:
		return ((fims__JobType *)ptr)->soap_out(soap, tag, id, "fims:JobType");
	case SOAP_TYPE_fims__QueueType:
		return ((fims__QueueType *)ptr)->soap_out(soap, tag, id, "fims:QueueType");
	case SOAP_TYPE_fims__ProfileType:
		return ((fims__ProfileType *)ptr)->soap_out(soap, tag, id, "fims:ProfileType");
	case SOAP_TYPE_fims__ServiceType:
		return ((fims__ServiceType *)ptr)->soap_out(soap, tag, id, "fims:ServiceType");
	case SOAP_TYPE_fims__AsyncEndpointType:
		return ((fims__AsyncEndpointType *)ptr)->soap_out(soap, tag, id, "fims:AsyncEndpointType");
	case SOAP_TYPE_fims__ResourceType:
		return ((fims__ResourceType *)ptr)->soap_out(soap, tag, id, "fims:ResourceType");
	case SOAP_TYPE_fims__ResourceReferenceType:
		return ((fims__ResourceReferenceType *)ptr)->soap_out(soap, tag, id, "fims:ResourceReferenceType");
	case SOAP_TYPE_fims__ExtensionAttributes:
		return ((fims__ExtensionAttributes *)ptr)->soap_out(soap, tag, id, "fims:ExtensionAttributes");
	case SOAP_TYPE_fims__ExtensionGroup:
		return ((fims__ExtensionGroup *)ptr)->soap_out(soap, tag, id, "fims:ExtensionGroup");
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		return ((edlprovider__EdlProviderFaultType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		return ((edlprovider__EdlCreateResponseType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateResponseType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		return ((edlprovider__EdlCreateRequestDoubleType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		return ((edlprovider__EdlCreateRequestType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		return ((edlprovider__EdlCreateRequestBaseType *)ptr)->soap_out(soap, tag, id, "edlprovider:EdlCreateRequestBaseType");
	case SOAP_TYPE_edlprovider__ClipType:
		return ((edlprovider__ClipType *)ptr)->soap_out(soap, tag, id, "edlprovider:ClipType");
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		return ((edlprovider__ArrayOfClips *)ptr)->soap_out(soap, tag, id, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		return ((edlprovider__ArrayOfstring *)ptr)->soap_out(soap, tag, id, "edlprovider:ArrayOfstring");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::wstring *)ptr, NULL);
	case SOAP_TYPE_xsd__time:
		return soap_out_xsd__time(soap, tag, id, (const std::wstring *)ptr, "xsd:time");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_out_xsd__positiveInteger(soap, tag, id, (const std::wstring *)ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::wstring *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__language:
		return soap_out_xsd__language(soap, tag, id, (const std::wstring *)ptr, "xsd:language");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::wstring *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__gYear:
		return soap_out_xsd__gYear(soap, tag, id, (const std::wstring *)ptr, "xsd:gYear");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::wstring *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_xsd__date(soap, tag, id, (const std::wstring *)ptr, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::wstring *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_xsd__NMTOKEN(soap, tag, id, (const std::wstring *)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_std__wstring:
		return soap_out_std__wstring(soap, tag, id, (const std::wstring *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType:
		return soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(soap, tag, id, (edlprovider__EdlCreateRequestDoubleType *const*)ptr, "edlprovider:EdlCreateRequestDoubleType");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateResponseType:
		return soap_out_PointerToedlprovider__EdlCreateResponseType(soap, tag, id, (edlprovider__EdlCreateResponseType *const*)ptr, "edlprovider:EdlCreateResponseType");
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType:
		return soap_out_PointerToedlprovider__EdlCreateRequestType(soap, tag, id, (edlprovider__EdlCreateRequestType *const*)ptr, "edlprovider:EdlCreateRequestType");
	case SOAP_TYPE_PointerToedlprovider__ArrayOfstring:
		return soap_out_PointerToedlprovider__ArrayOfstring(soap, tag, id, (edlprovider__ArrayOfstring *const*)ptr, "edlprovider:ArrayOfstring");
	case SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType:
		return soap_out_PointerToedlprovider__EdlProviderFaultType(soap, tag, id, (edlprovider__EdlProviderFaultType *const*)ptr, "edlprovider:EdlProviderFaultType");
	case SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat:
		return soap_out_PointerTo_fims__ContainerFormatType_containerFormat(soap, tag, id, (_fims__ContainerFormatType_containerFormat *const*)ptr, "fims:ContainerFormatType-containerFormat");
	case SOAP_TYPE_PointerTofims__AncillaryDataFormatType:
		return soap_out_PointerTofims__AncillaryDataFormatType(soap, tag, id, (fims__AncillaryDataFormatType *const*)ptr, "fims:AncillaryDataFormatType");
	case SOAP_TYPE_PointerTofims__CaptioningFormatType:
		return soap_out_PointerTofims__CaptioningFormatType(soap, tag, id, (fims__CaptioningFormatType *const*)ptr, "fims:CaptioningFormatType");
	case SOAP_TYPE_PointerTofims__AudioSampleType:
		return soap_out_PointerTofims__AudioSampleType(soap, tag, id, (enum fims__AudioSampleType *const*)ptr, "fims:AudioSampleType");
	case SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration:
		return soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(soap, tag, id, (_fims__AudioFormatType_trackConfiguration *const*)ptr, "fims:AudioFormatType-trackConfiguration");
	case SOAP_TYPE_PointerToxsd__decimal:
		return soap_out_PointerToxsd__decimal(soap, tag, id, (std::wstring *const*)ptr, "xsd:decimal");
	case SOAP_TYPE_PointerTofims__ScanningOrderType:
		return soap_out_PointerTofims__ScanningOrderType(soap, tag, id, (enum fims__ScanningOrderType *const*)ptr, "fims:ScanningOrderType");
	case SOAP_TYPE_PointerTofims__ScanningFormatType:
		return soap_out_PointerTofims__ScanningFormatType(soap, tag, id, (enum fims__ScanningFormatType *const*)ptr, "fims:ScanningFormatType");
	case SOAP_TYPE_PointerTofims__BitRateModeType:
		return soap_out_PointerTofims__BitRateModeType(soap, tag, id, (enum fims__BitRateModeType *const*)ptr, "fims:BitRateModeType");
	case SOAP_TYPE_PointerTofims__BMTrackType:
		return soap_out_PointerTofims__BMTrackType(soap, tag, id, (fims__BMTrackType *const*)ptr, "fims:BMTrackType");
	case SOAP_TYPE_PointerTofims__CodecType:
		return soap_out_PointerTofims__CodecType(soap, tag, id, (fims__CodecType *const*)ptr, "fims:CodecType");
	case SOAP_TYPE_PointerTofims__RationalType:
		return soap_out_PointerTofims__RationalType(soap, tag, id, (fims__RationalType *const*)ptr, "fims:RationalType");
	case SOAP_TYPE_PointerTofims__LengthType:
		return soap_out_PointerTofims__LengthType(soap, tag, id, (fims__LengthType *const*)ptr, "fims:LengthType");
	case SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType:
		return soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, tag, id, (_fims__BMEssenceLocatorType_containerMimeType *const*)ptr, "fims:BMEssenceLocatorType-containerMimeType");
	case SOAP_TYPE_PointerTofims__StorageType:
		return soap_out_PointerTofims__StorageType(soap, tag, id, (fims__StorageType *const*)ptr, "fims:StorageType");
	case SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType:
		return soap_out_PointerTo_fims__BMContentFormatType_mimeType(soap, tag, id, (_fims__BMContentFormatType_mimeType *const*)ptr, "fims:BMContentFormatType-mimeType");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_out_PointerTounsignedLONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTofims__HashType:
		return soap_out_PointerTofims__HashType(soap, tag, id, (fims__HashType *const*)ptr, "fims:HashType");
	case SOAP_TYPE_PointerTo_fims__formatCollection:
		return soap_out_PointerTo_fims__formatCollection(soap, tag, id, (_fims__formatCollection *const*)ptr, "fims:formatCollection");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorsType:
		return soap_out_PointerTofims__BMEssenceLocatorsType(soap, tag, id, (fims__BMEssenceLocatorsType *const*)ptr, "fims:BMEssenceLocatorsType");
	case SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType:
		return soap_out_PointerTofimsdescription__bmContentDescriptionType(soap, tag, id, (fimsdescription__bmContentDescriptionType *const*)ptr, "fimsdescription:bmContentDescriptionType");
	case SOAP_TYPE_PointerTofims__DescriptionsType:
		return soap_out_PointerTofims__DescriptionsType(soap, tag, id, (fims__DescriptionsType *const*)ptr, "fims:DescriptionsType");
	case SOAP_TYPE_PointerTofims__BMContentFormatsType:
		return soap_out_PointerTofims__BMContentFormatsType(soap, tag, id, (fims__BMContentFormatsType *const*)ptr, "fims:BMContentFormatsType");
	case SOAP_TYPE_PointerTofims__BMContentsType:
		return soap_out_PointerTofims__BMContentsType(soap, tag, id, (fims__BMContentsType *const*)ptr, "fims:BMContentsType");
	case SOAP_TYPE_PointerTofims__TechnicalAttributeType:
		return soap_out_PointerTofims__TechnicalAttributeType(soap, tag, id, (fims__TechnicalAttributeType *const*)ptr, "fims:TechnicalAttributeType");
	case SOAP_TYPE_PointerTofims__ProcessedInfoType:
		return soap_out_PointerTofims__ProcessedInfoType(soap, tag, id, (fims__ProcessedInfoType *const*)ptr, "fims:ProcessedInfoType");
	case SOAP_TYPE_PointerTofims__StartJobType:
		return soap_out_PointerTofims__StartJobType(soap, tag, id, (fims__StartJobType *const*)ptr, "fims:StartJobType");
	case SOAP_TYPE_PointerTofims__BMObjectsType:
		return soap_out_PointerTofims__BMObjectsType(soap, tag, id, (fims__BMObjectsType *const*)ptr, "fims:BMObjectsType");
	case SOAP_TYPE_PointerTofims__JobStatusType:
		return soap_out_PointerTofims__JobStatusType(soap, tag, id, (enum fims__JobStatusType *const*)ptr, "fims:JobStatusType");
	case SOAP_TYPE_PointerTofims__QueueStatusType:
		return soap_out_PointerTofims__QueueStatusType(soap, tag, id, (enum fims__QueueStatusType *const*)ptr, "fims:QueueStatusType");
	case SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription:
		return soap_out_PointerTo_fims__ServiceType_serviceDescription(soap, tag, id, (_fims__ServiceType_serviceDescription *const*)ptr, "fims:ServiceType-serviceDescription");
	case SOAP_TYPE_PointerTofims__ListFilterType:
		return soap_out_PointerTofims__ListFilterType(soap, tag, id, (fims__ListFilterType *const*)ptr, "fims:ListFilterType");
	case SOAP_TYPE_PointerTofims__DurationType:
		return soap_out_PointerTofims__DurationType(soap, tag, id, (fims__DurationType *const*)ptr, "fims:DurationType");
	case SOAP_TYPE_PointerTofims__TimeType:
		return soap_out_PointerTofims__TimeType(soap, tag, id, (fims__TimeType *const*)ptr, "fims:TimeType");
	case SOAP_TYPE_PointerTofims__AsyncEndpointType:
		return soap_out_PointerTofims__AsyncEndpointType(soap, tag, id, (fims__AsyncEndpointType *const*)ptr, "fims:AsyncEndpointType");
	case SOAP_TYPE_PointerToedlprovider__EDLProviderErrorCodeType:
		return soap_out_PointerToedlprovider__EDLProviderErrorCodeType(soap, tag, id, (enum edlprovider__EDLProviderErrorCodeType *const*)ptr, "edlprovider:EDLProviderErrorCodeType");
	case SOAP_TYPE_PointerTo_fimsdescription__addressType_country:
		return soap_out_PointerTo_fimsdescription__addressType_country(soap, tag, id, (_fimsdescription__addressType_country *const*)ptr, "fimsdescription:addressType-country");
	case SOAP_TYPE_PointerTofimsdescription__addressType:
		return soap_out_PointerTofimsdescription__addressType(soap, tag, id, (fimsdescription__addressType *const*)ptr, "fimsdescription:addressType");
	case SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment:
		return soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, id, (_fimsdescription__organisationDetailsType_organisationDepartment *const*)ptr, "fimsdescription:organisationDetailsType-organisationDepartment");
	case SOAP_TYPE_PointerTofimsdescription__detailsType:
		return soap_out_PointerTofimsdescription__detailsType(soap, tag, id, (fimsdescription__detailsType *const*)ptr, "fimsdescription:detailsType");
	case SOAP_TYPE_PointerTofimsdescription__organisationDetailsType:
		return soap_out_PointerTofimsdescription__organisationDetailsType(soap, tag, id, (fimsdescription__organisationDetailsType *const*)ptr, "fimsdescription:organisationDetailsType");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative:
		return soap_out_PointerTo_fimsdescription__dateType_alternative(soap, tag, id, (_fimsdescription__dateType_alternative *const*)ptr, "fimsdescription:dateType-alternative");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_issued:
		return soap_out_PointerTo_fimsdescription__dateType_issued(soap, tag, id, (_fimsdescription__dateType_issued *const*)ptr, "fimsdescription:dateType-issued");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_modified:
		return soap_out_PointerTo_fimsdescription__dateType_modified(soap, tag, id, (_fimsdescription__dateType_modified *const*)ptr, "fimsdescription:dateType-modified");
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_created:
		return soap_out_PointerTo_fimsdescription__dateType_created(soap, tag, id, (_fimsdescription__dateType_created *const*)ptr, "fimsdescription:dateType-created");
	case SOAP_TYPE_PointerToxsd__date:
		return soap_out_PointerToxsd__date(soap, tag, id, (std::wstring *const*)ptr, "xsd:date");
	case SOAP_TYPE_PointerToxsd__gYear:
		return soap_out_PointerToxsd__gYear(soap, tag, id, (std::wstring *const*)ptr, "xsd:gYear");
	case SOAP_TYPE_PointerTofimsdescription__contactDetailsType:
		return soap_out_PointerTofimsdescription__contactDetailsType(soap, tag, id, (fimsdescription__contactDetailsType *const*)ptr, "fimsdescription:contactDetailsType");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial:
		return soap_out_PointerTo_fimsdescription__coverageType_spatial(soap, tag, id, (_fimsdescription__coverageType_spatial *const*)ptr, "fimsdescription:coverageType-spatial");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates:
		return soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, tag, id, (_fimsdescription__coverageType_spatial_coordinates *const*)ptr, "fimsdescription:coverageType-spatial-coordinates");
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal:
		return soap_out_PointerTo_fimsdescription__coverageType_temporal(soap, tag, id, (_fimsdescription__coverageType_temporal *const*)ptr, "fimsdescription:coverageType-temporal");
	case SOAP_TYPE_PointerTo_xml__lang:
		return soap_out_PointerTo_xml__lang(soap, tag, id, (std::wstring *const*)ptr, "xml:lang");
	case SOAP_TYPE_PointerTofimsdescription__rightsType:
		return soap_out_PointerTofimsdescription__rightsType(soap, tag, id, (fimsdescription__rightsType *const*)ptr, "fimsdescription:rightsType");
	case SOAP_TYPE_PointerTofimsdescription__coverageType:
		return soap_out_PointerTofimsdescription__coverageType(soap, tag, id, (fimsdescription__coverageType *const*)ptr, "fimsdescription:coverageType");
	case SOAP_TYPE_PointerTofimsdescription__languageType:
		return soap_out_PointerTofimsdescription__languageType(soap, tag, id, (fimsdescription__languageType *const*)ptr, "fimsdescription:languageType");
	case SOAP_TYPE_PointerTofimsdescription__identifierType:
		return soap_out_PointerTofimsdescription__identifierType(soap, tag, id, (fimsdescription__identifierType *const*)ptr, "fimsdescription:identifierType");
	case SOAP_TYPE_PointerTofimsdescription__typeType:
		return soap_out_PointerTofimsdescription__typeType(soap, tag, id, (fimsdescription__typeType *const*)ptr, "fimsdescription:typeType");
	case SOAP_TYPE_PointerTofimsdescription__dateType:
		return soap_out_PointerTofimsdescription__dateType(soap, tag, id, (fimsdescription__dateType *const*)ptr, "fimsdescription:dateType");
	case SOAP_TYPE_PointerTofimsdescription__descriptionType:
		return soap_out_PointerTofimsdescription__descriptionType(soap, tag, id, (fimsdescription__descriptionType *const*)ptr, "fimsdescription:descriptionType");
	case SOAP_TYPE_PointerTofimsdescription__subjectType:
		return soap_out_PointerTofimsdescription__subjectType(soap, tag, id, (fimsdescription__subjectType *const*)ptr, "fimsdescription:subjectType");
	case SOAP_TYPE_PointerTofimsdescription__entityType:
		return soap_out_PointerTofimsdescription__entityType(soap, tag, id, (fimsdescription__entityType *const*)ptr, "fimsdescription:entityType");
	case SOAP_TYPE_PointerTofimsdescription__titleType:
		return soap_out_PointerTofimsdescription__titleType(soap, tag, id, (fimsdescription__titleType *const*)ptr, "fimsdescription:titleType");
	case SOAP_TYPE_PointerTofimsdescription__textElementType:
		return soap_out_PointerTofimsdescription__textElementType(soap, tag, id, (fimsdescription__textElementType *const*)ptr, "fimsdescription:textElementType");
	case SOAP_TYPE_PointerTofims__DescriptionType:
		return soap_out_PointerTofims__DescriptionType(soap, tag, id, (fims__DescriptionType *const*)ptr, "fims:DescriptionType");
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorType:
		return soap_out_PointerTofims__BMEssenceLocatorType(soap, tag, id, (fims__BMEssenceLocatorType *const*)ptr, "fims:BMEssenceLocatorType");
	case SOAP_TYPE_PointerTofims__BMContentFormatType:
		return soap_out_PointerTofims__BMContentFormatType(soap, tag, id, (fims__BMContentFormatType *const*)ptr, "fims:BMContentFormatType");
	case SOAP_TYPE_PointerTofims__BMContentType:
		return soap_out_PointerTofims__BMContentType(soap, tag, id, (fims__BMContentType *const*)ptr, "fims:BMContentType");
	case SOAP_TYPE_PointerTofims__BMObjectType:
		return soap_out_PointerTofims__BMObjectType(soap, tag, id, (fims__BMObjectType *const*)ptr, "fims:BMObjectType");
	case SOAP_TYPE_PointerTofims__DataFormatType:
		return soap_out_PointerTofims__DataFormatType(soap, tag, id, (fims__DataFormatType *const*)ptr, "fims:DataFormatType");
	case SOAP_TYPE_PointerTofims__ProfileType:
		return soap_out_PointerTofims__ProfileType(soap, tag, id, (fims__ProfileType *const*)ptr, "fims:ProfileType");
	case SOAP_TYPE_PointerTofims__ResourceType:
		return soap_out_PointerTofims__ResourceType(soap, tag, id, (fims__ResourceType *const*)ptr, "fims:ResourceType");
	case SOAP_TYPE_PointerTofims__InnerFaultType:
		return soap_out_PointerTofims__InnerFaultType(soap, tag, id, (fims__InnerFaultType *const*)ptr, "fims:InnerFaultType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTofims__ServiceType:
		return soap_out_PointerTofims__ServiceType(soap, tag, id, (fims__ServiceType *const*)ptr, "fims:ServiceType");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::wstring *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTofims__JobsType:
		return soap_out_PointerTofims__JobsType(soap, tag, id, (fims__JobsType *const*)ptr, "fims:JobsType");
	case SOAP_TYPE_PointerTofims__QueueType:
		return soap_out_PointerTofims__QueueType(soap, tag, id, (fims__QueueType *const*)ptr, "fims:QueueType");
	case SOAP_TYPE_PointerTofims__JobType:
		return soap_out_PointerTofims__JobType(soap, tag, id, (fims__JobType *const*)ptr, "fims:JobType");
	case SOAP_TYPE_PointerTofims__PriorityType:
		return soap_out_PointerTofims__PriorityType(soap, tag, id, (enum fims__PriorityType *const*)ptr, "fims:PriorityType");
	case SOAP_TYPE_PointerToxsd__time:
		return soap_out_PointerToxsd__time(soap, tag, id, (std::wstring *const*)ptr, "xsd:time");
	case SOAP_TYPE_PointerTofims__Timecode:
		return soap_out_PointerTofims__Timecode(soap, tag, id, (std::wstring *const*)ptr, "fims:Timecode");
	case SOAP_TYPE_PointerTofims__EditUnitNumberType:
		return soap_out_PointerTofims__EditUnitNumberType(soap, tag, id, (fims__EditUnitNumberType *const*)ptr, "fims:EditUnitNumberType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (LONG64 *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTofims__TimecodeDuration:
		return soap_out_PointerTofims__TimecodeDuration(soap, tag, id, (std::wstring *const*)ptr, "fims:TimecodeDuration");
	case SOAP_TYPE_PointerTofims__HashFunctionType:
		return soap_out_PointerTofims__HashFunctionType(soap, tag, id, (fims__HashFunctionType *const*)ptr, "fims:HashFunctionType");
	case SOAP_TYPE_PointerTofims__ContainerFormatType:
		return soap_out_PointerTofims__ContainerFormatType(soap, tag, id, (fims__ContainerFormatType *const*)ptr, "fims:ContainerFormatType");
	case SOAP_TYPE_PointerTofims__AudioFormatType:
		return soap_out_PointerTofims__AudioFormatType(soap, tag, id, (fims__AudioFormatType *const*)ptr, "fims:AudioFormatType");
	case SOAP_TYPE_PointerTofims__VideoFormatType:
		return soap_out_PointerTofims__VideoFormatType(soap, tag, id, (fims__VideoFormatType *const*)ptr, "fims:VideoFormatType");
	case SOAP_TYPE_PointerToxsd__language:
		return soap_out_PointerToxsd__language(soap, tag, id, (std::wstring *const*)ptr, "xsd:language");
	case SOAP_TYPE_PointerTofims__UID:
		return soap_out_PointerTofims__UID(soap, tag, id, (std::wstring *const*)ptr, "fims:UID");
	case SOAP_TYPE_PointerTofims__ExtensionAttributes:
		return soap_out_PointerTofims__ExtensionAttributes(soap, tag, id, (fims__ExtensionAttributes *const*)ptr, "fims:ExtensionAttributes");
	case SOAP_TYPE_PointerTofims__ExtensionGroup:
		return soap_out_PointerTofims__ExtensionGroup(soap, tag, id, (fims__ExtensionGroup *const*)ptr, "fims:ExtensionGroup");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::wstring *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::wstring *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTofims__RevisionIDType:
		return soap_out_PointerTofims__RevisionIDType(soap, tag, id, (std::wstring *const*)ptr, "fims:RevisionIDType");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTostd__wstring:
		return soap_out_PointerTostd__wstring(soap, tag, id, (std::wstring *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToedlprovider__ArrayOfClips:
		return soap_out_PointerToedlprovider__ArrayOfClips(soap, tag, id, (edlprovider__ArrayOfClips *const*)ptr, "edlprovider:ArrayOfClips");
	case SOAP_TYPE_PointerToedlprovider__ClipType:
		return soap_out_PointerToedlprovider__ClipType(soap, tag, id, (edlprovider__ClipType *const*)ptr, "edlprovider:ClipType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		((_fims__ContainerFormatType_containerFormat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		((_fims__AudioFormatType_trackConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		((_fims__BMEssenceLocatorType_containerMimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		((_fims__BMContentFormatType_mimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		((_fims__ServiceType_serviceDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__addressType_country:
		((_fimsdescription__addressType_country *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		((_fimsdescription__organisationDetailsType_organisationDepartment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__entityType_role:
		((_fimsdescription__entityType_role *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		((_fimsdescription__dateType_alternative *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_issued:
		((_fimsdescription__dateType_issued *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_modified:
		((_fimsdescription__dateType_modified *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__dateType_created:
		((_fimsdescription__dateType_created *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		((_fimsdescription__coverageType_spatial_coordinates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		((_fimsdescription__coverageType_spatial_locationName *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		((_fimsdescription__coverageType_spatial *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		((_fimsdescription__coverageType_temporal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		((_fimsdescription__typeType_targetAudience *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		((_fimsdescription__typeType_objectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fimsdescription__typeType_genre:
		((_fimsdescription__typeType_genre *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__DataFormatsType_sequence:
		((__fims__DataFormatsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__ContainerFormatsType_sequence:
		((__fims__ContainerFormatsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__AudioFormatsType_sequence:
		((__fims__AudioFormatsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__VideoFormatsType_sequence:
		((__fims__VideoFormatsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__JobsType_sequence:
		((__fims__JobsType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__QueuesType_sequence:
		((__fims__QueuesType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__ServicesType_sequence:
		((__fims__ServicesType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__ProfilesType_sequence:
		((__fims__ProfilesType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___fims__ResourcesType_sequence:
		((__fims__ResourcesType_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TimecodeDuration:
		soap_serialize_fims__TimecodeDuration(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__Timecode:
		soap_serialize_fims__Timecode(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__RevisionIDType:
		soap_serialize_fims__RevisionIDType(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__ResourceIDType:
		soap_serialize_fims__ResourceIDType(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__EmptyID:
		soap_serialize_fims__EmptyID(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__UL:
		soap_serialize_fims__UL(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__UMID:
		soap_serialize_fims__UMID(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__UUID:
		soap_serialize_fims__UUID(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fims__UID:
		soap_serialize_fims__UID(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_fimsdescription__languageType:
		((fimsdescription__languageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__addressType:
		((fimsdescription__addressType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__detailsType:
		((fimsdescription__detailsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		((fimsdescription__organisationDetailsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		((fimsdescription__contactDetailsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__entityType:
		((fimsdescription__entityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__dateType:
		((fimsdescription__dateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__textElementType:
		((fimsdescription__textElementType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__rightsType:
		((fimsdescription__rightsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__coverageType:
		((fimsdescription__coverageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__descriptionType:
		((fimsdescription__descriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__typeType:
		((fimsdescription__typeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__subjectType:
		((fimsdescription__subjectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__identifierType:
		((fimsdescription__identifierType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__titleType:
		((fimsdescription__titleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		((fimsdescription__bmContentDescriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__fims__formatCollection:
		((_fims__formatCollection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DescriptionsType:
		((fims__DescriptionsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		((fims__BMEssenceLocatorsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentFormatsType:
		((fims__BMContentFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentsType:
		((fims__BMContentsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMObjectsType:
		((fims__BMObjectsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DataFormatsType:
		((fims__DataFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContainerFormatsType:
		((fims__ContainerFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AudioFormatsType:
		((fims__AudioFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__VideoFormatsType:
		((fims__VideoFormatsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__JobsType:
		((fims__JobsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueuesType:
		((fims__QueuesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ServicesType:
		((fims__ServicesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProfilesType:
		((fims__ProfilesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourcesType:
		((fims__ResourcesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__InnerFaultType:
		((fims__InnerFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__FaultType:
		((fims__FaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ListFilterType:
		((fims__ListFilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		((fims__QueryServiceDescriptionResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		((fims__QueryServiceDescriptionRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobResponseType:
		((fims__QueryJobResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		((fims__QueryJobRequestByFilterType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		((fims__QueryJobRequestByIDType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueryJobRequestType:
		((fims__QueryJobRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageQueueResponseType:
		((fims__ManageQueueResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageQueueRequestType:
		((fims__ManageQueueRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageJobResponseType:
		((fims__ManageJobResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ManageJobRequestType:
		((fims__ManageJobRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobByLatestType:
		((fims__StartJobByLatestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobByTimeType:
		((fims__StartJobByTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		((fims__StartJobByNoWaitType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartJobType:
		((fims__StartJobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		((fims__StopProcessByOpenEndType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		((fims__StopProcessByServiceDefinedTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		((fims__StopProcessByTimeMarkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByDurationType:
		((fims__StopProcessByDurationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeType:
		((fims__StopProcessByTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StopProcessType:
		((fims__StopProcessType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		((fims__StartProcessByServiceDefinedTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		((fims__StartProcessByTimeMarkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeType:
		((fims__StartProcessByTimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		((fims__StartProcessByNoWaitType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StartProcessType:
		((fims__StartProcessType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__HashFunctionType:
		((fims__HashFunctionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__StorageType:
		((fims__StorageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TimeType:
		((fims__TimeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DurationType:
		((fims__DurationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		((fims__ProcessedInfoByFramesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		((fims__ProcessedInfoByBytesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProcessedInfoType:
		((fims__ProcessedInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__EditUnitNumberType:
		((fims__EditUnitNumberType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__HashType:
		((fims__HashType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__RationalType:
		((fims__RationalType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__LengthType:
		((fims__LengthType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TechnicalAttributeType:
		((fims__TechnicalAttributeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TransformAtomType:
		((fims__TransformAtomType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__TransferAtomType:
		((fims__TransferAtomType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__FolderLocatorType:
		((fims__FolderLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ListFileLocatorType:
		((fims__ListFileLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		((fims__SimpleFileLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		((fims__BMEssenceLocatorType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentFormatType:
		((fims__BMContentFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DescriptionType:
		((fims__DescriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMContentType:
		((fims__BMContentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMObjectType:
		((fims__BMObjectType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CodecType:
		((fims__CodecType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__BMTrackType:
		((fims__BMTrackType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ContainerFormatType:
		((fims__ContainerFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		((fims__AncillaryDataFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__CaptioningFormatType:
		((fims__CaptioningFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__DataFormatType:
		((fims__DataFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AudioFormatType:
		((fims__AudioFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__VideoFormatType:
		((fims__VideoFormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__FormatType:
		((fims__FormatType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__JobType:
		((fims__JobType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__QueueType:
		((fims__QueueType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ProfileType:
		((fims__ProfileType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ServiceType:
		((fims__ServiceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__AsyncEndpointType:
		((fims__AsyncEndpointType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourceType:
		((fims__ResourceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ResourceReferenceType:
		((fims__ResourceReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ExtensionAttributes:
		((fims__ExtensionAttributes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fims__ExtensionGroup:
		((fims__ExtensionGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		((edlprovider__EdlProviderFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		((edlprovider__EdlCreateResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		((edlprovider__EdlCreateRequestDoubleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		((edlprovider__EdlCreateRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		((edlprovider__EdlCreateRequestBaseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__ClipType:
		((edlprovider__ClipType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		((edlprovider__ArrayOfClips *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		((edlprovider__ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__time:
		soap_serialize_xsd__time(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		soap_serialize_xsd__positiveInteger(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__language:
		soap_serialize_xsd__language(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__gYear:
		soap_serialize_xsd__gYear(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_xsd__date(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_xsd__NMTOKEN(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_std__wstring:
		soap_serialize_std__wstring(soap, (const std::wstring *)ptr);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___edlprovider__getEdlDouble:
		soap_serialize___edlprovider__getEdlDouble(soap, (const struct __edlprovider__getEdlDouble *)ptr);
		break;
	case SOAP_TYPE___edlprovider__getEdl:
		soap_serialize___edlprovider__getEdl(soap, (const struct __edlprovider__getEdl *)ptr);
		break;
	case SOAP_TYPE___edlprovider__getInstalledEdls:
		soap_serialize___edlprovider__getInstalledEdls(soap, (const struct __edlprovider__getInstalledEdls *)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType:
		soap_serialize_PointerToedlprovider__EdlCreateRequestDoubleType(soap, (edlprovider__EdlCreateRequestDoubleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlCreateResponseType:
		soap_serialize_PointerToedlprovider__EdlCreateResponseType(soap, (edlprovider__EdlCreateResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType:
		soap_serialize_PointerToedlprovider__EdlCreateRequestType(soap, (edlprovider__EdlCreateRequestType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__ArrayOfstring:
		soap_serialize_PointerToedlprovider__ArrayOfstring(soap, (edlprovider__ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType:
		soap_serialize_PointerToedlprovider__EdlProviderFaultType(soap, (edlprovider__EdlProviderFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat:
		soap_serialize_PointerTo_fims__ContainerFormatType_containerFormat(soap, (_fims__ContainerFormatType_containerFormat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AncillaryDataFormatType:
		soap_serialize_PointerTofims__AncillaryDataFormatType(soap, (fims__AncillaryDataFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CaptioningFormatType:
		soap_serialize_PointerTofims__CaptioningFormatType(soap, (fims__CaptioningFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AudioSampleType:
		soap_serialize_PointerTofims__AudioSampleType(soap, (enum fims__AudioSampleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration:
		soap_serialize_PointerTo_fims__AudioFormatType_trackConfiguration(soap, (_fims__AudioFormatType_trackConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__decimal:
		soap_serialize_PointerToxsd__decimal(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ScanningOrderType:
		soap_serialize_PointerTofims__ScanningOrderType(soap, (enum fims__ScanningOrderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ScanningFormatType:
		soap_serialize_PointerTofims__ScanningFormatType(soap, (enum fims__ScanningFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BitRateModeType:
		soap_serialize_PointerTofims__BitRateModeType(soap, (enum fims__BitRateModeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMTrackType:
		soap_serialize_PointerTofims__BMTrackType(soap, (fims__BMTrackType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__CodecType:
		soap_serialize_PointerTofims__CodecType(soap, (fims__CodecType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__RationalType:
		soap_serialize_PointerTofims__RationalType(soap, (fims__RationalType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__LengthType:
		soap_serialize_PointerTofims__LengthType(soap, (fims__LengthType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType:
		soap_serialize_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, (_fims__BMEssenceLocatorType_containerMimeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__StorageType:
		soap_serialize_PointerTofims__StorageType(soap, (fims__StorageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType:
		soap_serialize_PointerTo_fims__BMContentFormatType_mimeType(soap, (_fims__BMContentFormatType_mimeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLONG64:
		soap_serialize_PointerTounsignedLONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__HashType:
		soap_serialize_PointerTofims__HashType(soap, (fims__HashType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__formatCollection:
		soap_serialize_PointerTo_fims__formatCollection(soap, (_fims__formatCollection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorsType:
		soap_serialize_PointerTofims__BMEssenceLocatorsType(soap, (fims__BMEssenceLocatorsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType:
		soap_serialize_PointerTofimsdescription__bmContentDescriptionType(soap, (fimsdescription__bmContentDescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__DescriptionsType:
		soap_serialize_PointerTofims__DescriptionsType(soap, (fims__DescriptionsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentFormatsType:
		soap_serialize_PointerTofims__BMContentFormatsType(soap, (fims__BMContentFormatsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentsType:
		soap_serialize_PointerTofims__BMContentsType(soap, (fims__BMContentsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__TechnicalAttributeType:
		soap_serialize_PointerTofims__TechnicalAttributeType(soap, (fims__TechnicalAttributeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ProcessedInfoType:
		soap_serialize_PointerTofims__ProcessedInfoType(soap, (fims__ProcessedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__StartJobType:
		soap_serialize_PointerTofims__StartJobType(soap, (fims__StartJobType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMObjectsType:
		soap_serialize_PointerTofims__BMObjectsType(soap, (fims__BMObjectsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__JobStatusType:
		soap_serialize_PointerTofims__JobStatusType(soap, (enum fims__JobStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueueStatusType:
		soap_serialize_PointerTofims__QueueStatusType(soap, (enum fims__QueueStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription:
		soap_serialize_PointerTo_fims__ServiceType_serviceDescription(soap, (_fims__ServiceType_serviceDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ListFilterType:
		soap_serialize_PointerTofims__ListFilterType(soap, (fims__ListFilterType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__DurationType:
		soap_serialize_PointerTofims__DurationType(soap, (fims__DurationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__TimeType:
		soap_serialize_PointerTofims__TimeType(soap, (fims__TimeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AsyncEndpointType:
		soap_serialize_PointerTofims__AsyncEndpointType(soap, (fims__AsyncEndpointType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__EDLProviderErrorCodeType:
		soap_serialize_PointerToedlprovider__EDLProviderErrorCodeType(soap, (enum edlprovider__EDLProviderErrorCodeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__addressType_country:
		soap_serialize_PointerTo_fimsdescription__addressType_country(soap, (_fimsdescription__addressType_country *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__addressType:
		soap_serialize_PointerTofimsdescription__addressType(soap, (fimsdescription__addressType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment:
		soap_serialize_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, (_fimsdescription__organisationDetailsType_organisationDepartment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__detailsType:
		soap_serialize_PointerTofimsdescription__detailsType(soap, (fimsdescription__detailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__organisationDetailsType:
		soap_serialize_PointerTofimsdescription__organisationDetailsType(soap, (fimsdescription__organisationDetailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative:
		soap_serialize_PointerTo_fimsdescription__dateType_alternative(soap, (_fimsdescription__dateType_alternative *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_issued:
		soap_serialize_PointerTo_fimsdescription__dateType_issued(soap, (_fimsdescription__dateType_issued *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_modified:
		soap_serialize_PointerTo_fimsdescription__dateType_modified(soap, (_fimsdescription__dateType_modified *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__dateType_created:
		soap_serialize_PointerTo_fimsdescription__dateType_created(soap, (_fimsdescription__dateType_created *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__date:
		soap_serialize_PointerToxsd__date(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__gYear:
		soap_serialize_PointerToxsd__gYear(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__contactDetailsType:
		soap_serialize_PointerTofimsdescription__contactDetailsType(soap, (fimsdescription__contactDetailsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial:
		soap_serialize_PointerTo_fimsdescription__coverageType_spatial(soap, (_fimsdescription__coverageType_spatial *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates:
		soap_serialize_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, (_fimsdescription__coverageType_spatial_coordinates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal:
		soap_serialize_PointerTo_fimsdescription__coverageType_temporal(soap, (_fimsdescription__coverageType_temporal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xml__lang:
		soap_serialize_PointerTo_xml__lang(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__rightsType:
		soap_serialize_PointerTofimsdescription__rightsType(soap, (fimsdescription__rightsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__coverageType:
		soap_serialize_PointerTofimsdescription__coverageType(soap, (fimsdescription__coverageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__languageType:
		soap_serialize_PointerTofimsdescription__languageType(soap, (fimsdescription__languageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__identifierType:
		soap_serialize_PointerTofimsdescription__identifierType(soap, (fimsdescription__identifierType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__typeType:
		soap_serialize_PointerTofimsdescription__typeType(soap, (fimsdescription__typeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__dateType:
		soap_serialize_PointerTofimsdescription__dateType(soap, (fimsdescription__dateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__descriptionType:
		soap_serialize_PointerTofimsdescription__descriptionType(soap, (fimsdescription__descriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__subjectType:
		soap_serialize_PointerTofimsdescription__subjectType(soap, (fimsdescription__subjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__entityType:
		soap_serialize_PointerTofimsdescription__entityType(soap, (fimsdescription__entityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__titleType:
		soap_serialize_PointerTofimsdescription__titleType(soap, (fimsdescription__titleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofimsdescription__textElementType:
		soap_serialize_PointerTofimsdescription__textElementType(soap, (fimsdescription__textElementType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__DescriptionType:
		soap_serialize_PointerTofims__DescriptionType(soap, (fims__DescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMEssenceLocatorType:
		soap_serialize_PointerTofims__BMEssenceLocatorType(soap, (fims__BMEssenceLocatorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentFormatType:
		soap_serialize_PointerTofims__BMContentFormatType(soap, (fims__BMContentFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMContentType:
		soap_serialize_PointerTofims__BMContentType(soap, (fims__BMContentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__BMObjectType:
		soap_serialize_PointerTofims__BMObjectType(soap, (fims__BMObjectType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__DataFormatType:
		soap_serialize_PointerTofims__DataFormatType(soap, (fims__DataFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ProfileType:
		soap_serialize_PointerTofims__ProfileType(soap, (fims__ProfileType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ResourceType:
		soap_serialize_PointerTofims__ResourceType(soap, (fims__ResourceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__InnerFaultType:
		soap_serialize_PointerTofims__InnerFaultType(soap, (fims__InnerFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ServiceType:
		soap_serialize_PointerTofims__ServiceType(soap, (fims__ServiceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__JobsType:
		soap_serialize_PointerTofims__JobsType(soap, (fims__JobsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__QueueType:
		soap_serialize_PointerTofims__QueueType(soap, (fims__QueueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__JobType:
		soap_serialize_PointerTofims__JobType(soap, (fims__JobType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__PriorityType:
		soap_serialize_PointerTofims__PriorityType(soap, (enum fims__PriorityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__time:
		soap_serialize_PointerToxsd__time(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__Timecode:
		soap_serialize_PointerTofims__Timecode(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__EditUnitNumberType:
		soap_serialize_PointerTofims__EditUnitNumberType(soap, (fims__EditUnitNumberType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__TimecodeDuration:
		soap_serialize_PointerTofims__TimecodeDuration(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__HashFunctionType:
		soap_serialize_PointerTofims__HashFunctionType(soap, (fims__HashFunctionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ContainerFormatType:
		soap_serialize_PointerTofims__ContainerFormatType(soap, (fims__ContainerFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__AudioFormatType:
		soap_serialize_PointerTofims__AudioFormatType(soap, (fims__AudioFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__VideoFormatType:
		soap_serialize_PointerTofims__VideoFormatType(soap, (fims__VideoFormatType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__language:
		soap_serialize_PointerToxsd__language(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__UID:
		soap_serialize_PointerTofims__UID(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ExtensionAttributes:
		soap_serialize_PointerTofims__ExtensionAttributes(soap, (fims__ExtensionAttributes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__ExtensionGroup:
		soap_serialize_PointerTofims__ExtensionGroup(soap, (fims__ExtensionGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofims__RevisionIDType:
		soap_serialize_PointerTofims__RevisionIDType(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__wstring:
		soap_serialize_PointerTostd__wstring(soap, (std::wstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__ArrayOfClips:
		soap_serialize_PointerToedlprovider__ArrayOfClips(soap, (edlprovider__ArrayOfClips *const*)ptr);
		break;
	case SOAP_TYPE_PointerToedlprovider__ClipType:
		soap_serialize_PointerToedlprovider__ClipType(soap, (edlprovider__ClipType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 EDLProvider_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__wstring:
		return (void*)soap_instantiate_std__wstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		return (void*)soap_instantiate_edlprovider__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		return (void*)soap_instantiate_edlprovider__ArrayOfClips(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__ClipType:
		return (void*)soap_instantiate_edlprovider__ClipType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		return (void*)soap_instantiate_edlprovider__EdlCreateRequestBaseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		return (void*)soap_instantiate_edlprovider__EdlCreateResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ExtensionGroup:
		return (void*)soap_instantiate_fims__ExtensionGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ExtensionAttributes:
		return (void*)soap_instantiate_fims__ExtensionAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourceReferenceType:
		return (void*)soap_instantiate_fims__ResourceReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AsyncEndpointType:
		return (void*)soap_instantiate_fims__AsyncEndpointType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		return (void*)soap_instantiate_fims__AncillaryDataFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMTrackType:
		return (void*)soap_instantiate_fims__BMTrackType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CodecType:
		return (void*)soap_instantiate_fims__CodecType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TransferAtomType:
		return (void*)soap_instantiate_fims__TransferAtomType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TransformAtomType:
		return (void*)soap_instantiate_fims__TransformAtomType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__HashType:
		return (void*)soap_instantiate_fims__HashType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProcessedInfoType:
		return (void*)soap_instantiate_fims__ProcessedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DurationType:
		return (void*)soap_instantiate_fims__DurationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TimeType:
		return (void*)soap_instantiate_fims__TimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessType:
		return (void*)soap_instantiate_fims__StartProcessType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessType:
		return (void*)soap_instantiate_fims__StopProcessType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobType:
		return (void*)soap_instantiate_fims__StartJobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageJobRequestType:
		return (void*)soap_instantiate_fims__ManageJobRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageJobResponseType:
		return (void*)soap_instantiate_fims__ManageJobResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageQueueRequestType:
		return (void*)soap_instantiate_fims__ManageQueueRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ManageQueueResponseType:
		return (void*)soap_instantiate_fims__ManageQueueResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobRequestType:
		return (void*)soap_instantiate_fims__QueryJobRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobResponseType:
		return (void*)soap_instantiate_fims__QueryJobResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		return (void*)soap_instantiate_fims__QueryServiceDescriptionRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		return (void*)soap_instantiate_fims__QueryServiceDescriptionResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ListFilterType:
		return (void*)soap_instantiate_fims__ListFilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__FaultType:
		return (void*)soap_instantiate_fims__FaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__InnerFaultType:
		return (void*)soap_instantiate_fims__InnerFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__ResourcesType_sequence:
		return (void*)soap_instantiate___fims__ResourcesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourcesType:
		return (void*)soap_instantiate_fims__ResourcesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__ProfilesType_sequence:
		return (void*)soap_instantiate___fims__ProfilesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProfilesType:
		return (void*)soap_instantiate_fims__ProfilesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__ServicesType_sequence:
		return (void*)soap_instantiate___fims__ServicesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ServicesType:
		return (void*)soap_instantiate_fims__ServicesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__QueuesType_sequence:
		return (void*)soap_instantiate___fims__QueuesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueuesType:
		return (void*)soap_instantiate_fims__QueuesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__JobsType_sequence:
		return (void*)soap_instantiate___fims__JobsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__JobsType:
		return (void*)soap_instantiate_fims__JobsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__VideoFormatsType_sequence:
		return (void*)soap_instantiate___fims__VideoFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__VideoFormatsType:
		return (void*)soap_instantiate_fims__VideoFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__AudioFormatsType_sequence:
		return (void*)soap_instantiate___fims__AudioFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AudioFormatsType:
		return (void*)soap_instantiate_fims__AudioFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__ContainerFormatsType_sequence:
		return (void*)soap_instantiate___fims__ContainerFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContainerFormatsType:
		return (void*)soap_instantiate_fims__ContainerFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___fims__DataFormatsType_sequence:
		return (void*)soap_instantiate___fims__DataFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DataFormatsType:
		return (void*)soap_instantiate_fims__DataFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMObjectsType:
		return (void*)soap_instantiate_fims__BMObjectsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentsType:
		return (void*)soap_instantiate_fims__BMContentsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentFormatsType:
		return (void*)soap_instantiate_fims__BMContentFormatsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		return (void*)soap_instantiate_fims__BMEssenceLocatorsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DescriptionsType:
		return (void*)soap_instantiate_fims__DescriptionsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__formatCollection:
		return (void*)soap_instantiate__fims__formatCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		return (void*)soap_instantiate_fimsdescription__bmContentDescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__typeType_genre:
		return (void*)soap_instantiate__fimsdescription__typeType_genre(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		return (void*)soap_instantiate__fimsdescription__typeType_objectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		return (void*)soap_instantiate__fimsdescription__typeType_targetAudience(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__typeType:
		return (void*)soap_instantiate_fimsdescription__typeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		return (void*)soap_instantiate__fimsdescription__coverageType_temporal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		return (void*)soap_instantiate__fimsdescription__coverageType_spatial_locationName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		return (void*)soap_instantiate__fimsdescription__coverageType_spatial_coordinates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		return (void*)soap_instantiate__fimsdescription__coverageType_spatial(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__coverageType:
		return (void*)soap_instantiate_fimsdescription__coverageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__rightsType:
		return (void*)soap_instantiate_fimsdescription__rightsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_created:
		return (void*)soap_instantiate__fimsdescription__dateType_created(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_modified:
		return (void*)soap_instantiate__fimsdescription__dateType_modified(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_issued:
		return (void*)soap_instantiate__fimsdescription__dateType_issued(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		return (void*)soap_instantiate__fimsdescription__dateType_alternative(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__dateType:
		return (void*)soap_instantiate_fimsdescription__dateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__entityType_role:
		return (void*)soap_instantiate__fimsdescription__entityType_role(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__entityType:
		return (void*)soap_instantiate_fimsdescription__entityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		return (void*)soap_instantiate_fimsdescription__contactDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		return (void*)soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		return (void*)soap_instantiate_fimsdescription__organisationDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__detailsType:
		return (void*)soap_instantiate_fimsdescription__detailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fimsdescription__addressType_country:
		return (void*)soap_instantiate__fimsdescription__addressType_country(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__addressType:
		return (void*)soap_instantiate_fimsdescription__addressType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__languageType:
		return (void*)soap_instantiate_fimsdescription__languageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		return (void*)soap_instantiate_edlprovider__EdlCreateRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		return (void*)soap_instantiate_edlprovider__EdlCreateRequestDoubleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		return (void*)soap_instantiate_edlprovider__EdlProviderFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourceType:
		return (void*)soap_instantiate_fims__ResourceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__CaptioningFormatType:
		return (void*)soap_instantiate_fims__CaptioningFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TechnicalAttributeType:
		return (void*)soap_instantiate_fims__TechnicalAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__LengthType:
		return (void*)soap_instantiate_fims__LengthType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__RationalType:
		return (void*)soap_instantiate_fims__RationalType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__EditUnitNumberType:
		return (void*)soap_instantiate_fims__EditUnitNumberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		return (void*)soap_instantiate_fims__ProcessedInfoByBytesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		return (void*)soap_instantiate_fims__ProcessedInfoByFramesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		return (void*)soap_instantiate_fims__StartProcessByNoWaitType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByTimeType:
		return (void*)soap_instantiate_fims__StartProcessByTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		return (void*)soap_instantiate_fims__StartProcessByTimeMarkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		return (void*)soap_instantiate_fims__StartProcessByServiceDefinedTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByTimeType:
		return (void*)soap_instantiate_fims__StopProcessByTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByDurationType:
		return (void*)soap_instantiate_fims__StopProcessByDurationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		return (void*)soap_instantiate_fims__StopProcessByTimeMarkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		return (void*)soap_instantiate_fims__StopProcessByServiceDefinedTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		return (void*)soap_instantiate_fims__StopProcessByOpenEndType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		return (void*)soap_instantiate_fims__StartJobByNoWaitType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobByTimeType:
		return (void*)soap_instantiate_fims__StartJobByTimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StartJobByLatestType:
		return (void*)soap_instantiate_fims__StartJobByLatestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		return (void*)soap_instantiate_fims__QueryJobRequestByIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		return (void*)soap_instantiate_fims__QueryJobRequestByFilterType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__identifierType:
		return (void*)soap_instantiate_fimsdescription__identifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__textElementType:
		return (void*)soap_instantiate_fimsdescription__textElementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		return (void*)soap_instantiate__fims__ServiceType_serviceDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ServiceType:
		return (void*)soap_instantiate_fims__ServiceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ProfileType:
		return (void*)soap_instantiate_fims__ProfileType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__QueueType:
		return (void*)soap_instantiate_fims__QueueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__JobType:
		return (void*)soap_instantiate_fims__JobType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__FormatType:
		return (void*)soap_instantiate_fims__FormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMObjectType:
		return (void*)soap_instantiate_fims__BMObjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentType:
		return (void*)soap_instantiate_fims__BMContentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DescriptionType:
		return (void*)soap_instantiate_fims__DescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		return (void*)soap_instantiate__fims__BMContentFormatType_mimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMContentFormatType:
		return (void*)soap_instantiate_fims__BMContentFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		return (void*)soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		return (void*)soap_instantiate_fims__BMEssenceLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__StorageType:
		return (void*)soap_instantiate_fims__StorageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__HashFunctionType:
		return (void*)soap_instantiate_fims__HashFunctionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__titleType:
		return (void*)soap_instantiate_fimsdescription__titleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__subjectType:
		return (void*)soap_instantiate_fimsdescription__subjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fimsdescription__descriptionType:
		return (void*)soap_instantiate_fimsdescription__descriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__VideoFormatType:
		return (void*)soap_instantiate_fims__VideoFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		return (void*)soap_instantiate__fims__AudioFormatType_trackConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__AudioFormatType:
		return (void*)soap_instantiate_fims__AudioFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__DataFormatType:
		return (void*)soap_instantiate_fims__DataFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		return (void*)soap_instantiate__fims__ContainerFormatType_containerFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ContainerFormatType:
		return (void*)soap_instantiate_fims__ContainerFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		return (void*)soap_instantiate_fims__SimpleFileLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ListFileLocatorType:
		return (void*)soap_instantiate_fims__ListFileLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__FolderLocatorType:
		return (void*)soap_instantiate_fims__FolderLocatorType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___edlprovider__getInstalledEdls:
		return (void*)soap_instantiate___edlprovider__getInstalledEdls(soap, -1, type, arrayType, n);
	case SOAP_TYPE___edlprovider__getEdl:
		return (void*)soap_instantiate___edlprovider__getEdl(soap, -1, type, arrayType, n);
	case SOAP_TYPE___edlprovider__getEdlDouble:
		return (void*)soap_instantiate___edlprovider__getEdlDouble(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__NMTOKEN:
		return (void*)soap_instantiate_xsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__date:
		return (void*)soap_instantiate_xsd__date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__gYear:
		return (void*)soap_instantiate_xsd__gYear(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__language:
		return (void*)soap_instantiate_xsd__language(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__positiveInteger:
		return (void*)soap_instantiate_xsd__positiveInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__time:
		return (void*)soap_instantiate_xsd__time(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__UID:
		return (void*)soap_instantiate_fims__UID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__UUID:
		return (void*)soap_instantiate_fims__UUID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__UMID:
		return (void*)soap_instantiate_fims__UMID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__UL:
		return (void*)soap_instantiate_fims__UL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__EmptyID:
		return (void*)soap_instantiate_fims__EmptyID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__ResourceIDType:
		return (void*)soap_instantiate_fims__ResourceIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__RevisionIDType:
		return (void*)soap_instantiate_fims__RevisionIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__Timecode:
		return (void*)soap_instantiate_fims__Timecode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fims__TimecodeDuration:
		return (void*)soap_instantiate_fims__TimecodeDuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMTrackType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOffims__UID:
		return (void*)soap_instantiate_std__vectorTemplateOffims__UID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__entityType_role(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre:
		return (void*)soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__DescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__BMObjectType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__DataFormatsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__DataFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__ContainerFormatsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__AudioFormatsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__AudioFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__VideoFormatsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__VideoFormatsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__JobsType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__JobsType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__QueuesType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__QueuesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__ServicesType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__ServicesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__ProfilesType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__ProfilesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf__fims__ResourcesType_sequence:
		return (void*)soap_instantiate_std__vectorTemplateOf__fims__ResourcesType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__wstring(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 EDLProvider_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			SOAP_DELETE((xsd__hexBinary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__hexBinary*)p->ptr);
		break;
	case SOAP_TYPE_std__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfstring:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__ArrayOfstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__ArrayOfstring*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__ArrayOfClips:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__ArrayOfClips*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__ArrayOfClips*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__ClipType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__ClipType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__ClipType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestBaseType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateRequestBaseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateRequestBaseType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateResponseType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ExtensionGroup:
		if (p->size < 0)
			SOAP_DELETE((fims__ExtensionGroup*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ExtensionGroup*)p->ptr);
		break;
	case SOAP_TYPE_fims__ExtensionAttributes:
		if (p->size < 0)
			SOAP_DELETE((fims__ExtensionAttributes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ExtensionAttributes*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourceReferenceType:
		if (p->size < 0)
			SOAP_DELETE((fims__ResourceReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ResourceReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_fims__AsyncEndpointType:
		if (p->size < 0)
			SOAP_DELETE((fims__AsyncEndpointType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AsyncEndpointType*)p->ptr);
		break;
	case SOAP_TYPE_fims__AncillaryDataFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__AncillaryDataFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AncillaryDataFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMTrackType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMTrackType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMTrackType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CodecType:
		if (p->size < 0)
			SOAP_DELETE((fims__CodecType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CodecType*)p->ptr);
		break;
	case SOAP_TYPE_fims__TransferAtomType:
		if (p->size < 0)
			SOAP_DELETE((fims__TransferAtomType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__TransferAtomType*)p->ptr);
		break;
	case SOAP_TYPE_fims__TransformAtomType:
		if (p->size < 0)
			SOAP_DELETE((fims__TransformAtomType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__TransformAtomType*)p->ptr);
		break;
	case SOAP_TYPE_fims__HashType:
		if (p->size < 0)
			SOAP_DELETE((fims__HashType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__HashType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProcessedInfoType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProcessedInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProcessedInfoType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DurationType:
		if (p->size < 0)
			SOAP_DELETE((fims__DurationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DurationType*)p->ptr);
		break;
	case SOAP_TYPE_fims__TimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__TimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__TimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageJobRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageJobRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageJobRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageJobResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageJobResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageJobResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageQueueRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageQueueRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageQueueRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ManageQueueResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__ManageQueueResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ManageQueueResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionRequestType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryServiceDescriptionRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryServiceDescriptionRequestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryServiceDescriptionResponseType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryServiceDescriptionResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryServiceDescriptionResponseType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ListFilterType:
		if (p->size < 0)
			SOAP_DELETE((fims__ListFilterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ListFilterType*)p->ptr);
		break;
	case SOAP_TYPE_fims__FaultType:
		if (p->size < 0)
			SOAP_DELETE((fims__FaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__FaultType*)p->ptr);
		break;
	case SOAP_TYPE_fims__InnerFaultType:
		if (p->size < 0)
			SOAP_DELETE((fims__InnerFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__InnerFaultType*)p->ptr);
		break;
	case SOAP_TYPE___fims__ResourcesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__ResourcesType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__ResourcesType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourcesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ResourcesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ResourcesType*)p->ptr);
		break;
	case SOAP_TYPE___fims__ProfilesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__ProfilesType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__ProfilesType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProfilesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProfilesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProfilesType*)p->ptr);
		break;
	case SOAP_TYPE___fims__ServicesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__ServicesType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__ServicesType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__ServicesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ServicesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ServicesType*)p->ptr);
		break;
	case SOAP_TYPE___fims__QueuesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__QueuesType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__QueuesType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueuesType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueuesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueuesType*)p->ptr);
		break;
	case SOAP_TYPE___fims__JobsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__JobsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__JobsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__JobsType:
		if (p->size < 0)
			SOAP_DELETE((fims__JobsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__JobsType*)p->ptr);
		break;
	case SOAP_TYPE___fims__VideoFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__VideoFormatsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__VideoFormatsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__VideoFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__VideoFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__VideoFormatsType*)p->ptr);
		break;
	case SOAP_TYPE___fims__AudioFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__AudioFormatsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__AudioFormatsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__AudioFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__AudioFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AudioFormatsType*)p->ptr);
		break;
	case SOAP_TYPE___fims__ContainerFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__ContainerFormatsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__ContainerFormatsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContainerFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContainerFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContainerFormatsType*)p->ptr);
		break;
	case SOAP_TYPE___fims__DataFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((__fims__DataFormatsType_sequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__fims__DataFormatsType_sequence*)p->ptr);
		break;
	case SOAP_TYPE_fims__DataFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__DataFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DataFormatsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMObjectsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMObjectsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMObjectsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentFormatsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentFormatsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentFormatsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorsType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMEssenceLocatorsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMEssenceLocatorsType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DescriptionsType:
		if (p->size < 0)
			SOAP_DELETE((fims__DescriptionsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DescriptionsType*)p->ptr);
		break;
	case SOAP_TYPE__fims__formatCollection:
		if (p->size < 0)
			SOAP_DELETE((_fims__formatCollection*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__formatCollection*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__bmContentDescriptionType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__bmContentDescriptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__bmContentDescriptionType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__typeType_genre:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__typeType_genre*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__typeType_genre*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__typeType_objectType:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__typeType_objectType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__typeType_objectType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__typeType_targetAudience:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__typeType_targetAudience*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__typeType_targetAudience*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__typeType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__typeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__typeType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_temporal:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_temporal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_temporal*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_locationName:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_spatial_locationName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_spatial_locationName*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_spatial_coordinates*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_spatial_coordinates*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__coverageType_spatial:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__coverageType_spatial*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__coverageType_spatial*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__coverageType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__coverageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__coverageType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__rightsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__rightsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__rightsType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_created:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_created*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_created*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_modified:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_modified*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_modified*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_issued:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_issued*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_issued*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__dateType_alternative:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__dateType_alternative*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__dateType_alternative*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__dateType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__dateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__dateType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__entityType_role:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__entityType_role*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__entityType_role*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__entityType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__entityType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__entityType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__contactDetailsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__contactDetailsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__contactDetailsType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__organisationDetailsType_organisationDepartment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__organisationDetailsType_organisationDepartment*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__organisationDetailsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__organisationDetailsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__organisationDetailsType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__detailsType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__detailsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__detailsType*)p->ptr);
		break;
	case SOAP_TYPE__fimsdescription__addressType_country:
		if (p->size < 0)
			SOAP_DELETE((_fimsdescription__addressType_country*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fimsdescription__addressType_country*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__addressType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__addressType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__addressType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__languageType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__languageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__languageType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateRequestType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlCreateRequestDoubleType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlCreateRequestDoubleType*)p->ptr);
		break;
	case SOAP_TYPE_edlprovider__EdlProviderFaultType:
		if (p->size < 0)
			SOAP_DELETE((edlprovider__EdlProviderFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((edlprovider__EdlProviderFaultType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourceType:
		if (p->size < 0)
			SOAP_DELETE((fims__ResourceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ResourceType*)p->ptr);
		break;
	case SOAP_TYPE_fims__CaptioningFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__CaptioningFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__CaptioningFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__TechnicalAttributeType:
		if (p->size < 0)
			SOAP_DELETE((fims__TechnicalAttributeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__TechnicalAttributeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__LengthType:
		if (p->size < 0)
			SOAP_DELETE((fims__LengthType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__LengthType*)p->ptr);
		break;
	case SOAP_TYPE_fims__RationalType:
		if (p->size < 0)
			SOAP_DELETE((fims__RationalType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__RationalType*)p->ptr);
		break;
	case SOAP_TYPE_fims__EditUnitNumberType:
		if (p->size < 0)
			SOAP_DELETE((fims__EditUnitNumberType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__EditUnitNumberType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByBytesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProcessedInfoByBytesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProcessedInfoByBytesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProcessedInfoByFramesType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProcessedInfoByFramesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProcessedInfoByFramesType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByNoWaitType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByNoWaitType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByNoWaitType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByTimeMarkType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByTimeMarkType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByTimeMarkType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartProcessByServiceDefinedTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartProcessByServiceDefinedTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByDurationType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByDurationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByDurationType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByTimeMarkType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByTimeMarkType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByTimeMarkType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByServiceDefinedTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByServiceDefinedTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StopProcessByOpenEndType:
		if (p->size < 0)
			SOAP_DELETE((fims__StopProcessByOpenEndType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StopProcessByOpenEndType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobByNoWaitType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobByNoWaitType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobByNoWaitType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobByTimeType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobByTimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobByTimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StartJobByLatestType:
		if (p->size < 0)
			SOAP_DELETE((fims__StartJobByLatestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StartJobByLatestType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByIDType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobRequestByIDType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobRequestByIDType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueryJobRequestByFilterType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueryJobRequestByFilterType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueryJobRequestByFilterType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__identifierType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__identifierType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__identifierType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__textElementType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__textElementType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__textElementType*)p->ptr);
		break;
	case SOAP_TYPE__fims__ServiceType_serviceDescription:
		if (p->size < 0)
			SOAP_DELETE((_fims__ServiceType_serviceDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__ServiceType_serviceDescription*)p->ptr);
		break;
	case SOAP_TYPE_fims__ServiceType:
		if (p->size < 0)
			SOAP_DELETE((fims__ServiceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ServiceType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ProfileType:
		if (p->size < 0)
			SOAP_DELETE((fims__ProfileType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ProfileType*)p->ptr);
		break;
	case SOAP_TYPE_fims__QueueType:
		if (p->size < 0)
			SOAP_DELETE((fims__QueueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__QueueType*)p->ptr);
		break;
	case SOAP_TYPE_fims__JobType:
		if (p->size < 0)
			SOAP_DELETE((fims__JobType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__JobType*)p->ptr);
		break;
	case SOAP_TYPE_fims__FormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__FormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__FormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMObjectType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMObjectType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMObjectType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DescriptionType:
		if (p->size < 0)
			SOAP_DELETE((fims__DescriptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DescriptionType*)p->ptr);
		break;
	case SOAP_TYPE__fims__BMContentFormatType_mimeType:
		if (p->size < 0)
			SOAP_DELETE((_fims__BMContentFormatType_mimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__BMContentFormatType_mimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMContentFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMContentFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMContentFormatType*)p->ptr);
		break;
	case SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType:
		if (p->size < 0)
			SOAP_DELETE((_fims__BMEssenceLocatorType_containerMimeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__BMEssenceLocatorType_containerMimeType*)p->ptr);
		break;
	case SOAP_TYPE_fims__BMEssenceLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__BMEssenceLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__BMEssenceLocatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__StorageType:
		if (p->size < 0)
			SOAP_DELETE((fims__StorageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__StorageType*)p->ptr);
		break;
	case SOAP_TYPE_fims__HashFunctionType:
		if (p->size < 0)
			SOAP_DELETE((fims__HashFunctionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__HashFunctionType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__titleType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__titleType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__titleType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__subjectType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__subjectType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__subjectType*)p->ptr);
		break;
	case SOAP_TYPE_fimsdescription__descriptionType:
		if (p->size < 0)
			SOAP_DELETE((fimsdescription__descriptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fimsdescription__descriptionType*)p->ptr);
		break;
	case SOAP_TYPE_fims__VideoFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__VideoFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__VideoFormatType*)p->ptr);
		break;
	case SOAP_TYPE__fims__AudioFormatType_trackConfiguration:
		if (p->size < 0)
			SOAP_DELETE((_fims__AudioFormatType_trackConfiguration*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__AudioFormatType_trackConfiguration*)p->ptr);
		break;
	case SOAP_TYPE_fims__AudioFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__AudioFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__AudioFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__DataFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__DataFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__DataFormatType*)p->ptr);
		break;
	case SOAP_TYPE__fims__ContainerFormatType_containerFormat:
		if (p->size < 0)
			SOAP_DELETE((_fims__ContainerFormatType_containerFormat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_fims__ContainerFormatType_containerFormat*)p->ptr);
		break;
	case SOAP_TYPE_fims__ContainerFormatType:
		if (p->size < 0)
			SOAP_DELETE((fims__ContainerFormatType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ContainerFormatType*)p->ptr);
		break;
	case SOAP_TYPE_fims__SimpleFileLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__SimpleFileLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__SimpleFileLocatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__ListFileLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__ListFileLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__ListFileLocatorType*)p->ptr);
		break;
	case SOAP_TYPE_fims__FolderLocatorType:
		if (p->size < 0)
			SOAP_DELETE((fims__FolderLocatorType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((fims__FolderLocatorType*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___edlprovider__getInstalledEdls:
		if (p->size < 0)
			SOAP_DELETE((struct __edlprovider__getInstalledEdls*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __edlprovider__getInstalledEdls*)p->ptr);
		break;
	case SOAP_TYPE___edlprovider__getEdl:
		if (p->size < 0)
			SOAP_DELETE((struct __edlprovider__getEdl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __edlprovider__getEdl*)p->ptr);
		break;
	case SOAP_TYPE___edlprovider__getEdlDouble:
		if (p->size < 0)
			SOAP_DELETE((struct __edlprovider__getEdlDouble*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __edlprovider__getEdlDouble*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__NMTOKEN:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__date:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__gYear:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__language:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_xsd__time:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__UID:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__UUID:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__UMID:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__UL:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__EmptyID:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__ResourceIDType:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__RevisionIDType:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__Timecode:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_fims__TimecodeDuration:
		if (p->size < 0)
			SOAP_DELETE((std::wstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::wstring*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__AncillaryDataFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__AncillaryDataFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__CaptioningFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__CaptioningFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMTrackType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMTrackType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__TechnicalAttributeType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__TechnicalAttributeType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOffims__UID:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::wstring >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::wstring >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__detailsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__detailsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__entityType_role >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__entityType_role >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__organisationDetailsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__organisationDetailsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__contactDetailsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__contactDetailsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__typeType_targetAudience >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__typeType_targetAudience >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__typeType_objectType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__typeType_objectType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_fimsdescription__typeType_genre >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_fimsdescription__typeType_genre >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__rightsType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__rightsType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__coverageType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__coverageType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__languageType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__languageType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__identifierType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__identifierType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__typeType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__typeType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__dateType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__dateType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__descriptionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__descriptionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__subjectType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__subjectType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__entityType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__entityType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__titleType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__titleType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fimsdescription__textElementType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fimsdescription__textElementType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__DescriptionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__DescriptionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMEssenceLocatorType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMEssenceLocatorType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMContentFormatType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMContentFormatType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMContentType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMContentType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__BMObjectType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__BMObjectType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__DataFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__DataFormatsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__DataFormatsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ContainerFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__ContainerFormatsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__ContainerFormatsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__AudioFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__AudioFormatsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__AudioFormatsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__VideoFormatsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__VideoFormatsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__VideoFormatsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__JobsType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__JobsType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__JobsType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__QueuesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__QueuesType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__QueuesType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ServicesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__ServicesType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__ServicesType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ProfilesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__ProfilesType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__ProfilesType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ResourcesType_sequence:
		if (p->size < 0)
			SOAP_DELETE((std::vector<__fims__ResourcesType_sequence >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<__fims__ResourcesType_sequence >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<fims__InnerFaultType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<fims__InnerFaultType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE((std::vector<char * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<char * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<edlprovider__ClipType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<edlprovider__ClipType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::wstring >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::wstring >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, EDLProvider_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, EDLProvider_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 EDLProvider_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__AncillaryDataFormatType * >*)p)[len] = *(fims__AncillaryDataFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__CaptioningFormatType * >*)p)[len] = *(fims__CaptioningFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMTrackType * >*)p)[len] = *(fims__BMTrackType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__TechnicalAttributeType * >*)p)[len] = *(fims__TechnicalAttributeType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOffims__UID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::wstring >*)p)[len] = *(std::wstring *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::wstring >*)p)[len] = *(std::wstring *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__detailsType * >*)p)[len] = *(fimsdescription__detailsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__entityType_role >*)p)[len] = *(_fimsdescription__entityType_role *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__organisationDetailsType * >*)p)[len] = *(fimsdescription__organisationDetailsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__contactDetailsType * >*)p)[len] = *(fimsdescription__contactDetailsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__typeType_targetAudience >*)p)[len] = *(_fimsdescription__typeType_targetAudience *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__typeType_objectType >*)p)[len] = *(_fimsdescription__typeType_objectType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_fimsdescription__typeType_genre >*)p)[len] = *(_fimsdescription__typeType_genre *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__rightsType * >*)p)[len] = *(fimsdescription__rightsType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__coverageType * >*)p)[len] = *(fimsdescription__coverageType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__languageType * >*)p)[len] = *(fimsdescription__languageType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__identifierType * >*)p)[len] = *(fimsdescription__identifierType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__typeType * >*)p)[len] = *(fimsdescription__typeType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__dateType * >*)p)[len] = *(fimsdescription__dateType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__descriptionType * >*)p)[len] = *(fimsdescription__descriptionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__subjectType * >*)p)[len] = *(fimsdescription__subjectType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__entityType * >*)p)[len] = *(fimsdescription__entityType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__titleType * >*)p)[len] = *(fimsdescription__titleType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fimsdescription__textElementType * >*)p)[len] = *(fimsdescription__textElementType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__DescriptionType * >*)p)[len] = *(fims__DescriptionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMEssenceLocatorType * >*)p)[len] = *(fims__BMEssenceLocatorType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMContentFormatType * >*)p)[len] = *(fims__BMContentFormatType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMContentType * >*)p)[len] = *(fims__BMContentType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__BMObjectType * >*)p)[len] = *(fims__BMObjectType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__DataFormatsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__DataFormatsType_sequence >*)p)[len] = *(__fims__DataFormatsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ContainerFormatsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__ContainerFormatsType_sequence >*)p)[len] = *(__fims__ContainerFormatsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__AudioFormatsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__AudioFormatsType_sequence >*)p)[len] = *(__fims__AudioFormatsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__VideoFormatsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__VideoFormatsType_sequence >*)p)[len] = *(__fims__VideoFormatsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__JobsType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__JobsType_sequence >*)p)[len] = *(__fims__JobsType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__QueuesType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__QueuesType_sequence >*)p)[len] = *(__fims__QueuesType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ServicesType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__ServicesType_sequence >*)p)[len] = *(__fims__ServicesType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ProfilesType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__ProfilesType_sequence >*)p)[len] = *(__fims__ProfilesType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf__fims__ResourcesType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<__fims__ResourcesType_sequence >*)p)[len] = *(__fims__ResourcesType_sequence *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<fims__InnerFaultType * >*)p)[len] = *(fims__InnerFaultType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<edlprovider__ClipType * >*)p)[len] = *(edlprovider__ClipType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__wstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container EDLProvider_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::wstring >*)p)[len] = *(std::wstring *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, enum _fims__QueryServiceDescriptionRequestType_responseType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__fims__QueryServiceDescriptionRequestType_responseType
	*a = SOAP_DEFAULT__fims__QueryServiceDescriptionRequestType_responseType;
#else
	*a = (enum _fims__QueryServiceDescriptionRequestType_responseType)0;
#endif
}

static const struct soap_code_map soap_codes__fims__QueryServiceDescriptionRequestType_responseType[] =
{	{ (long)_fims__QueryServiceDescriptionRequestType_responseType__ref, "ref" },
	{ (long)_fims__QueryServiceDescriptionRequestType_responseType__value, "value" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__fims__QueryServiceDescriptionRequestType_responseType2s(struct soap *soap, enum _fims__QueryServiceDescriptionRequestType_responseType n)
{	const char *s = soap_code_str(soap_codes__fims__QueryServiceDescriptionRequestType_responseType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const char *tag, int id, const enum _fims__QueryServiceDescriptionRequestType_responseType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType), type) || soap_send(soap, soap__fims__QueryServiceDescriptionRequestType_responseType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const char *s, enum _fims__QueryServiceDescriptionRequestType_responseType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__fims__QueryServiceDescriptionRequestType_responseType, s);
	if (map)
		*a = (enum _fims__QueryServiceDescriptionRequestType_responseType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _fims__QueryServiceDescriptionRequestType_responseType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _fims__QueryServiceDescriptionRequestType_responseType * SOAP_FMAC4 soap_in__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const char *tag, enum _fims__QueryServiceDescriptionRequestType_responseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _fims__QueryServiceDescriptionRequestType_responseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType, sizeof(enum _fims__QueryServiceDescriptionRequestType_responseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_fims__QueryServiceDescriptionRequestType_responseType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _fims__QueryServiceDescriptionRequestType_responseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType, 0, sizeof(enum _fims__QueryServiceDescriptionRequestType_responseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, const enum _fims__QueryServiceDescriptionRequestType_responseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType);
	if (soap_out__fims__QueryServiceDescriptionRequestType_responseType(soap, tag?tag:"fims:QueryServiceDescriptionRequestType-responseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _fims__QueryServiceDescriptionRequestType_responseType * SOAP_FMAC4 soap_get__fims__QueryServiceDescriptionRequestType_responseType(struct soap *soap, enum _fims__QueryServiceDescriptionRequestType_responseType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__QueryServiceDescriptionRequestType_responseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__JobInfoSelectionType(struct soap *soap, enum fims__JobInfoSelectionType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__JobInfoSelectionType
	*a = SOAP_DEFAULT_fims__JobInfoSelectionType;
#else
	*a = (enum fims__JobInfoSelectionType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__JobInfoSelectionType[] =
{	{ (long)fims__JobInfoSelectionType__mandatory, "mandatory" },
	{ (long)fims__JobInfoSelectionType__all, "all" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__JobInfoSelectionType2s(struct soap *soap, enum fims__JobInfoSelectionType n)
{	const char *s = soap_code_str(soap_codes_fims__JobInfoSelectionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobInfoSelectionType(struct soap *soap, const char *tag, int id, const enum fims__JobInfoSelectionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobInfoSelectionType), type) || soap_send(soap, soap_fims__JobInfoSelectionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__JobInfoSelectionType(struct soap *soap, const char *s, enum fims__JobInfoSelectionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__JobInfoSelectionType, s);
	if (map)
		*a = (enum fims__JobInfoSelectionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__JobInfoSelectionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__JobInfoSelectionType * SOAP_FMAC4 soap_in_fims__JobInfoSelectionType(struct soap *soap, const char *tag, enum fims__JobInfoSelectionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__JobInfoSelectionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobInfoSelectionType, sizeof(enum fims__JobInfoSelectionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__JobInfoSelectionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__JobInfoSelectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobInfoSelectionType, 0, sizeof(enum fims__JobInfoSelectionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__JobInfoSelectionType(struct soap *soap, const enum fims__JobInfoSelectionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__JobInfoSelectionType);
	if (soap_out_fims__JobInfoSelectionType(soap, tag?tag:"fims:JobInfoSelectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobInfoSelectionType * SOAP_FMAC4 soap_get_fims__JobInfoSelectionType(struct soap *soap, enum fims__JobInfoSelectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobInfoSelectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__ErrorCodeType(struct soap *soap, enum fims__ErrorCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__ErrorCodeType
	*a = SOAP_DEFAULT_fims__ErrorCodeType;
#else
	*a = (enum fims__ErrorCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__ErrorCodeType[] =
{	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0001, "INF_S00_0001" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0002, "INF_S00_0002" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0003, "INF_S00_0003" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0004, "INF_S00_0004" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0005, "INF_S00_0005" },
	{ (long)fims__ErrorCodeType__INF_USCORES00_USCORE0006, "INF_S00_0006" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0001, "SVC_S00_0001" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0002, "SVC_S00_0002" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0003, "SVC_S00_0003" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0004, "SVC_S00_0004" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0005, "SVC_S00_0005" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0006, "SVC_S00_0006" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0007, "SVC_S00_0007" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0008, "SVC_S00_0008" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0009, "SVC_S00_0009" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0010, "SVC_S00_0010" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0011, "SVC_S00_0011" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0012, "SVC_S00_0012" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0013, "SVC_S00_0013" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0014, "SVC_S00_0014" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0015, "SVC_S00_0015" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0016, "SVC_S00_0016" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0017, "SVC_S00_0017" },
	{ (long)fims__ErrorCodeType__SVC_USCORES00_USCORE0018, "SVC_S00_0018" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0001, "DAT_S00_0001" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0002, "DAT_S00_0002" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0003, "DAT_S00_0003" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0004, "DAT_S00_0004" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0005, "DAT_S00_0005" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0006, "DAT_S00_0006" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0007, "DAT_S00_0007" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0008, "DAT_S00_0008" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0009, "DAT_S00_0009" },
	{ (long)fims__ErrorCodeType__DAT_USCORES00_USCORE0010, "DAT_S00_0010" },
	{ (long)fims__ErrorCodeType__EXT_USCORES00_USCORE0000, "EXT_S00_0000" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__ErrorCodeType2s(struct soap *soap, enum fims__ErrorCodeType n)
{	const char *s = soap_code_str(soap_codes_fims__ErrorCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ErrorCodeType(struct soap *soap, const char *tag, int id, const enum fims__ErrorCodeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ErrorCodeType), type) || soap_send(soap, soap_fims__ErrorCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__ErrorCodeType(struct soap *soap, const char *s, enum fims__ErrorCodeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__ErrorCodeType, s);
	if (map)
		*a = (enum fims__ErrorCodeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 34)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__ErrorCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__ErrorCodeType * SOAP_FMAC4 soap_in_fims__ErrorCodeType(struct soap *soap, const char *tag, enum fims__ErrorCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__ErrorCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ErrorCodeType, sizeof(enum fims__ErrorCodeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__ErrorCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__ErrorCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ErrorCodeType, 0, sizeof(enum fims__ErrorCodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ErrorCodeType(struct soap *soap, const enum fims__ErrorCodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ErrorCodeType);
	if (soap_out_fims__ErrorCodeType(soap, tag?tag:"fims:ErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ErrorCodeType * SOAP_FMAC4 soap_get_fims__ErrorCodeType(struct soap *soap, enum fims__ErrorCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__BitRateModeType
	*a = SOAP_DEFAULT_fims__BitRateModeType;
#else
	*a = (enum fims__BitRateModeType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__BitRateModeType[] =
{	{ (long)fims__BitRateModeType__constant, "constant" },
	{ (long)fims__BitRateModeType__variable, "variable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__BitRateModeType2s(struct soap *soap, enum fims__BitRateModeType n)
{	const char *s = soap_code_str(soap_codes_fims__BitRateModeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BitRateModeType(struct soap *soap, const char *tag, int id, const enum fims__BitRateModeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BitRateModeType), type) || soap_send(soap, soap_fims__BitRateModeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__BitRateModeType(struct soap *soap, const char *s, enum fims__BitRateModeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__BitRateModeType, s);
	if (map)
		*a = (enum fims__BitRateModeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__BitRateModeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__BitRateModeType * SOAP_FMAC4 soap_in_fims__BitRateModeType(struct soap *soap, const char *tag, enum fims__BitRateModeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__BitRateModeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BitRateModeType, sizeof(enum fims__BitRateModeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__BitRateModeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__BitRateModeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BitRateModeType, 0, sizeof(enum fims__BitRateModeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__BitRateModeType(struct soap *soap, const enum fims__BitRateModeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__BitRateModeType);
	if (soap_out_fims__BitRateModeType(soap, tag?tag:"fims:BitRateModeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__BitRateModeType * SOAP_FMAC4 soap_get_fims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BitRateModeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__ScanningOrderType
	*a = SOAP_DEFAULT_fims__ScanningOrderType;
#else
	*a = (enum fims__ScanningOrderType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__ScanningOrderType[] =
{	{ (long)fims__ScanningOrderType__top, "top" },
	{ (long)fims__ScanningOrderType__bottom, "bottom" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__ScanningOrderType2s(struct soap *soap, enum fims__ScanningOrderType n)
{	const char *s = soap_code_str(soap_codes_fims__ScanningOrderType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ScanningOrderType(struct soap *soap, const char *tag, int id, const enum fims__ScanningOrderType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ScanningOrderType), type) || soap_send(soap, soap_fims__ScanningOrderType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__ScanningOrderType(struct soap *soap, const char *s, enum fims__ScanningOrderType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__ScanningOrderType, s);
	if (map)
		*a = (enum fims__ScanningOrderType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__ScanningOrderType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__ScanningOrderType * SOAP_FMAC4 soap_in_fims__ScanningOrderType(struct soap *soap, const char *tag, enum fims__ScanningOrderType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__ScanningOrderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ScanningOrderType, sizeof(enum fims__ScanningOrderType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__ScanningOrderType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningOrderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ScanningOrderType, 0, sizeof(enum fims__ScanningOrderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ScanningOrderType(struct soap *soap, const enum fims__ScanningOrderType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ScanningOrderType);
	if (soap_out_fims__ScanningOrderType(soap, tag?tag:"fims:ScanningOrderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningOrderType * SOAP_FMAC4 soap_get_fims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ScanningOrderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__ScanningFormatType
	*a = SOAP_DEFAULT_fims__ScanningFormatType;
#else
	*a = (enum fims__ScanningFormatType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__ScanningFormatType[] =
{	{ (long)fims__ScanningFormatType__interlaced, "interlaced" },
	{ (long)fims__ScanningFormatType__progressive, "progressive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__ScanningFormatType2s(struct soap *soap, enum fims__ScanningFormatType n)
{	const char *s = soap_code_str(soap_codes_fims__ScanningFormatType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ScanningFormatType(struct soap *soap, const char *tag, int id, const enum fims__ScanningFormatType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ScanningFormatType), type) || soap_send(soap, soap_fims__ScanningFormatType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__ScanningFormatType(struct soap *soap, const char *s, enum fims__ScanningFormatType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__ScanningFormatType, s);
	if (map)
		*a = (enum fims__ScanningFormatType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__ScanningFormatType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__ScanningFormatType * SOAP_FMAC4 soap_in_fims__ScanningFormatType(struct soap *soap, const char *tag, enum fims__ScanningFormatType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__ScanningFormatType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ScanningFormatType, sizeof(enum fims__ScanningFormatType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__ScanningFormatType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ScanningFormatType, 0, sizeof(enum fims__ScanningFormatType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ScanningFormatType(struct soap *soap, const enum fims__ScanningFormatType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ScanningFormatType);
	if (soap_out_fims__ScanningFormatType(soap, tag?tag:"fims:ScanningFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningFormatType * SOAP_FMAC4 soap_get_fims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ScanningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__AudioSampleType
	*a = SOAP_DEFAULT_fims__AudioSampleType;
#else
	*a = (enum fims__AudioSampleType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__AudioSampleType[] =
{	{ (long)fims__AudioSampleType__float_, "float" },
	{ (long)fims__AudioSampleType__integer, "integer" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__AudioSampleType2s(struct soap *soap, enum fims__AudioSampleType n)
{	const char *s = soap_code_str(soap_codes_fims__AudioSampleType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AudioSampleType(struct soap *soap, const char *tag, int id, const enum fims__AudioSampleType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AudioSampleType), type) || soap_send(soap, soap_fims__AudioSampleType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__AudioSampleType(struct soap *soap, const char *s, enum fims__AudioSampleType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__AudioSampleType, s);
	if (map)
		*a = (enum fims__AudioSampleType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__AudioSampleType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__AudioSampleType * SOAP_FMAC4 soap_in_fims__AudioSampleType(struct soap *soap, const char *tag, enum fims__AudioSampleType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__AudioSampleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AudioSampleType, sizeof(enum fims__AudioSampleType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__AudioSampleType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__AudioSampleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AudioSampleType, 0, sizeof(enum fims__AudioSampleType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__AudioSampleType(struct soap *soap, const enum fims__AudioSampleType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__AudioSampleType);
	if (soap_out_fims__AudioSampleType(soap, tag?tag:"fims:AudioSampleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__AudioSampleType * SOAP_FMAC4 soap_get_fims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AudioSampleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__JobStatusType(struct soap *soap, enum fims__JobStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__JobStatusType
	*a = SOAP_DEFAULT_fims__JobStatusType;
#else
	*a = (enum fims__JobStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__JobStatusType[] =
{	{ (long)fims__JobStatusType__queued, "queued" },
	{ (long)fims__JobStatusType__running, "running" },
	{ (long)fims__JobStatusType__paused, "paused" },
	{ (long)fims__JobStatusType__completed, "completed" },
	{ (long)fims__JobStatusType__canceled, "canceled" },
	{ (long)fims__JobStatusType__stopped, "stopped" },
	{ (long)fims__JobStatusType__failed, "failed" },
	{ (long)fims__JobStatusType__cleaned, "cleaned" },
	{ (long)fims__JobStatusType__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__JobStatusType2s(struct soap *soap, enum fims__JobStatusType n)
{	const char *s = soap_code_str(soap_codes_fims__JobStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobStatusType(struct soap *soap, const char *tag, int id, const enum fims__JobStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobStatusType), type) || soap_send(soap, soap_fims__JobStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__JobStatusType(struct soap *soap, const char *s, enum fims__JobStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__JobStatusType, s);
	if (map)
		*a = (enum fims__JobStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__JobStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__JobStatusType * SOAP_FMAC4 soap_in_fims__JobStatusType(struct soap *soap, const char *tag, enum fims__JobStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__JobStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobStatusType, sizeof(enum fims__JobStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__JobStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__JobStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobStatusType, 0, sizeof(enum fims__JobStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__JobStatusType(struct soap *soap, const enum fims__JobStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__JobStatusType);
	if (soap_out_fims__JobStatusType(soap, tag?tag:"fims:JobStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobStatusType * SOAP_FMAC4 soap_get_fims__JobStatusType(struct soap *soap, enum fims__JobStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__HashFunctionTypes(struct soap *soap, enum fims__HashFunctionTypes *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__HashFunctionTypes
	*a = SOAP_DEFAULT_fims__HashFunctionTypes;
#else
	*a = (enum fims__HashFunctionTypes)0;
#endif
}

static const struct soap_code_map soap_codes_fims__HashFunctionTypes[] =
{	{ (long)fims__HashFunctionTypes__CRC32, "CRC32" },
	{ (long)fims__HashFunctionTypes__CRC64, "CRC64" },
	{ (long)fims__HashFunctionTypes__MD5, "MD5" },
	{ (long)fims__HashFunctionTypes__SHA1, "SHA1" },
	{ (long)fims__HashFunctionTypes__SHA256, "SHA256" },
	{ (long)fims__HashFunctionTypes__SHA384, "SHA384" },
	{ (long)fims__HashFunctionTypes__SHA512, "SHA512" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__HashFunctionTypes2s(struct soap *soap, enum fims__HashFunctionTypes n)
{	const char *s = soap_code_str(soap_codes_fims__HashFunctionTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__HashFunctionTypes(struct soap *soap, const char *tag, int id, const enum fims__HashFunctionTypes *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__HashFunctionTypes), type) || soap_send(soap, soap_fims__HashFunctionTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__HashFunctionTypes(struct soap *soap, const char *s, enum fims__HashFunctionTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__HashFunctionTypes, s);
	if (map)
		*a = (enum fims__HashFunctionTypes)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__HashFunctionTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__HashFunctionTypes * SOAP_FMAC4 soap_in_fims__HashFunctionTypes(struct soap *soap, const char *tag, enum fims__HashFunctionTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__HashFunctionTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__HashFunctionTypes, sizeof(enum fims__HashFunctionTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__HashFunctionTypes(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__HashFunctionTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__HashFunctionTypes, 0, sizeof(enum fims__HashFunctionTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__HashFunctionTypes(struct soap *soap, const enum fims__HashFunctionTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__HashFunctionTypes);
	if (soap_out_fims__HashFunctionTypes(soap, tag?tag:"fims:HashFunctionTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__HashFunctionTypes * SOAP_FMAC4 soap_get_fims__HashFunctionTypes(struct soap *soap, enum fims__HashFunctionTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__HashFunctionTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__JobCommandType(struct soap *soap, enum fims__JobCommandType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__JobCommandType
	*a = SOAP_DEFAULT_fims__JobCommandType;
#else
	*a = (enum fims__JobCommandType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__JobCommandType[] =
{	{ (long)fims__JobCommandType__cancel, "cancel" },
	{ (long)fims__JobCommandType__pause, "pause" },
	{ (long)fims__JobCommandType__resume, "resume" },
	{ (long)fims__JobCommandType__restart, "restart" },
	{ (long)fims__JobCommandType__stop, "stop" },
	{ (long)fims__JobCommandType__cleanup, "cleanup" },
	{ (long)fims__JobCommandType__modifyPriority, "modifyPriority" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__JobCommandType2s(struct soap *soap, enum fims__JobCommandType n)
{	const char *s = soap_code_str(soap_codes_fims__JobCommandType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobCommandType(struct soap *soap, const char *tag, int id, const enum fims__JobCommandType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobCommandType), type) || soap_send(soap, soap_fims__JobCommandType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__JobCommandType(struct soap *soap, const char *s, enum fims__JobCommandType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__JobCommandType, s);
	if (map)
		*a = (enum fims__JobCommandType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__JobCommandType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__JobCommandType * SOAP_FMAC4 soap_in_fims__JobCommandType(struct soap *soap, const char *tag, enum fims__JobCommandType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__JobCommandType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobCommandType, sizeof(enum fims__JobCommandType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__JobCommandType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__JobCommandType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobCommandType, 0, sizeof(enum fims__JobCommandType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__JobCommandType(struct soap *soap, const enum fims__JobCommandType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__JobCommandType);
	if (soap_out_fims__JobCommandType(soap, tag?tag:"fims:JobCommandType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobCommandType * SOAP_FMAC4 soap_get_fims__JobCommandType(struct soap *soap, enum fims__JobCommandType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobCommandType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__QueueCommandType(struct soap *soap, enum fims__QueueCommandType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__QueueCommandType
	*a = SOAP_DEFAULT_fims__QueueCommandType;
#else
	*a = (enum fims__QueueCommandType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__QueueCommandType[] =
{	{ (long)fims__QueueCommandType__status, "status" },
	{ (long)fims__QueueCommandType__clear, "clear" },
	{ (long)fims__QueueCommandType__stop, "stop" },
	{ (long)fims__QueueCommandType__start, "start" },
	{ (long)fims__QueueCommandType__lock, "lock" },
	{ (long)fims__QueueCommandType__unlock, "unlock" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__QueueCommandType2s(struct soap *soap, enum fims__QueueCommandType n)
{	const char *s = soap_code_str(soap_codes_fims__QueueCommandType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueueCommandType(struct soap *soap, const char *tag, int id, const enum fims__QueueCommandType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueueCommandType), type) || soap_send(soap, soap_fims__QueueCommandType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__QueueCommandType(struct soap *soap, const char *s, enum fims__QueueCommandType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__QueueCommandType, s);
	if (map)
		*a = (enum fims__QueueCommandType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__QueueCommandType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__QueueCommandType * SOAP_FMAC4 soap_in_fims__QueueCommandType(struct soap *soap, const char *tag, enum fims__QueueCommandType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__QueueCommandType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueueCommandType, sizeof(enum fims__QueueCommandType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__QueueCommandType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__QueueCommandType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueueCommandType, 0, sizeof(enum fims__QueueCommandType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__QueueCommandType(struct soap *soap, const enum fims__QueueCommandType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__QueueCommandType);
	if (soap_out_fims__QueueCommandType(soap, tag?tag:"fims:QueueCommandType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueueCommandType * SOAP_FMAC4 soap_get_fims__QueueCommandType(struct soap *soap, enum fims__QueueCommandType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueueCommandType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__StorageTypes(struct soap *soap, enum fims__StorageTypes *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__StorageTypes
	*a = SOAP_DEFAULT_fims__StorageTypes;
#else
	*a = (enum fims__StorageTypes)0;
#endif
}

static const struct soap_code_map soap_codes_fims__StorageTypes[] =
{	{ (long)fims__StorageTypes__online, "online" },
	{ (long)fims__StorageTypes__offline, "offline" },
	{ (long)fims__StorageTypes__hsm, "hsm" },
	{ (long)fims__StorageTypes__archive, "archive" },
	{ (long)fims__StorageTypes__playout, "playout" },
	{ (long)fims__StorageTypes__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__StorageTypes2s(struct soap *soap, enum fims__StorageTypes n)
{	const char *s = soap_code_str(soap_codes_fims__StorageTypes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StorageTypes(struct soap *soap, const char *tag, int id, const enum fims__StorageTypes *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StorageTypes), type) || soap_send(soap, soap_fims__StorageTypes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__StorageTypes(struct soap *soap, const char *s, enum fims__StorageTypes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__StorageTypes, s);
	if (map)
		*a = (enum fims__StorageTypes)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__StorageTypes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__StorageTypes * SOAP_FMAC4 soap_in_fims__StorageTypes(struct soap *soap, const char *tag, enum fims__StorageTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__StorageTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StorageTypes, sizeof(enum fims__StorageTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__StorageTypes(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__StorageTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StorageTypes, 0, sizeof(enum fims__StorageTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__StorageTypes(struct soap *soap, const enum fims__StorageTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__StorageTypes);
	if (soap_out_fims__StorageTypes(soap, tag?tag:"fims:StorageTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__StorageTypes * SOAP_FMAC4 soap_get_fims__StorageTypes(struct soap *soap, enum fims__StorageTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StorageTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__PriorityType(struct soap *soap, enum fims__PriorityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__PriorityType
	*a = SOAP_DEFAULT_fims__PriorityType;
#else
	*a = (enum fims__PriorityType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__PriorityType[] =
{	{ (long)fims__PriorityType__low, "low" },
	{ (long)fims__PriorityType__medium, "medium" },
	{ (long)fims__PriorityType__high, "high" },
	{ (long)fims__PriorityType__urgent, "urgent" },
	{ (long)fims__PriorityType__immediate, "immediate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__PriorityType2s(struct soap *soap, enum fims__PriorityType n)
{	const char *s = soap_code_str(soap_codes_fims__PriorityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__PriorityType(struct soap *soap, const char *tag, int id, const enum fims__PriorityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__PriorityType), type) || soap_send(soap, soap_fims__PriorityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__PriorityType(struct soap *soap, const char *s, enum fims__PriorityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__PriorityType, s);
	if (map)
		*a = (enum fims__PriorityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__PriorityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__PriorityType * SOAP_FMAC4 soap_in_fims__PriorityType(struct soap *soap, const char *tag, enum fims__PriorityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__PriorityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__PriorityType, sizeof(enum fims__PriorityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__PriorityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__PriorityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__PriorityType, 0, sizeof(enum fims__PriorityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__PriorityType(struct soap *soap, const enum fims__PriorityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__PriorityType);
	if (soap_out_fims__PriorityType(soap, tag?tag:"fims:PriorityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__PriorityType * SOAP_FMAC4 soap_get_fims__PriorityType(struct soap *soap, enum fims__PriorityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__PriorityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_fims__QueueStatusType
	*a = SOAP_DEFAULT_fims__QueueStatusType;
#else
	*a = (enum fims__QueueStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_fims__QueueStatusType[] =
{	{ (long)fims__QueueStatusType__started, "started" },
	{ (long)fims__QueueStatusType__stopped, "stopped" },
	{ (long)fims__QueueStatusType__locked, "locked" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_fims__QueueStatusType2s(struct soap *soap, enum fims__QueueStatusType n)
{	const char *s = soap_code_str(soap_codes_fims__QueueStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueueStatusType(struct soap *soap, const char *tag, int id, const enum fims__QueueStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueueStatusType), type) || soap_send(soap, soap_fims__QueueStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2fims__QueueStatusType(struct soap *soap, const char *s, enum fims__QueueStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_fims__QueueStatusType, s);
	if (map)
		*a = (enum fims__QueueStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum fims__QueueStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum fims__QueueStatusType * SOAP_FMAC4 soap_in_fims__QueueStatusType(struct soap *soap, const char *tag, enum fims__QueueStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum fims__QueueStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueueStatusType, sizeof(enum fims__QueueStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2fims__QueueStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum fims__QueueStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueueStatusType, 0, sizeof(enum fims__QueueStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__QueueStatusType(struct soap *soap, const enum fims__QueueStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__QueueStatusType);
	if (soap_out_fims__QueueStatusType(soap, tag?tag:"fims:QueueStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueueStatusType * SOAP_FMAC4 soap_get_fims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueueStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_edlprovider__EDLProviderErrorCodeType(struct soap *soap, enum edlprovider__EDLProviderErrorCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_edlprovider__EDLProviderErrorCodeType
	*a = SOAP_DEFAULT_edlprovider__EDLProviderErrorCodeType;
#else
	*a = (enum edlprovider__EDLProviderErrorCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_edlprovider__EDLProviderErrorCodeType[] =
{	{ (long)edlprovider__EDLProviderErrorCodeType__EXT_USCORES00_USCORE0001, "EXT_S00_0001" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_edlprovider__EDLProviderErrorCodeType2s(struct soap *soap, enum edlprovider__EDLProviderErrorCodeType n)
{	const char *s = soap_code_str(soap_codes_edlprovider__EDLProviderErrorCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EDLProviderErrorCodeType(struct soap *soap, const char *tag, int id, const enum edlprovider__EDLProviderErrorCodeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EDLProviderErrorCodeType), type) || soap_send(soap, soap_edlprovider__EDLProviderErrorCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2edlprovider__EDLProviderErrorCodeType(struct soap *soap, const char *s, enum edlprovider__EDLProviderErrorCodeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_edlprovider__EDLProviderErrorCodeType, s);
	if (map)
		*a = (enum edlprovider__EDLProviderErrorCodeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum edlprovider__EDLProviderErrorCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum edlprovider__EDLProviderErrorCodeType * SOAP_FMAC4 soap_in_edlprovider__EDLProviderErrorCodeType(struct soap *soap, const char *tag, enum edlprovider__EDLProviderErrorCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum edlprovider__EDLProviderErrorCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EDLProviderErrorCodeType, sizeof(enum edlprovider__EDLProviderErrorCodeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2edlprovider__EDLProviderErrorCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum edlprovider__EDLProviderErrorCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EDLProviderErrorCodeType, 0, sizeof(enum edlprovider__EDLProviderErrorCodeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_edlprovider__EDLProviderErrorCodeType(struct soap *soap, const enum edlprovider__EDLProviderErrorCodeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_edlprovider__EDLProviderErrorCodeType);
	if (soap_out_edlprovider__EDLProviderErrorCodeType(soap, tag?tag:"edlprovider:EDLProviderErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum edlprovider__EDLProviderErrorCodeType * SOAP_FMAC4 soap_get_edlprovider__EDLProviderErrorCodeType(struct soap *soap, enum edlprovider__EDLProviderErrorCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EDLProviderErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _fims__ContainerFormatType_containerFormat::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &this->_fims__ContainerFormatType_containerFormat::__item);
	this->_fims__ContainerFormatType_containerFormat::formatLabel = NULL;
	this->_fims__ContainerFormatType_containerFormat::formatDefinition = NULL;
	this->_fims__ContainerFormatType_containerFormat::formatLink = NULL;
}

void _fims__ContainerFormatType_containerFormat::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_fims__ContainerFormatType_containerFormat::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->_fims__ContainerFormatType_containerFormat::__item);
#endif
}

int _fims__ContainerFormatType_containerFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__ContainerFormatType_containerFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, int id, const _fims__ContainerFormatType_containerFormat *a, const char *type)
{
	if (((_fims__ContainerFormatType_containerFormat*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((_fims__ContainerFormatType_containerFormat*)a)->formatLabel->c_str()), 2);
	if (((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition->c_str()), 2);
	if (((_fims__ContainerFormatType_containerFormat*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((_fims__ContainerFormatType_containerFormat*)a)->formatLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->_fims__ContainerFormatType_containerFormat::__item, "");
}

void *_fims__ContainerFormatType_containerFormat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__ContainerFormatType_containerFormat(soap, tag, this, type);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat * SOAP_FMAC4 soap_in__fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, _fims__ContainerFormatType_containerFormat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_fims__ContainerFormatType_containerFormat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__ContainerFormatType_containerFormat, sizeof(_fims__ContainerFormatType_containerFormat), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__ContainerFormatType_containerFormat)
			return (_fims__ContainerFormatType_containerFormat *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((_fims__ContainerFormatType_containerFormat*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__ContainerFormatType_containerFormat*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((_fims__ContainerFormatType_containerFormat*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((_fims__ContainerFormatType_containerFormat*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((_fims__ContainerFormatType_containerFormat*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__ContainerFormatType_containerFormat*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((_fims__ContainerFormatType_containerFormat*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->_fims__ContainerFormatType_containerFormat::__item), ""))
		return NULL;
	return a;
}

int _fims__ContainerFormatType_containerFormat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__ContainerFormatType_containerFormat);
	if (this->soap_out(soap, tag?tag:"fims:ContainerFormatType-containerFormat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__ContainerFormatType_containerFormat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__ContainerFormatType_containerFormat(soap, this, tag, type);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat * SOAP_FMAC4 soap_get__fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__ContainerFormatType_containerFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__ContainerFormatType_containerFormat * SOAP_FMAC2 soap_instantiate__fims__ContainerFormatType_containerFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__ContainerFormatType_containerFormat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__ContainerFormatType_containerFormat, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__ContainerFormatType_containerFormat);
		if (size)
			*size = sizeof(_fims__ContainerFormatType_containerFormat);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__ContainerFormatType_containerFormat, n);
		if (size)
			*size = n * sizeof(_fims__ContainerFormatType_containerFormat);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__ContainerFormatType_containerFormat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__ContainerFormatType_containerFormat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__ContainerFormatType_containerFormat %p -> %p\n", q, p));
	*(_fims__ContainerFormatType_containerFormat*)p = *(_fims__ContainerFormatType_containerFormat*)q;
}

void _fims__AudioFormatType_trackConfiguration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fims__AudioFormatType_trackConfiguration::typeLabel = NULL;
	this->_fims__AudioFormatType_trackConfiguration::typeDefinition = NULL;
	this->_fims__AudioFormatType_trackConfiguration::typeLink = NULL;
}

void _fims__AudioFormatType_trackConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fims__AudioFormatType_trackConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__AudioFormatType_trackConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, int id, const _fims__AudioFormatType_trackConfiguration *a, const char *type)
{
	if (((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel->c_str()), 2);
	if (((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition->c_str()), 2);
	if (((_fims__AudioFormatType_trackConfiguration*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fims__AudioFormatType_trackConfiguration*)a)->typeLink->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fims__AudioFormatType_trackConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__AudioFormatType_trackConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration * SOAP_FMAC4 soap_in__fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, _fims__AudioFormatType_trackConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fims__AudioFormatType_trackConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, sizeof(_fims__AudioFormatType_trackConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__AudioFormatType_trackConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fims__AudioFormatType_trackConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fims__AudioFormatType_trackConfiguration*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fims__AudioFormatType_trackConfiguration*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fims__AudioFormatType_trackConfiguration*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__AudioFormatType_trackConfiguration*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fims__AudioFormatType_trackConfiguration*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fims__AudioFormatType_trackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, 0, sizeof(_fims__AudioFormatType_trackConfiguration), 0, soap_copy__fims__AudioFormatType_trackConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fims__AudioFormatType_trackConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__AudioFormatType_trackConfiguration);
	if (this->soap_out(soap, tag?tag:"fims:AudioFormatType-trackConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__AudioFormatType_trackConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__AudioFormatType_trackConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration * SOAP_FMAC4 soap_get__fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__AudioFormatType_trackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__AudioFormatType_trackConfiguration * SOAP_FMAC2 soap_instantiate__fims__AudioFormatType_trackConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__AudioFormatType_trackConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__AudioFormatType_trackConfiguration);
		if (size)
			*size = sizeof(_fims__AudioFormatType_trackConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__AudioFormatType_trackConfiguration, n);
		if (size)
			*size = n * sizeof(_fims__AudioFormatType_trackConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__AudioFormatType_trackConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__AudioFormatType_trackConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__AudioFormatType_trackConfiguration %p -> %p\n", q, p));
	*(_fims__AudioFormatType_trackConfiguration*)p = *(_fims__AudioFormatType_trackConfiguration*)q;
}

void _fims__BMEssenceLocatorType_containerMimeType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &this->_fims__BMEssenceLocatorType_containerMimeType::__item);
	this->_fims__BMEssenceLocatorType_containerMimeType::typeLabel = NULL;
	this->_fims__BMEssenceLocatorType_containerMimeType::typeDefinition = NULL;
	this->_fims__BMEssenceLocatorType_containerMimeType::typeLink = NULL;
}

void _fims__BMEssenceLocatorType_containerMimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_fims__BMEssenceLocatorType_containerMimeType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->_fims__BMEssenceLocatorType_containerMimeType::__item);
#endif
}

int _fims__BMEssenceLocatorType_containerMimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__BMEssenceLocatorType_containerMimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, int id, const _fims__BMEssenceLocatorType_containerMimeType *a, const char *type)
{
	if (((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel->c_str()), 2);
	if (((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition->c_str()), 2);
	if (((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->_fims__BMEssenceLocatorType_containerMimeType::__item, "");
}

void *_fims__BMEssenceLocatorType_containerMimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__BMEssenceLocatorType_containerMimeType(soap, tag, this, type);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType * SOAP_FMAC4 soap_in__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, _fims__BMEssenceLocatorType_containerMimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_fims__BMEssenceLocatorType_containerMimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType, sizeof(_fims__BMEssenceLocatorType_containerMimeType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType)
			return (_fims__BMEssenceLocatorType_containerMimeType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fims__BMEssenceLocatorType_containerMimeType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->_fims__BMEssenceLocatorType_containerMimeType::__item), ""))
		return NULL;
	return a;
}

int _fims__BMEssenceLocatorType_containerMimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorType-containerMimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__BMEssenceLocatorType_containerMimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__BMEssenceLocatorType_containerMimeType(soap, this, tag, type);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType * SOAP_FMAC4 soap_get__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__BMEssenceLocatorType_containerMimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__BMEssenceLocatorType_containerMimeType * SOAP_FMAC2 soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__BMEssenceLocatorType_containerMimeType);
		if (size)
			*size = sizeof(_fims__BMEssenceLocatorType_containerMimeType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__BMEssenceLocatorType_containerMimeType, n);
		if (size)
			*size = n * sizeof(_fims__BMEssenceLocatorType_containerMimeType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__BMEssenceLocatorType_containerMimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__BMEssenceLocatorType_containerMimeType %p -> %p\n", q, p));
	*(_fims__BMEssenceLocatorType_containerMimeType*)p = *(_fims__BMEssenceLocatorType_containerMimeType*)q;
}

void _fims__BMContentFormatType_mimeType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__wstring(soap, &this->_fims__BMContentFormatType_mimeType::__item);
	this->_fims__BMContentFormatType_mimeType::typeLabel = NULL;
	this->_fims__BMContentFormatType_mimeType::typeDefinition = NULL;
	this->_fims__BMContentFormatType_mimeType::typeLink = NULL;
}

void _fims__BMContentFormatType_mimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_fims__BMContentFormatType_mimeType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->_fims__BMContentFormatType_mimeType::__item);
#endif
}

int _fims__BMContentFormatType_mimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__BMContentFormatType_mimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, int id, const _fims__BMContentFormatType_mimeType *a, const char *type)
{
	if (((_fims__BMContentFormatType_mimeType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fims__BMContentFormatType_mimeType*)a)->typeLabel->c_str()), 2);
	if (((_fims__BMContentFormatType_mimeType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fims__BMContentFormatType_mimeType*)a)->typeDefinition->c_str()), 2);
	if (((_fims__BMContentFormatType_mimeType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fims__BMContentFormatType_mimeType*)a)->typeLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->_fims__BMContentFormatType_mimeType::__item, "");
}

void *_fims__BMContentFormatType_mimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__BMContentFormatType_mimeType(soap, tag, this, type);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType * SOAP_FMAC4 soap_in__fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, _fims__BMContentFormatType_mimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (_fims__BMContentFormatType_mimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__BMContentFormatType_mimeType, sizeof(_fims__BMContentFormatType_mimeType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__BMContentFormatType_mimeType)
			return (_fims__BMContentFormatType_mimeType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fims__BMContentFormatType_mimeType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMContentFormatType_mimeType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fims__BMContentFormatType_mimeType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fims__BMContentFormatType_mimeType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMContentFormatType_mimeType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fims__BMContentFormatType_mimeType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fims__BMContentFormatType_mimeType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fims__BMContentFormatType_mimeType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fims__BMContentFormatType_mimeType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->_fims__BMContentFormatType_mimeType::__item), ""))
		return NULL;
	return a;
}

int _fims__BMContentFormatType_mimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__BMContentFormatType_mimeType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentFormatType-mimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__BMContentFormatType_mimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__BMContentFormatType_mimeType(soap, this, tag, type);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType * SOAP_FMAC4 soap_get__fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__BMContentFormatType_mimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__BMContentFormatType_mimeType * SOAP_FMAC2 soap_instantiate__fims__BMContentFormatType_mimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__BMContentFormatType_mimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__BMContentFormatType_mimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__BMContentFormatType_mimeType);
		if (size)
			*size = sizeof(_fims__BMContentFormatType_mimeType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__BMContentFormatType_mimeType, n);
		if (size)
			*size = n * sizeof(_fims__BMContentFormatType_mimeType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__BMContentFormatType_mimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__BMContentFormatType_mimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__BMContentFormatType_mimeType %p -> %p\n", q, p));
	*(_fims__BMContentFormatType_mimeType*)p = *(_fims__BMContentFormatType_mimeType*)q;
}

void _fims__ServiceType_serviceDescription::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_fims__ServiceType_serviceDescription::__any);
}

void _fims__ServiceType_serviceDescription::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_fims__ServiceType_serviceDescription::__any);
#endif
}

int _fims__ServiceType_serviceDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__ServiceType_serviceDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, int id, const _fims__ServiceType_serviceDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__ServiceType_serviceDescription), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->_fims__ServiceType_serviceDescription::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fims__ServiceType_serviceDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__ServiceType_serviceDescription(soap, tag, this, type);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription * SOAP_FMAC4 soap_in__fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, _fims__ServiceType_serviceDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fims__ServiceType_serviceDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__ServiceType_serviceDescription, sizeof(_fims__ServiceType_serviceDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__ServiceType_serviceDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fims__ServiceType_serviceDescription *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->_fims__ServiceType_serviceDescription::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fims__ServiceType_serviceDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__ServiceType_serviceDescription, 0, sizeof(_fims__ServiceType_serviceDescription), 0, soap_copy__fims__ServiceType_serviceDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fims__ServiceType_serviceDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__ServiceType_serviceDescription);
	if (this->soap_out(soap, tag?tag:"fims:ServiceType-serviceDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__ServiceType_serviceDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__ServiceType_serviceDescription(soap, this, tag, type);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription * SOAP_FMAC4 soap_get__fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__ServiceType_serviceDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__ServiceType_serviceDescription * SOAP_FMAC2 soap_instantiate__fims__ServiceType_serviceDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__ServiceType_serviceDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__ServiceType_serviceDescription, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__ServiceType_serviceDescription);
		if (size)
			*size = sizeof(_fims__ServiceType_serviceDescription);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__ServiceType_serviceDescription, n);
		if (size)
			*size = n * sizeof(_fims__ServiceType_serviceDescription);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__ServiceType_serviceDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__ServiceType_serviceDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__ServiceType_serviceDescription %p -> %p\n", q, p));
	*(_fims__ServiceType_serviceDescription*)p = *(_fims__ServiceType_serviceDescription*)q;
}

void _fimsdescription__addressType_country::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__addressType_country::typeLabel = NULL;
	this->_fimsdescription__addressType_country::typeDefinition = NULL;
	this->_fimsdescription__addressType_country::typeLink = NULL;
	this->_fimsdescription__addressType_country::typeLanguage = NULL;
}

void _fimsdescription__addressType_country::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__addressType_country::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__addressType_country(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__addressType_country(struct soap *soap, const char *tag, int id, const _fimsdescription__addressType_country *a, const char *type)
{
	if (((_fimsdescription__addressType_country*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__addressType_country*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__addressType_country*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__addressType_country*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__addressType_country*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__addressType_country), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__addressType_country::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__addressType_country(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__addressType_country * SOAP_FMAC4 soap_in__fimsdescription__addressType_country(struct soap *soap, const char *tag, _fimsdescription__addressType_country *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__addressType_country *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__addressType_country, sizeof(_fimsdescription__addressType_country), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__addressType_country)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__addressType_country *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__addressType_country*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__addressType_country*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__addressType_country*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__addressType_country *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__addressType_country, 0, sizeof(_fimsdescription__addressType_country), 0, soap_copy__fimsdescription__addressType_country);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__addressType_country::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__addressType_country);
	if (this->soap_out(soap, tag?tag:"fimsdescription:addressType-country", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__addressType_country::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__addressType_country(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__addressType_country * SOAP_FMAC4 soap_get__fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__addressType_country(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__addressType_country * SOAP_FMAC2 soap_instantiate__fimsdescription__addressType_country(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__addressType_country(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__addressType_country, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__addressType_country);
		if (size)
			*size = sizeof(_fimsdescription__addressType_country);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__addressType_country, n);
		if (size)
			*size = n * sizeof(_fimsdescription__addressType_country);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__addressType_country*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__addressType_country(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__addressType_country %p -> %p\n", q, p));
	*(_fimsdescription__addressType_country*)p = *(_fimsdescription__addressType_country*)q;
}

void _fimsdescription__organisationDetailsType_organisationDepartment::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__organisationDetailsType_organisationDepartment::departmentId = NULL;
}

void _fimsdescription__organisationDetailsType_organisationDepartment::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__organisationDetailsType_organisationDepartment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, int id, const _fimsdescription__organisationDetailsType_organisationDepartment *a, const char *type)
{
	if (((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId)
		soap_set_attr(soap, "departmentId", soap_wchar2s(soap, ((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__organisationDetailsType_organisationDepartment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment * SOAP_FMAC4 soap_in__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, _fimsdescription__organisationDetailsType_organisationDepartment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__organisationDetailsType_organisationDepartment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__organisationDetailsType_organisationDepartment *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "departmentId", 0);
		if (t)
		{
			if (!(((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId = soap_new_std__wstring(soap, -1);
				((_fimsdescription__organisationDetailsType_organisationDepartment*)a)->departmentId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__organisationDetailsType_organisationDepartment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, 0, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment), 0, soap_copy__fimsdescription__organisationDetailsType_organisationDepartment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__organisationDetailsType_organisationDepartment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment);
	if (this->soap_out(soap, tag?tag:"fimsdescription:organisationDetailsType-organisationDepartment", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__organisationDetailsType_organisationDepartment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__organisationDetailsType_organisationDepartment(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment * SOAP_FMAC4 soap_get__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__organisationDetailsType_organisationDepartment * SOAP_FMAC2 soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__organisationDetailsType_organisationDepartment);
		if (size)
			*size = sizeof(_fimsdescription__organisationDetailsType_organisationDepartment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__organisationDetailsType_organisationDepartment, n);
		if (size)
			*size = n * sizeof(_fimsdescription__organisationDetailsType_organisationDepartment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__organisationDetailsType_organisationDepartment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__organisationDetailsType_organisationDepartment %p -> %p\n", q, p));
	*(_fimsdescription__organisationDetailsType_organisationDepartment*)p = *(_fimsdescription__organisationDetailsType_organisationDepartment*)q;
}

void _fimsdescription__entityType_role::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__entityType_role::typeLabel = NULL;
	this->_fimsdescription__entityType_role::typeDefinition = NULL;
	this->_fimsdescription__entityType_role::typeLink = NULL;
	this->_fimsdescription__entityType_role::typeLanguage = NULL;
}

void _fimsdescription__entityType_role::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__entityType_role::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__entityType_role(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__entityType_role(struct soap *soap, const char *tag, int id, const _fimsdescription__entityType_role *a, const char *type)
{
	if (((_fimsdescription__entityType_role*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__entityType_role*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__entityType_role*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__entityType_role*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__entityType_role*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__entityType_role), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__entityType_role::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__entityType_role(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__entityType_role * SOAP_FMAC4 soap_in__fimsdescription__entityType_role(struct soap *soap, const char *tag, _fimsdescription__entityType_role *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__entityType_role *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__entityType_role, sizeof(_fimsdescription__entityType_role), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__entityType_role)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__entityType_role *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__entityType_role*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__entityType_role*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__entityType_role*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__entityType_role *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__entityType_role, 0, sizeof(_fimsdescription__entityType_role), 0, soap_copy__fimsdescription__entityType_role);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__entityType_role::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__entityType_role);
	if (this->soap_out(soap, tag?tag:"fimsdescription:entityType-role", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__entityType_role::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__entityType_role(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__entityType_role * SOAP_FMAC4 soap_get__fimsdescription__entityType_role(struct soap *soap, _fimsdescription__entityType_role *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__entityType_role(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__entityType_role * SOAP_FMAC2 soap_instantiate__fimsdescription__entityType_role(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__entityType_role(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__entityType_role, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__entityType_role);
		if (size)
			*size = sizeof(_fimsdescription__entityType_role);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__entityType_role, n);
		if (size)
			*size = n * sizeof(_fimsdescription__entityType_role);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__entityType_role*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__entityType_role(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__entityType_role %p -> %p\n", q, p));
	*(_fimsdescription__entityType_role*)p = *(_fimsdescription__entityType_role*)q;
}

void _fimsdescription__dateType_alternative::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_alternative::startYear = NULL;
	this->_fimsdescription__dateType_alternative::startDate = NULL;
	this->_fimsdescription__dateType_alternative::startTime = NULL;
	this->_fimsdescription__dateType_alternative::endYear = NULL;
	this->_fimsdescription__dateType_alternative::endDate = NULL;
	this->_fimsdescription__dateType_alternative::endTime = NULL;
	this->_fimsdescription__dateType_alternative::period = NULL;
	this->_fimsdescription__dateType_alternative::typeLabel = NULL;
	this->_fimsdescription__dateType_alternative::typeDefinition = NULL;
	this->_fimsdescription__dateType_alternative::typeLink = NULL;
	this->_fimsdescription__dateType_alternative::typeLanguage = NULL;
}

void _fimsdescription__dateType_alternative::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_alternative::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_alternative(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_alternative(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_alternative *a, const char *type)
{
	if (((_fimsdescription__dateType_alternative*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->period->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__dateType_alternative*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__dateType_alternative*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_alternative), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_alternative::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_alternative(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative * SOAP_FMAC4 soap_in__fimsdescription__dateType_alternative(struct soap *soap, const char *tag, _fimsdescription__dateType_alternative *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_alternative *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_alternative, sizeof(_fimsdescription__dateType_alternative), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_alternative)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_alternative *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_alternative*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_alternative*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_alternative*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_alternative *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_alternative, 0, sizeof(_fimsdescription__dateType_alternative), 0, soap_copy__fimsdescription__dateType_alternative);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_alternative::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_alternative);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-alternative", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_alternative::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_alternative(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative * SOAP_FMAC4 soap_get__fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_alternative(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_alternative * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_alternative(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_alternative(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_alternative, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_alternative);
		if (size)
			*size = sizeof(_fimsdescription__dateType_alternative);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_alternative, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_alternative);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_alternative*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_alternative(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_alternative %p -> %p\n", q, p));
	*(_fimsdescription__dateType_alternative*)p = *(_fimsdescription__dateType_alternative*)q;
}

void _fimsdescription__dateType_issued::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_issued::startYear = NULL;
	this->_fimsdescription__dateType_issued::startDate = NULL;
	this->_fimsdescription__dateType_issued::startTime = NULL;
	this->_fimsdescription__dateType_issued::endYear = NULL;
	this->_fimsdescription__dateType_issued::endDate = NULL;
	this->_fimsdescription__dateType_issued::endTime = NULL;
	this->_fimsdescription__dateType_issued::period = NULL;
}

void _fimsdescription__dateType_issued::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_issued::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_issued(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_issued(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_issued *a, const char *type)
{
	if (((_fimsdescription__dateType_issued*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_issued*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_issued*)a)->period->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_issued), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_issued::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_issued(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_issued * SOAP_FMAC4 soap_in__fimsdescription__dateType_issued(struct soap *soap, const char *tag, _fimsdescription__dateType_issued *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_issued *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_issued, sizeof(_fimsdescription__dateType_issued), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_issued)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_issued *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_issued*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_issued*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_issued*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_issued *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_issued, 0, sizeof(_fimsdescription__dateType_issued), 0, soap_copy__fimsdescription__dateType_issued);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_issued::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_issued);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-issued", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_issued::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_issued(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_issued * SOAP_FMAC4 soap_get__fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_issued(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_issued * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_issued(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_issued(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_issued, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_issued);
		if (size)
			*size = sizeof(_fimsdescription__dateType_issued);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_issued, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_issued);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_issued*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_issued(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_issued %p -> %p\n", q, p));
	*(_fimsdescription__dateType_issued*)p = *(_fimsdescription__dateType_issued*)q;
}

void _fimsdescription__dateType_modified::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_modified::startYear = NULL;
	this->_fimsdescription__dateType_modified::startDate = NULL;
	this->_fimsdescription__dateType_modified::startTime = NULL;
	this->_fimsdescription__dateType_modified::endYear = NULL;
	this->_fimsdescription__dateType_modified::endDate = NULL;
	this->_fimsdescription__dateType_modified::endTime = NULL;
	this->_fimsdescription__dateType_modified::period = NULL;
}

void _fimsdescription__dateType_modified::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_modified::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_modified(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_modified(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_modified *a, const char *type)
{
	if (((_fimsdescription__dateType_modified*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_modified*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_modified*)a)->period->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_modified), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_modified::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_modified(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_modified * SOAP_FMAC4 soap_in__fimsdescription__dateType_modified(struct soap *soap, const char *tag, _fimsdescription__dateType_modified *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_modified *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_modified, sizeof(_fimsdescription__dateType_modified), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_modified)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_modified *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_modified*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_modified*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_modified*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_modified *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_modified, 0, sizeof(_fimsdescription__dateType_modified), 0, soap_copy__fimsdescription__dateType_modified);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_modified::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_modified);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-modified", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_modified::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_modified(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_modified * SOAP_FMAC4 soap_get__fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_modified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_modified * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_modified(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_modified(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_modified, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_modified);
		if (size)
			*size = sizeof(_fimsdescription__dateType_modified);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_modified, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_modified);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_modified*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_modified(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_modified %p -> %p\n", q, p));
	*(_fimsdescription__dateType_modified*)p = *(_fimsdescription__dateType_modified*)q;
}

void _fimsdescription__dateType_created::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__dateType_created::startYear = NULL;
	this->_fimsdescription__dateType_created::startDate = NULL;
	this->_fimsdescription__dateType_created::startTime = NULL;
	this->_fimsdescription__dateType_created::endYear = NULL;
	this->_fimsdescription__dateType_created::endDate = NULL;
	this->_fimsdescription__dateType_created::endTime = NULL;
	this->_fimsdescription__dateType_created::period = NULL;
}

void _fimsdescription__dateType_created::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__dateType_created::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__dateType_created(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__dateType_created(struct soap *soap, const char *tag, int id, const _fimsdescription__dateType_created *a, const char *type)
{
	if (((_fimsdescription__dateType_created*)a)->startYear)
		soap_set_attr(soap, "startYear", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->startYear->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->startDate)
		soap_set_attr(soap, "startDate", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->startDate->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->startTime)
		soap_set_attr(soap, "startTime", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->startTime->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->endYear)
		soap_set_attr(soap, "endYear", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->endYear->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->endDate)
		soap_set_attr(soap, "endDate", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->endDate->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->endTime)
		soap_set_attr(soap, "endTime", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->endTime->c_str()), 2);
	if (((_fimsdescription__dateType_created*)a)->period)
		soap_set_attr(soap, "period", soap_wchar2s(soap, ((_fimsdescription__dateType_created*)a)->period->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__dateType_created), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__dateType_created::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__dateType_created(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__dateType_created * SOAP_FMAC4 soap_in__fimsdescription__dateType_created(struct soap *soap, const char *tag, _fimsdescription__dateType_created *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__dateType_created *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__dateType_created, sizeof(_fimsdescription__dateType_created), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__dateType_created)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__dateType_created *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "startYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->startYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->startYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->startYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->startDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->startDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->startDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->startTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->startTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->startTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endYear", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->endYear = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->endYear = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->endYear->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endDate", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->endDate = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->endDate = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->endDate->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "endTime", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->endTime = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->endTime = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->endTime->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "period", 0);
		if (t)
		{
			if (!(((_fimsdescription__dateType_created*)a)->period = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__dateType_created*)a)->period = soap_new_std__wstring(soap, -1);
				((_fimsdescription__dateType_created*)a)->period->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__dateType_created *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__dateType_created, 0, sizeof(_fimsdescription__dateType_created), 0, soap_copy__fimsdescription__dateType_created);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__dateType_created::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__dateType_created);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType-created", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__dateType_created::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__dateType_created(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__dateType_created * SOAP_FMAC4 soap_get__fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__dateType_created(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__dateType_created * SOAP_FMAC2 soap_instantiate__fimsdescription__dateType_created(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__dateType_created(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__dateType_created, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__dateType_created);
		if (size)
			*size = sizeof(_fimsdescription__dateType_created);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__dateType_created, n);
		if (size)
			*size = n * sizeof(_fimsdescription__dateType_created);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__dateType_created*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__dateType_created(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__dateType_created %p -> %p\n", q, p));
	*(_fimsdescription__dateType_created*)p = *(_fimsdescription__dateType_created*)q;
}

void _fimsdescription__coverageType_spatial_coordinates::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_float(soap, &this->_fimsdescription__coverageType_spatial_coordinates::posy);
	soap_default_float(soap, &this->_fimsdescription__coverageType_spatial_coordinates::posx);
	this->_fimsdescription__coverageType_spatial_coordinates::formatLabel = NULL;
	this->_fimsdescription__coverageType_spatial_coordinates::formatDefinition = NULL;
	this->_fimsdescription__coverageType_spatial_coordinates::formatLink = NULL;
	this->_fimsdescription__coverageType_spatial_coordinates::formatLanguage = NULL;
}

void _fimsdescription__coverageType_spatial_coordinates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__coverageType_spatial_coordinates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_spatial_coordinates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_spatial_coordinates *a, const char *type)
{
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage)
		soap_set_attr(soap, "formatLanguage", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates), type))
		return soap->error;
	if (soap_out_float(soap, "fimsdescription:posy", -1, &(a->_fimsdescription__coverageType_spatial_coordinates::posy), ""))
		return soap->error;
	if (soap_out_float(soap, "fimsdescription:posx", -1, &(a->_fimsdescription__coverageType_spatial_coordinates::posx), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_spatial_coordinates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_spatial_coordinates(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates * SOAP_FMAC4 soap_in__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial_coordinates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_spatial_coordinates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, sizeof(_fimsdescription__coverageType_spatial_coordinates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_spatial_coordinates *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_coordinates*)a)->formatLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_posy1 = 1;
	size_t soap_flag_posx1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_posy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "fimsdescription:posy", &(a->_fimsdescription__coverageType_spatial_coordinates::posy), "xsd:float"))
				{	soap_flag_posy1--;
					continue;
				}
			if (soap_flag_posx1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "fimsdescription:posx", &(a->_fimsdescription__coverageType_spatial_coordinates::posx), "xsd:float"))
				{	soap_flag_posx1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_spatial_coordinates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, 0, sizeof(_fimsdescription__coverageType_spatial_coordinates), 0, soap_copy__fimsdescription__coverageType_spatial_coordinates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_posy1 > 0 || soap_flag_posx1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_spatial_coordinates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-spatial-coordinates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_spatial_coordinates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_spatial_coordinates(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates * SOAP_FMAC4 soap_get__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_spatial_coordinates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_spatial_coordinates * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_spatial_coordinates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_spatial_coordinates);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_spatial_coordinates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_spatial_coordinates, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_spatial_coordinates);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_spatial_coordinates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_spatial_coordinates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_spatial_coordinates %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_spatial_coordinates*)p = *(_fimsdescription__coverageType_spatial_coordinates*)q;
}

void _fimsdescription__coverageType_spatial_locationName::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_spatial_locationName::typeLabel = NULL;
	this->_fimsdescription__coverageType_spatial_locationName::typeDefinition = NULL;
	this->_fimsdescription__coverageType_spatial_locationName::typeLink = NULL;
	this->_fimsdescription__coverageType_spatial_locationName::typeLanguage = NULL;
}

void _fimsdescription__coverageType_spatial_locationName::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__coverageType_spatial_locationName::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_spatial_locationName(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_spatial_locationName(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_spatial_locationName *a, const char *type)
{
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_spatial_locationName::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_spatial_locationName(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_locationName * SOAP_FMAC4 soap_in__fimsdescription__coverageType_spatial_locationName(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial_locationName *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_spatial_locationName *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName, sizeof(_fimsdescription__coverageType_spatial_locationName), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_spatial_locationName)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_spatial_locationName *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_spatial_locationName*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_spatial_locationName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName, 0, sizeof(_fimsdescription__coverageType_spatial_locationName), 0, soap_copy__fimsdescription__coverageType_spatial_locationName);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_spatial_locationName::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-spatial-locationName", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_spatial_locationName::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_spatial_locationName(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_locationName * SOAP_FMAC4 soap_get__fimsdescription__coverageType_spatial_locationName(struct soap *soap, _fimsdescription__coverageType_spatial_locationName *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_spatial_locationName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_spatial_locationName * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_spatial_locationName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_spatial_locationName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_spatial_locationName, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_spatial_locationName);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_spatial_locationName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_spatial_locationName, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_spatial_locationName);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_spatial_locationName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_spatial_locationName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_spatial_locationName %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_spatial_locationName*)p = *(_fimsdescription__coverageType_spatial_locationName*)q;
}

void _fimsdescription__coverageType_spatial::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_spatial::locationName._fimsdescription__coverageType_spatial_locationName::soap_default(soap);
	this->_fimsdescription__coverageType_spatial::coordinates = NULL;
}

void _fimsdescription__coverageType_spatial::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_spatial::locationName.soap_serialize(soap);
	soap_serialize_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, &this->_fimsdescription__coverageType_spatial::coordinates);
#endif
}

int _fimsdescription__coverageType_spatial::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_spatial(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_spatial *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_spatial), type))
		return soap->error;
	if ((a->_fimsdescription__coverageType_spatial::locationName).soap_out(soap, "fimsdescription:locationName", -1, ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, "fimsdescription:coordinates", -1, &(a->_fimsdescription__coverageType_spatial::coordinates), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_spatial::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_spatial(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial * SOAP_FMAC4 soap_in__fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_spatial *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_spatial, sizeof(_fimsdescription__coverageType_spatial), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_spatial)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_spatial *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_locationName1 = 1;
	size_t soap_flag_coordinates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locationName1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_fimsdescription__coverageType_spatial::locationName).soap_in(soap, "fimsdescription:locationName", ""))
				{	soap_flag_locationName1--;
					continue;
				}
			if (soap_flag_coordinates1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, "fimsdescription:coordinates", &(a->_fimsdescription__coverageType_spatial::coordinates), ""))
				{	soap_flag_coordinates1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_spatial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_spatial, 0, sizeof(_fimsdescription__coverageType_spatial), 0, soap_copy__fimsdescription__coverageType_spatial);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locationName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_spatial::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_spatial);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-spatial", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_spatial::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_spatial(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial * SOAP_FMAC4 soap_get__fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_spatial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_spatial * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_spatial(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_spatial(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_spatial, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_spatial);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_spatial);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_spatial, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_spatial);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_spatial*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_spatial(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_spatial %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_spatial*)p = *(_fimsdescription__coverageType_spatial*)q;
}

void _fimsdescription__coverageType_temporal::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__coverageType_temporal::typeLabel = NULL;
	this->_fimsdescription__coverageType_temporal::typeDefinition = NULL;
	this->_fimsdescription__coverageType_temporal::typeLink = NULL;
	this->_fimsdescription__coverageType_temporal::typeLanguage = NULL;
}

void _fimsdescription__coverageType_temporal::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__coverageType_temporal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__coverageType_temporal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, int id, const _fimsdescription__coverageType_temporal *a, const char *type)
{
	if (((_fimsdescription__coverageType_temporal*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__coverageType_temporal*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__coverageType_temporal*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__coverageType_temporal*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__coverageType_temporal*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__coverageType_temporal), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__coverageType_temporal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__coverageType_temporal(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal * SOAP_FMAC4 soap_in__fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, _fimsdescription__coverageType_temporal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__coverageType_temporal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__coverageType_temporal, sizeof(_fimsdescription__coverageType_temporal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__coverageType_temporal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__coverageType_temporal *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__coverageType_temporal*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__coverageType_temporal*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__coverageType_temporal*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__coverageType_temporal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__coverageType_temporal, 0, sizeof(_fimsdescription__coverageType_temporal), 0, soap_copy__fimsdescription__coverageType_temporal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__coverageType_temporal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__coverageType_temporal);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType-temporal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__coverageType_temporal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__coverageType_temporal(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal * SOAP_FMAC4 soap_get__fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__coverageType_temporal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__coverageType_temporal * SOAP_FMAC2 soap_instantiate__fimsdescription__coverageType_temporal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__coverageType_temporal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__coverageType_temporal, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__coverageType_temporal);
		if (size)
			*size = sizeof(_fimsdescription__coverageType_temporal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__coverageType_temporal, n);
		if (size)
			*size = n * sizeof(_fimsdescription__coverageType_temporal);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__coverageType_temporal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__coverageType_temporal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__coverageType_temporal %p -> %p\n", q, p));
	*(_fimsdescription__coverageType_temporal*)p = *(_fimsdescription__coverageType_temporal*)q;
}

void _fimsdescription__typeType_targetAudience::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__typeType_targetAudience::typeLabel = NULL;
	this->_fimsdescription__typeType_targetAudience::typeDefinition = NULL;
	this->_fimsdescription__typeType_targetAudience::typeLink = NULL;
	this->_fimsdescription__typeType_targetAudience::typeLanguage = NULL;
}

void _fimsdescription__typeType_targetAudience::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__typeType_targetAudience::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__typeType_targetAudience(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, int id, const _fimsdescription__typeType_targetAudience *a, const char *type)
{
	if (((_fimsdescription__typeType_targetAudience*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__typeType_targetAudience*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__typeType_targetAudience*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__typeType_targetAudience*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__typeType_targetAudience*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__typeType_targetAudience), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__typeType_targetAudience::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__typeType_targetAudience(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__typeType_targetAudience * SOAP_FMAC4 soap_in__fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, _fimsdescription__typeType_targetAudience *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__typeType_targetAudience *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__typeType_targetAudience, sizeof(_fimsdescription__typeType_targetAudience), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__typeType_targetAudience)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__typeType_targetAudience *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_targetAudience*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_targetAudience*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_targetAudience*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__typeType_targetAudience *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__typeType_targetAudience, 0, sizeof(_fimsdescription__typeType_targetAudience), 0, soap_copy__fimsdescription__typeType_targetAudience);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__typeType_targetAudience::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__typeType_targetAudience);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType-targetAudience", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__typeType_targetAudience::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__typeType_targetAudience(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__typeType_targetAudience * SOAP_FMAC4 soap_get__fimsdescription__typeType_targetAudience(struct soap *soap, _fimsdescription__typeType_targetAudience *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__typeType_targetAudience(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__typeType_targetAudience * SOAP_FMAC2 soap_instantiate__fimsdescription__typeType_targetAudience(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__typeType_targetAudience(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__typeType_targetAudience, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__typeType_targetAudience);
		if (size)
			*size = sizeof(_fimsdescription__typeType_targetAudience);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__typeType_targetAudience, n);
		if (size)
			*size = n * sizeof(_fimsdescription__typeType_targetAudience);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__typeType_targetAudience*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__typeType_targetAudience(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__typeType_targetAudience %p -> %p\n", q, p));
	*(_fimsdescription__typeType_targetAudience*)p = *(_fimsdescription__typeType_targetAudience*)q;
}

void _fimsdescription__typeType_objectType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__typeType_objectType::typeLabel = NULL;
	this->_fimsdescription__typeType_objectType::typeDefinition = NULL;
	this->_fimsdescription__typeType_objectType::typeLink = NULL;
	this->_fimsdescription__typeType_objectType::typeLanguage = NULL;
}

void _fimsdescription__typeType_objectType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__typeType_objectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__typeType_objectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__typeType_objectType(struct soap *soap, const char *tag, int id, const _fimsdescription__typeType_objectType *a, const char *type)
{
	if (((_fimsdescription__typeType_objectType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__typeType_objectType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__typeType_objectType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__typeType_objectType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__typeType_objectType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__typeType_objectType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__typeType_objectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__typeType_objectType(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__typeType_objectType * SOAP_FMAC4 soap_in__fimsdescription__typeType_objectType(struct soap *soap, const char *tag, _fimsdescription__typeType_objectType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__typeType_objectType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__typeType_objectType, sizeof(_fimsdescription__typeType_objectType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__typeType_objectType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__typeType_objectType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_objectType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_objectType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_objectType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__typeType_objectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__typeType_objectType, 0, sizeof(_fimsdescription__typeType_objectType), 0, soap_copy__fimsdescription__typeType_objectType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__typeType_objectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__typeType_objectType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType-objectType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__typeType_objectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__typeType_objectType(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__typeType_objectType * SOAP_FMAC4 soap_get__fimsdescription__typeType_objectType(struct soap *soap, _fimsdescription__typeType_objectType *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__typeType_objectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__typeType_objectType * SOAP_FMAC2 soap_instantiate__fimsdescription__typeType_objectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__typeType_objectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__typeType_objectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__typeType_objectType);
		if (size)
			*size = sizeof(_fimsdescription__typeType_objectType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__typeType_objectType, n);
		if (size)
			*size = n * sizeof(_fimsdescription__typeType_objectType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__typeType_objectType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__typeType_objectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__typeType_objectType %p -> %p\n", q, p));
	*(_fimsdescription__typeType_objectType*)p = *(_fimsdescription__typeType_objectType*)q;
}

void _fimsdescription__typeType_genre::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_fimsdescription__typeType_genre::typeLabel = NULL;
	this->_fimsdescription__typeType_genre::typeDefinition = NULL;
	this->_fimsdescription__typeType_genre::typeLink = NULL;
	this->_fimsdescription__typeType_genre::typeLanguage = NULL;
}

void _fimsdescription__typeType_genre::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
#endif
}

int _fimsdescription__typeType_genre::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fimsdescription__typeType_genre(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fimsdescription__typeType_genre(struct soap *soap, const char *tag, int id, const _fimsdescription__typeType_genre *a, const char *type)
{
	if (((_fimsdescription__typeType_genre*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeLabel->c_str()), 2);
	if (((_fimsdescription__typeType_genre*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeDefinition->c_str()), 2);
	if (((_fimsdescription__typeType_genre*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeLink->c_str()), 2);
	if (((_fimsdescription__typeType_genre*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((_fimsdescription__typeType_genre*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fimsdescription__typeType_genre), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_fimsdescription__typeType_genre::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fimsdescription__typeType_genre(soap, tag, this, type);
}

SOAP_FMAC3 _fimsdescription__typeType_genre * SOAP_FMAC4 soap_in__fimsdescription__typeType_genre(struct soap *soap, const char *tag, _fimsdescription__typeType_genre *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fimsdescription__typeType_genre *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fimsdescription__typeType_genre, sizeof(_fimsdescription__typeType_genre), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fimsdescription__typeType_genre)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fimsdescription__typeType_genre *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((_fimsdescription__typeType_genre*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((_fimsdescription__typeType_genre*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((_fimsdescription__typeType_genre*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fimsdescription__typeType_genre *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fimsdescription__typeType_genre, 0, sizeof(_fimsdescription__typeType_genre), 0, soap_copy__fimsdescription__typeType_genre);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fimsdescription__typeType_genre::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fimsdescription__typeType_genre);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType-genre", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fimsdescription__typeType_genre::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fimsdescription__typeType_genre(soap, this, tag, type);
}

SOAP_FMAC3 _fimsdescription__typeType_genre * SOAP_FMAC4 soap_get__fimsdescription__typeType_genre(struct soap *soap, _fimsdescription__typeType_genre *p, const char *tag, const char *type)
{
	if ((p = soap_in__fimsdescription__typeType_genre(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fimsdescription__typeType_genre * SOAP_FMAC2 soap_instantiate__fimsdescription__typeType_genre(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fimsdescription__typeType_genre(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fimsdescription__typeType_genre, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fimsdescription__typeType_genre);
		if (size)
			*size = sizeof(_fimsdescription__typeType_genre);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fimsdescription__typeType_genre, n);
		if (size)
			*size = n * sizeof(_fimsdescription__typeType_genre);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fimsdescription__typeType_genre*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fimsdescription__typeType_genre(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fimsdescription__typeType_genre %p -> %p\n", q, p));
	*(_fimsdescription__typeType_genre*)p = *(_fimsdescription__typeType_genre*)q;
}

void __fims__DataFormatsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__DataFormatsType_sequence::dataFormat = NULL;
}

void __fims__DataFormatsType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__DataFormatType(soap, &this->__fims__DataFormatsType_sequence::dataFormat);
#endif
}

int __fims__DataFormatsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__DataFormatsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__DataFormatsType_sequence(struct soap *soap, const char *tag, int id, const __fims__DataFormatsType_sequence *a, const char *type)
{
	if (a->__fims__DataFormatsType_sequence::dataFormat)
	{	if (soap_out_PointerTofims__DataFormatType(soap, "fims:dataFormat", -1, &a->__fims__DataFormatsType_sequence::dataFormat, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:dataFormat"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__DataFormatsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__DataFormatsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__DataFormatsType_sequence * SOAP_FMAC4 soap_in___fims__DataFormatsType_sequence(struct soap *soap, const char *tag, __fims__DataFormatsType_sequence *a, const char *type)
{
	a = (__fims__DataFormatsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__DataFormatsType_sequence, sizeof(__fims__DataFormatsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_dataFormat1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dataFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__DataFormatType(soap, "fims:dataFormat", &(a->__fims__DataFormatsType_sequence::dataFormat), "fims:DataFormatType"))
				{	soap_flag_dataFormat1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dataFormat1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__DataFormatsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:DataFormatsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__DataFormatsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__DataFormatsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__DataFormatsType_sequence * SOAP_FMAC4 soap_get___fims__DataFormatsType_sequence(struct soap *soap, __fims__DataFormatsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__DataFormatsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__DataFormatsType_sequence * SOAP_FMAC2 soap_instantiate___fims__DataFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__DataFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__DataFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__DataFormatsType_sequence);
		if (size)
			*size = sizeof(__fims__DataFormatsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__DataFormatsType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__DataFormatsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__DataFormatsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__DataFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__DataFormatsType_sequence %p -> %p\n", q, p));
	*(__fims__DataFormatsType_sequence*)p = *(__fims__DataFormatsType_sequence*)q;
}

void __fims__ContainerFormatsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__ContainerFormatsType_sequence::containerFormat = NULL;
}

void __fims__ContainerFormatsType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ContainerFormatType(soap, &this->__fims__ContainerFormatsType_sequence::containerFormat);
#endif
}

int __fims__ContainerFormatsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__ContainerFormatsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__ContainerFormatsType_sequence(struct soap *soap, const char *tag, int id, const __fims__ContainerFormatsType_sequence *a, const char *type)
{
	if (a->__fims__ContainerFormatsType_sequence::containerFormat)
	{	if (soap_out_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", -1, &a->__fims__ContainerFormatsType_sequence::containerFormat, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:containerFormat"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ContainerFormatsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__ContainerFormatsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__ContainerFormatsType_sequence * SOAP_FMAC4 soap_in___fims__ContainerFormatsType_sequence(struct soap *soap, const char *tag, __fims__ContainerFormatsType_sequence *a, const char *type)
{
	a = (__fims__ContainerFormatsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__ContainerFormatsType_sequence, sizeof(__fims__ContainerFormatsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_containerFormat1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_containerFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", &(a->__fims__ContainerFormatsType_sequence::containerFormat), "fims:ContainerFormatType"))
				{	soap_flag_containerFormat1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_containerFormat1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__ContainerFormatsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:ContainerFormatsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ContainerFormatsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__ContainerFormatsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__ContainerFormatsType_sequence * SOAP_FMAC4 soap_get___fims__ContainerFormatsType_sequence(struct soap *soap, __fims__ContainerFormatsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__ContainerFormatsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__ContainerFormatsType_sequence * SOAP_FMAC2 soap_instantiate___fims__ContainerFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__ContainerFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__ContainerFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__ContainerFormatsType_sequence);
		if (size)
			*size = sizeof(__fims__ContainerFormatsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__ContainerFormatsType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__ContainerFormatsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__ContainerFormatsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__ContainerFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__ContainerFormatsType_sequence %p -> %p\n", q, p));
	*(__fims__ContainerFormatsType_sequence*)p = *(__fims__ContainerFormatsType_sequence*)q;
}

void __fims__AudioFormatsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__AudioFormatsType_sequence::audioFormat = NULL;
}

void __fims__AudioFormatsType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__AudioFormatType(soap, &this->__fims__AudioFormatsType_sequence::audioFormat);
#endif
}

int __fims__AudioFormatsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__AudioFormatsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__AudioFormatsType_sequence(struct soap *soap, const char *tag, int id, const __fims__AudioFormatsType_sequence *a, const char *type)
{
	if (a->__fims__AudioFormatsType_sequence::audioFormat)
	{	if (soap_out_PointerTofims__AudioFormatType(soap, "fims:audioFormat", -1, &a->__fims__AudioFormatsType_sequence::audioFormat, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:audioFormat"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__AudioFormatsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__AudioFormatsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__AudioFormatsType_sequence * SOAP_FMAC4 soap_in___fims__AudioFormatsType_sequence(struct soap *soap, const char *tag, __fims__AudioFormatsType_sequence *a, const char *type)
{
	a = (__fims__AudioFormatsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__AudioFormatsType_sequence, sizeof(__fims__AudioFormatsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_audioFormat1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_audioFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AudioFormatType(soap, "fims:audioFormat", &(a->__fims__AudioFormatsType_sequence::audioFormat), "fims:AudioFormatType"))
				{	soap_flag_audioFormat1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_audioFormat1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__AudioFormatsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:AudioFormatsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__AudioFormatsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__AudioFormatsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__AudioFormatsType_sequence * SOAP_FMAC4 soap_get___fims__AudioFormatsType_sequence(struct soap *soap, __fims__AudioFormatsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__AudioFormatsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__AudioFormatsType_sequence * SOAP_FMAC2 soap_instantiate___fims__AudioFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__AudioFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__AudioFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__AudioFormatsType_sequence);
		if (size)
			*size = sizeof(__fims__AudioFormatsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__AudioFormatsType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__AudioFormatsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__AudioFormatsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__AudioFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__AudioFormatsType_sequence %p -> %p\n", q, p));
	*(__fims__AudioFormatsType_sequence*)p = *(__fims__AudioFormatsType_sequence*)q;
}

void __fims__VideoFormatsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__VideoFormatsType_sequence::videoFormat = NULL;
}

void __fims__VideoFormatsType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__VideoFormatType(soap, &this->__fims__VideoFormatsType_sequence::videoFormat);
#endif
}

int __fims__VideoFormatsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__VideoFormatsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__VideoFormatsType_sequence(struct soap *soap, const char *tag, int id, const __fims__VideoFormatsType_sequence *a, const char *type)
{
	if (a->__fims__VideoFormatsType_sequence::videoFormat)
	{	if (soap_out_PointerTofims__VideoFormatType(soap, "fims:videoFormat", -1, &a->__fims__VideoFormatsType_sequence::videoFormat, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:videoFormat"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__VideoFormatsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__VideoFormatsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__VideoFormatsType_sequence * SOAP_FMAC4 soap_in___fims__VideoFormatsType_sequence(struct soap *soap, const char *tag, __fims__VideoFormatsType_sequence *a, const char *type)
{
	a = (__fims__VideoFormatsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__VideoFormatsType_sequence, sizeof(__fims__VideoFormatsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_videoFormat1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_videoFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__VideoFormatType(soap, "fims:videoFormat", &(a->__fims__VideoFormatsType_sequence::videoFormat), "fims:VideoFormatType"))
				{	soap_flag_videoFormat1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_videoFormat1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__VideoFormatsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:VideoFormatsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__VideoFormatsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__VideoFormatsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__VideoFormatsType_sequence * SOAP_FMAC4 soap_get___fims__VideoFormatsType_sequence(struct soap *soap, __fims__VideoFormatsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__VideoFormatsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__VideoFormatsType_sequence * SOAP_FMAC2 soap_instantiate___fims__VideoFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__VideoFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__VideoFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__VideoFormatsType_sequence);
		if (size)
			*size = sizeof(__fims__VideoFormatsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__VideoFormatsType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__VideoFormatsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__VideoFormatsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__VideoFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__VideoFormatsType_sequence %p -> %p\n", q, p));
	*(__fims__VideoFormatsType_sequence*)p = *(__fims__VideoFormatsType_sequence*)q;
}

void __fims__JobsType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__JobsType_sequence::job = NULL;
}

void __fims__JobsType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__JobType(soap, &this->__fims__JobsType_sequence::job);
#endif
}

int __fims__JobsType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__JobsType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__JobsType_sequence(struct soap *soap, const char *tag, int id, const __fims__JobsType_sequence *a, const char *type)
{
	if (a->__fims__JobsType_sequence::job)
	{	if (soap_out_PointerTofims__JobType(soap, "fims:job", -1, &a->__fims__JobsType_sequence::job, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:job"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__JobsType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__JobsType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__JobsType_sequence * SOAP_FMAC4 soap_in___fims__JobsType_sequence(struct soap *soap, const char *tag, __fims__JobsType_sequence *a, const char *type)
{
	a = (__fims__JobsType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__JobsType_sequence, sizeof(__fims__JobsType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_job1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobType(soap, "fims:job", &(a->__fims__JobsType_sequence::job), "fims:JobType"))
				{	soap_flag_job1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_job1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__JobsType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:JobsType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__JobsType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__JobsType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__JobsType_sequence * SOAP_FMAC4 soap_get___fims__JobsType_sequence(struct soap *soap, __fims__JobsType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__JobsType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__JobsType_sequence * SOAP_FMAC2 soap_instantiate___fims__JobsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__JobsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__JobsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__JobsType_sequence);
		if (size)
			*size = sizeof(__fims__JobsType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__JobsType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__JobsType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__JobsType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__JobsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__JobsType_sequence %p -> %p\n", q, p));
	*(__fims__JobsType_sequence*)p = *(__fims__JobsType_sequence*)q;
}

void __fims__QueuesType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__QueuesType_sequence::queue = NULL;
}

void __fims__QueuesType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__QueueType(soap, &this->__fims__QueuesType_sequence::queue);
#endif
}

int __fims__QueuesType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__QueuesType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__QueuesType_sequence(struct soap *soap, const char *tag, int id, const __fims__QueuesType_sequence *a, const char *type)
{
	if (a->__fims__QueuesType_sequence::queue)
	{	if (soap_out_PointerTofims__QueueType(soap, "fims:queue", -1, &a->__fims__QueuesType_sequence::queue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:queue"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__QueuesType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__QueuesType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__QueuesType_sequence * SOAP_FMAC4 soap_in___fims__QueuesType_sequence(struct soap *soap, const char *tag, __fims__QueuesType_sequence *a, const char *type)
{
	a = (__fims__QueuesType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__QueuesType_sequence, sizeof(__fims__QueuesType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_queue1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueueType(soap, "fims:queue", &(a->__fims__QueuesType_sequence::queue), "fims:QueueType"))
				{	soap_flag_queue1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_queue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__QueuesType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:QueuesType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__QueuesType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__QueuesType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__QueuesType_sequence * SOAP_FMAC4 soap_get___fims__QueuesType_sequence(struct soap *soap, __fims__QueuesType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__QueuesType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__QueuesType_sequence * SOAP_FMAC2 soap_instantiate___fims__QueuesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__QueuesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__QueuesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__QueuesType_sequence);
		if (size)
			*size = sizeof(__fims__QueuesType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__QueuesType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__QueuesType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__QueuesType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__QueuesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__QueuesType_sequence %p -> %p\n", q, p));
	*(__fims__QueuesType_sequence*)p = *(__fims__QueuesType_sequence*)q;
}

void __fims__ServicesType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__ServicesType_sequence::service = NULL;
}

void __fims__ServicesType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ServiceType(soap, &this->__fims__ServicesType_sequence::service);
#endif
}

int __fims__ServicesType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__ServicesType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__ServicesType_sequence(struct soap *soap, const char *tag, int id, const __fims__ServicesType_sequence *a, const char *type)
{
	if (a->__fims__ServicesType_sequence::service)
	{	if (soap_out_PointerTofims__ServiceType(soap, "fims:service", -1, &a->__fims__ServicesType_sequence::service, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:service"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ServicesType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__ServicesType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__ServicesType_sequence * SOAP_FMAC4 soap_in___fims__ServicesType_sequence(struct soap *soap, const char *tag, __fims__ServicesType_sequence *a, const char *type)
{
	a = (__fims__ServicesType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__ServicesType_sequence, sizeof(__fims__ServicesType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_service1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_service1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ServiceType(soap, "fims:service", &(a->__fims__ServicesType_sequence::service), "fims:ServiceType"))
				{	soap_flag_service1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_service1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__ServicesType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:ServicesType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ServicesType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__ServicesType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__ServicesType_sequence * SOAP_FMAC4 soap_get___fims__ServicesType_sequence(struct soap *soap, __fims__ServicesType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__ServicesType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__ServicesType_sequence * SOAP_FMAC2 soap_instantiate___fims__ServicesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__ServicesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__ServicesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__ServicesType_sequence);
		if (size)
			*size = sizeof(__fims__ServicesType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__ServicesType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__ServicesType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__ServicesType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__ServicesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__ServicesType_sequence %p -> %p\n", q, p));
	*(__fims__ServicesType_sequence*)p = *(__fims__ServicesType_sequence*)q;
}

void __fims__ProfilesType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__ProfilesType_sequence::profile = NULL;
}

void __fims__ProfilesType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ProfileType(soap, &this->__fims__ProfilesType_sequence::profile);
#endif
}

int __fims__ProfilesType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__ProfilesType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__ProfilesType_sequence(struct soap *soap, const char *tag, int id, const __fims__ProfilesType_sequence *a, const char *type)
{
	if (a->__fims__ProfilesType_sequence::profile)
	{	if (soap_out_PointerTofims__ProfileType(soap, "fims:profile", -1, &a->__fims__ProfilesType_sequence::profile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:profile"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ProfilesType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__ProfilesType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__ProfilesType_sequence * SOAP_FMAC4 soap_in___fims__ProfilesType_sequence(struct soap *soap, const char *tag, __fims__ProfilesType_sequence *a, const char *type)
{
	a = (__fims__ProfilesType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__ProfilesType_sequence, sizeof(__fims__ProfilesType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_profile1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_profile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ProfileType(soap, "fims:profile", &(a->__fims__ProfilesType_sequence::profile), "fims:ProfileType"))
				{	soap_flag_profile1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_profile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__ProfilesType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:ProfilesType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ProfilesType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__ProfilesType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__ProfilesType_sequence * SOAP_FMAC4 soap_get___fims__ProfilesType_sequence(struct soap *soap, __fims__ProfilesType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__ProfilesType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__ProfilesType_sequence * SOAP_FMAC2 soap_instantiate___fims__ProfilesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__ProfilesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__ProfilesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__ProfilesType_sequence);
		if (size)
			*size = sizeof(__fims__ProfilesType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__ProfilesType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__ProfilesType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__ProfilesType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__ProfilesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__ProfilesType_sequence %p -> %p\n", q, p));
	*(__fims__ProfilesType_sequence*)p = *(__fims__ProfilesType_sequence*)q;
}

void __fims__ResourcesType_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__fims__ResourcesType_sequence::resource = NULL;
}

void __fims__ResourcesType_sequence::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ResourceType(soap, &this->__fims__ResourcesType_sequence::resource);
#endif
}

int __fims__ResourcesType_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___fims__ResourcesType_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___fims__ResourcesType_sequence(struct soap *soap, const char *tag, int id, const __fims__ResourcesType_sequence *a, const char *type)
{
	if (a->__fims__ResourcesType_sequence::resource)
	{	if (soap_out_PointerTofims__ResourceType(soap, "fims:resource", -1, &a->__fims__ResourcesType_sequence::resource, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:resource"))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ResourcesType_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___fims__ResourcesType_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __fims__ResourcesType_sequence * SOAP_FMAC4 soap_in___fims__ResourcesType_sequence(struct soap *soap, const char *tag, __fims__ResourcesType_sequence *a, const char *type)
{
	a = (__fims__ResourcesType_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___fims__ResourcesType_sequence, sizeof(__fims__ResourcesType_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
	}
	size_t soap_flag_resource1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resource1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ResourceType(soap, "fims:resource", &(a->__fims__ResourcesType_sequence::resource), "fims:ResourceType"))
				{	soap_flag_resource1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resource1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int __fims__ResourcesType_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-fims:ResourcesType-sequence", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__fims__ResourcesType_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___fims__ResourcesType_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __fims__ResourcesType_sequence * SOAP_FMAC4 soap_get___fims__ResourcesType_sequence(struct soap *soap, __fims__ResourcesType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___fims__ResourcesType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __fims__ResourcesType_sequence * SOAP_FMAC2 soap_instantiate___fims__ResourcesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___fims__ResourcesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___fims__ResourcesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__fims__ResourcesType_sequence);
		if (size)
			*size = sizeof(__fims__ResourcesType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(__fims__ResourcesType_sequence, n);
		if (size)
			*size = n * sizeof(__fims__ResourcesType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (__fims__ResourcesType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___fims__ResourcesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __fims__ResourcesType_sequence %p -> %p\n", q, p));
	*(__fims__ResourcesType_sequence*)p = *(__fims__ResourcesType_sequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__TimecodeDuration(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TimecodeDuration(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__TimecodeDuration), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__TimecodeDuration(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__TimecodeDuration, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__TimecodeDuration, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__TimecodeDuration, 0, sizeof(std::wstring), 0, soap_copy_fims__TimecodeDuration);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__TimecodeDuration(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__TimecodeDuration);
	if (soap_out_fims__TimecodeDuration(soap, tag?tag:"fims:TimecodeDuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__TimecodeDuration(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TimecodeDuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__Timecode(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__Timecode(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__Timecode), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__Timecode(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__Timecode, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__Timecode, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__Timecode, 0, sizeof(std::wstring), 0, soap_copy_fims__Timecode);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__Timecode(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__Timecode);
	if (soap_out_fims__Timecode(soap, tag?tag:"fims:Timecode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__Timecode(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__Timecode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__RevisionIDType(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__RevisionIDType(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__RevisionIDType), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__RevisionIDType(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__RevisionIDType, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__RevisionIDType, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__RevisionIDType, 0, sizeof(std::wstring), 0, soap_copy_fims__RevisionIDType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__RevisionIDType(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__RevisionIDType);
	if (soap_out_fims__RevisionIDType(soap, tag?tag:"fims:RevisionIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__RevisionIDType(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__RevisionIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__ResourceIDType(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourceIDType(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__ResourceIDType), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__ResourceIDType(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__ResourceIDType, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__ResourceIDType, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__ResourceIDType, 0, sizeof(std::wstring), 0, soap_copy_fims__ResourceIDType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__ResourceIDType(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__ResourceIDType);
	if (soap_out_fims__ResourceIDType(soap, tag?tag:"fims:ResourceIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__ResourceIDType(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourceIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__EmptyID(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EmptyID(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__EmptyID), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__EmptyID(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__EmptyID, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__EmptyID, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__EmptyID, 0, sizeof(std::wstring), 0, soap_copy_fims__EmptyID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__EmptyID(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__EmptyID);
	if (soap_out_fims__EmptyID(soap, tag?tag:"fims:EmptyID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__EmptyID(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EmptyID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__UL(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__UL(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__UL), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__UL(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UL, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UL, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__UL, 0, sizeof(std::wstring), 0, soap_copy_fims__UL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__UL(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__UL);
	if (soap_out_fims__UL(soap, tag?tag:"fims:UL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__UL(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__UL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__UMID(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__UMID(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__UMID), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__UMID(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UMID, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UMID, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__UMID, 0, sizeof(std::wstring), 0, soap_copy_fims__UMID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__UMID(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__UMID);
	if (soap_out_fims__UMID(soap, tag?tag:"fims:UMID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__UMID(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__UMID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__UUID(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__UUID(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__UUID), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__UUID(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UUID, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UUID, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__UUID, 0, sizeof(std::wstring), 0, soap_copy_fims__UUID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__UUID(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__UUID);
	if (soap_out_fims__UUID(soap, tag?tag:"fims:UUID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__UUID(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__UUID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fims__UID(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__UID(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_fims__UID), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_fims__UID(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UID, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_fims__UID, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_fims__UID, 0, sizeof(std::wstring), 0, soap_copy_fims__UID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fims__UID(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_fims__UID);
	if (soap_out_fims__UID(soap, tag?tag:"fims:UID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_fims__UID(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__UID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void fimsdescription__languageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__languageType::xml__lang = NULL;
	this->fimsdescription__languageType::typeLabel = NULL;
	this->fimsdescription__languageType::typeDefinition = NULL;
	this->fimsdescription__languageType::typeLink = NULL;
	this->fimsdescription__languageType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__languageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fimsdescription__languageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__languageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__languageType(struct soap *soap, const char *tag, int id, const fimsdescription__languageType *a, const char *type)
{
	if (((fimsdescription__languageType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->xml__lang->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__languageType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__languageType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__languageType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__languageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__languageType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__languageType * SOAP_FMAC4 soap_in_fimsdescription__languageType(struct soap *soap, const char *tag, fimsdescription__languageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__languageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__languageType, sizeof(fimsdescription__languageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__languageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__languageType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__languageType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__languageType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__languageType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__languageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__languageType, 0, sizeof(fimsdescription__languageType), 0, soap_copy_fimsdescription__languageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__languageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__languageType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:languageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__languageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__languageType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__languageType * SOAP_FMAC4 soap_get_fimsdescription__languageType(struct soap *soap, fimsdescription__languageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__languageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__languageType * SOAP_FMAC2 soap_instantiate_fimsdescription__languageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__languageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__languageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__languageType);
		if (size)
			*size = sizeof(fimsdescription__languageType);
		((fimsdescription__languageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__languageType, n);
		if (size)
			*size = n * sizeof(fimsdescription__languageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__languageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__languageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__languageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__languageType %p -> %p\n", q, p));
	*(fimsdescription__languageType*)p = *(fimsdescription__languageType*)q;
}

void fimsdescription__addressType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressLine);
	this->fimsdescription__addressType::addressTownCity = NULL;
	this->fimsdescription__addressType::addressCountyState = NULL;
	this->fimsdescription__addressType::addressDeliveryCode = NULL;
	this->fimsdescription__addressType::country = NULL;
	/* transient soap skipped */
}

void fimsdescription__addressType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressLine);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressTownCity);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__addressType::addressCountyState);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__addressType::addressDeliveryCode);
	soap_serialize_PointerTo_fimsdescription__addressType_country(soap, &this->fimsdescription__addressType::country);
	/* transient soap skipped */
#endif
}

int fimsdescription__addressType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__addressType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__addressType(struct soap *soap, const char *tag, int id, const fimsdescription__addressType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__addressType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:addressLine", -1, &(a->fimsdescription__addressType::addressLine), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressTownCity", -1, &(a->fimsdescription__addressType::addressTownCity), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressCountyState", -1, &(a->fimsdescription__addressType::addressCountyState), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:addressDeliveryCode", -1, &(a->fimsdescription__addressType::addressDeliveryCode), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__addressType_country(soap, "fimsdescription:country", -1, &(a->fimsdescription__addressType::country), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__addressType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__addressType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__addressType * SOAP_FMAC4 soap_in_fimsdescription__addressType(struct soap *soap, const char *tag, fimsdescription__addressType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__addressType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__addressType, sizeof(fimsdescription__addressType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__addressType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__addressType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_addressTownCity1 = 1;
	size_t soap_flag_addressCountyState1 = 1;
	size_t soap_flag_addressDeliveryCode1 = 1;
	size_t soap_flag_country1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:addressLine", &(a->fimsdescription__addressType::addressLine), "fimsdescription:textElementType"))
					continue;
			if (soap_flag_addressTownCity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressTownCity", &(a->fimsdescription__addressType::addressTownCity), "fimsdescription:textElementType"))
				{	soap_flag_addressTownCity1--;
					continue;
				}
			if (soap_flag_addressCountyState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:addressCountyState", &(a->fimsdescription__addressType::addressCountyState), "fimsdescription:textElementType"))
				{	soap_flag_addressCountyState1--;
					continue;
				}
			if (soap_flag_addressDeliveryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:addressDeliveryCode", &(a->fimsdescription__addressType::addressDeliveryCode), "xsd:string"))
				{	soap_flag_addressDeliveryCode1--;
					continue;
				}
			if (soap_flag_country1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__addressType_country(soap, "fimsdescription:country", &(a->fimsdescription__addressType::country), ""))
				{	soap_flag_country1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__addressType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__addressType, 0, sizeof(fimsdescription__addressType), 0, soap_copy_fimsdescription__addressType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__addressType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__addressType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:addressType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__addressType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__addressType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__addressType * SOAP_FMAC4 soap_get_fimsdescription__addressType(struct soap *soap, fimsdescription__addressType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__addressType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__addressType * SOAP_FMAC2 soap_instantiate_fimsdescription__addressType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__addressType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__addressType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__addressType);
		if (size)
			*size = sizeof(fimsdescription__addressType);
		((fimsdescription__addressType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__addressType, n);
		if (size)
			*size = n * sizeof(fimsdescription__addressType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__addressType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__addressType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__addressType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__addressType %p -> %p\n", q, p));
	*(fimsdescription__addressType*)p = *(fimsdescription__addressType*)q;
}

void fimsdescription__detailsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__detailsType::emailAddress);
	this->fimsdescription__detailsType::webAddress = NULL;
	this->fimsdescription__detailsType::address = NULL;
	this->fimsdescription__detailsType::telephoneNumber = NULL;
	this->fimsdescription__detailsType::mobileTelephoneNumber = NULL;
	this->fimsdescription__detailsType::typeLabel = NULL;
	this->fimsdescription__detailsType::typeDefinition = NULL;
	this->fimsdescription__detailsType::typeLink = NULL;
	this->fimsdescription__detailsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__detailsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__detailsType::emailAddress);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__detailsType::webAddress);
	soap_serialize_PointerTofimsdescription__addressType(soap, &this->fimsdescription__detailsType::address);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__detailsType::telephoneNumber);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__detailsType::mobileTelephoneNumber);
	/* transient soap skipped */
#endif
}

int fimsdescription__detailsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__detailsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__detailsType(struct soap *soap, const char *tag, int id, const fimsdescription__detailsType *a, const char *type)
{
	if (((fimsdescription__detailsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__detailsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__detailsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__detailsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__detailsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__detailsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:emailAddress", -1, &(a->fimsdescription__detailsType::emailAddress), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:webAddress", -1, &(a->fimsdescription__detailsType::webAddress), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__addressType(soap, "fimsdescription:address", -1, &(a->fimsdescription__detailsType::address), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:telephoneNumber", -1, &(a->fimsdescription__detailsType::telephoneNumber), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:mobileTelephoneNumber", -1, &(a->fimsdescription__detailsType::mobileTelephoneNumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__detailsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__detailsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__detailsType * SOAP_FMAC4 soap_in_fimsdescription__detailsType(struct soap *soap, const char *tag, fimsdescription__detailsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__detailsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__detailsType, sizeof(fimsdescription__detailsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__detailsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__detailsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__detailsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__detailsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__detailsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_webAddress1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_telephoneNumber1 = 1;
	size_t soap_flag_mobileTelephoneNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:emailAddress", &(a->fimsdescription__detailsType::emailAddress), "xsd:string"))
					continue;
			if (soap_flag_webAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:webAddress", &(a->fimsdescription__detailsType::webAddress), "xsd:string"))
				{	soap_flag_webAddress1--;
					continue;
				}
			if (soap_flag_address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__addressType(soap, "fimsdescription:address", &(a->fimsdescription__detailsType::address), "fimsdescription:addressType"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_telephoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:telephoneNumber", &(a->fimsdescription__detailsType::telephoneNumber), "xsd:string"))
				{	soap_flag_telephoneNumber1--;
					continue;
				}
			if (soap_flag_mobileTelephoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:mobileTelephoneNumber", &(a->fimsdescription__detailsType::mobileTelephoneNumber), "xsd:string"))
				{	soap_flag_mobileTelephoneNumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__detailsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__detailsType, 0, sizeof(fimsdescription__detailsType), 0, soap_copy_fimsdescription__detailsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__detailsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__detailsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:detailsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__detailsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__detailsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__detailsType * SOAP_FMAC4 soap_get_fimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__detailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__detailsType * SOAP_FMAC2 soap_instantiate_fimsdescription__detailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__detailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__detailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__detailsType);
		if (size)
			*size = sizeof(fimsdescription__detailsType);
		((fimsdescription__detailsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__detailsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__detailsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__detailsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__detailsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__detailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__detailsType %p -> %p\n", q, p));
	*(fimsdescription__detailsType*)p = *(fimsdescription__detailsType*)q;
}

void fimsdescription__organisationDetailsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__organisationDetailsType::organisationName);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->fimsdescription__organisationDetailsType::organisationCode);
	this->fimsdescription__organisationDetailsType::organisationDepartment = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__organisationDetailsType::details);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__organisationDetailsType::contacts);
	this->fimsdescription__organisationDetailsType::organisationId = NULL;
	this->fimsdescription__organisationDetailsType::typeLabel = NULL;
	this->fimsdescription__organisationDetailsType::typeDefinition = NULL;
	this->fimsdescription__organisationDetailsType::typeLink = NULL;
	this->fimsdescription__organisationDetailsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__organisationDetailsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__organisationDetailsType::organisationName);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->fimsdescription__organisationDetailsType::organisationCode);
	soap_serialize_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, &this->fimsdescription__organisationDetailsType::organisationDepartment);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__organisationDetailsType::details);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__organisationDetailsType::contacts);
	/* transient soap skipped */
#endif
}

int fimsdescription__organisationDetailsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__organisationDetailsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__organisationDetailsType(struct soap *soap, const char *tag, int id, const fimsdescription__organisationDetailsType *a, const char *type)
{
	if (((fimsdescription__organisationDetailsType*)a)->organisationId)
		soap_set_attr(soap, "organisationId", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->organisationId->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__organisationDetailsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__organisationDetailsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__organisationDetailsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:organisationName", -1, &(a->fimsdescription__organisationDetailsType::organisationName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "fimsdescription:organisationCode", -1, &(a->fimsdescription__organisationDetailsType::organisationCode), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, "fimsdescription:organisationDepartment", -1, &(a->fimsdescription__organisationDetailsType::organisationDepartment), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", -1, &(a->fimsdescription__organisationDetailsType::details), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contacts", -1, &(a->fimsdescription__organisationDetailsType::contacts), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__organisationDetailsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__organisationDetailsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType * SOAP_FMAC4 soap_in_fimsdescription__organisationDetailsType(struct soap *soap, const char *tag, fimsdescription__organisationDetailsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__organisationDetailsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__organisationDetailsType, sizeof(fimsdescription__organisationDetailsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__organisationDetailsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__organisationDetailsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "organisationId", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->organisationId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->organisationId = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->organisationId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__organisationDetailsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__organisationDetailsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__organisationDetailsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_organisationDepartment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:organisationName", &(a->fimsdescription__organisationDetailsType::organisationName), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "fimsdescription:organisationCode", &(a->fimsdescription__organisationDetailsType::organisationCode), "xsd:anyURI"))
					continue;
			if (soap_flag_organisationDepartment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, "fimsdescription:organisationDepartment", &(a->fimsdescription__organisationDetailsType::organisationDepartment), ""))
				{	soap_flag_organisationDepartment1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", &(a->fimsdescription__organisationDetailsType::details), "fimsdescription:detailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contacts", &(a->fimsdescription__organisationDetailsType::contacts), "fimsdescription:entityType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__organisationDetailsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__organisationDetailsType, 0, sizeof(fimsdescription__organisationDetailsType), 0, soap_copy_fimsdescription__organisationDetailsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__organisationDetailsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__organisationDetailsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:organisationDetailsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__organisationDetailsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__organisationDetailsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType * SOAP_FMAC4 soap_get_fimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__organisationDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__organisationDetailsType * SOAP_FMAC2 soap_instantiate_fimsdescription__organisationDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__organisationDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__organisationDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__organisationDetailsType);
		if (size)
			*size = sizeof(fimsdescription__organisationDetailsType);
		((fimsdescription__organisationDetailsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__organisationDetailsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__organisationDetailsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__organisationDetailsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__organisationDetailsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__organisationDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__organisationDetailsType %p -> %p\n", q, p));
	*(fimsdescription__organisationDetailsType*)p = *(fimsdescription__organisationDetailsType*)q;
}

void fimsdescription__contactDetailsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__contactDetailsType::name = NULL;
	this->fimsdescription__contactDetailsType::givenName = NULL;
	this->fimsdescription__contactDetailsType::familyName = NULL;
	soap_default_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__contactDetailsType::otherGivenName);
	this->fimsdescription__contactDetailsType::suffix = NULL;
	this->fimsdescription__contactDetailsType::salutation = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::username);
	this->fimsdescription__contactDetailsType::occupation = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__contactDetailsType::details);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::stageName);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__contactDetailsType::relatedContacts);
	this->fimsdescription__contactDetailsType::contactId = NULL;
	this->fimsdescription__contactDetailsType::typeLabel = NULL;
	this->fimsdescription__contactDetailsType::typeDefinition = NULL;
	this->fimsdescription__contactDetailsType::typeLink = NULL;
	this->fimsdescription__contactDetailsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__contactDetailsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::name);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::givenName);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::familyName);
	soap_serialize_std__vectorTemplateOfstd__wstring(soap, &this->fimsdescription__contactDetailsType::otherGivenName);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::suffix);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__contactDetailsType::salutation);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::username);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::occupation);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, &this->fimsdescription__contactDetailsType::details);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__contactDetailsType::stageName);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__contactDetailsType::relatedContacts);
	/* transient soap skipped */
#endif
}

int fimsdescription__contactDetailsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__contactDetailsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__contactDetailsType(struct soap *soap, const char *tag, int id, const fimsdescription__contactDetailsType *a, const char *type)
{
	if (((fimsdescription__contactDetailsType*)a)->contactId)
		soap_set_attr(soap, "contactId", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->contactId->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__contactDetailsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__contactDetailsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__contactDetailsType), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:name", -1, &(a->fimsdescription__contactDetailsType::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:givenName", -1, &(a->fimsdescription__contactDetailsType::givenName), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:familyName", -1, &(a->fimsdescription__contactDetailsType::familyName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:otherGivenName", -1, &(a->fimsdescription__contactDetailsType::otherGivenName), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:suffix", -1, &(a->fimsdescription__contactDetailsType::suffix), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:salutation", -1, &(a->fimsdescription__contactDetailsType::salutation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:username", -1, &(a->fimsdescription__contactDetailsType::username), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:occupation", -1, &(a->fimsdescription__contactDetailsType::occupation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", -1, &(a->fimsdescription__contactDetailsType::details), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:stageName", -1, &(a->fimsdescription__contactDetailsType::stageName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:relatedContacts", -1, &(a->fimsdescription__contactDetailsType::relatedContacts), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__contactDetailsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__contactDetailsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__contactDetailsType * SOAP_FMAC4 soap_in_fimsdescription__contactDetailsType(struct soap *soap, const char *tag, fimsdescription__contactDetailsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__contactDetailsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__contactDetailsType, sizeof(fimsdescription__contactDetailsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__contactDetailsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__contactDetailsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "contactId", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->contactId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->contactId = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->contactId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__contactDetailsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__contactDetailsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__contactDetailsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_givenName1 = 1;
	size_t soap_flag_familyName1 = 1;
	size_t soap_flag_suffix1 = 1;
	size_t soap_flag_salutation1 = 1;
	size_t soap_flag_occupation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:name", &(a->fimsdescription__contactDetailsType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_givenName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:givenName", &(a->fimsdescription__contactDetailsType::givenName), "xsd:string"))
				{	soap_flag_givenName1--;
					continue;
				}
			if (soap_flag_familyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:familyName", &(a->fimsdescription__contactDetailsType::familyName), "xsd:string"))
				{	soap_flag_familyName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__wstring(soap, "fimsdescription:otherGivenName", &(a->fimsdescription__contactDetailsType::otherGivenName), "xsd:string"))
					continue;
			if (soap_flag_suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:suffix", &(a->fimsdescription__contactDetailsType::suffix), "xsd:string"))
				{	soap_flag_suffix1--;
					continue;
				}
			if (soap_flag_salutation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:salutation", &(a->fimsdescription__contactDetailsType::salutation), "xsd:string"))
				{	soap_flag_salutation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:username", &(a->fimsdescription__contactDetailsType::username), "fimsdescription:textElementType"))
					continue;
			if (soap_flag_occupation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:occupation", &(a->fimsdescription__contactDetailsType::occupation), "fimsdescription:textElementType"))
				{	soap_flag_occupation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, "fimsdescription:details", &(a->fimsdescription__contactDetailsType::details), "fimsdescription:detailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:stageName", &(a->fimsdescription__contactDetailsType::stageName), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:relatedContacts", &(a->fimsdescription__contactDetailsType::relatedContacts), "fimsdescription:entityType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__contactDetailsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__contactDetailsType, 0, sizeof(fimsdescription__contactDetailsType), 0, soap_copy_fimsdescription__contactDetailsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__contactDetailsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__contactDetailsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:contactDetailsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__contactDetailsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__contactDetailsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__contactDetailsType * SOAP_FMAC4 soap_get_fimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__contactDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__contactDetailsType * SOAP_FMAC2 soap_instantiate_fimsdescription__contactDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__contactDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__contactDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__contactDetailsType);
		if (size)
			*size = sizeof(fimsdescription__contactDetailsType);
		((fimsdescription__contactDetailsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__contactDetailsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__contactDetailsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__contactDetailsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__contactDetailsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__contactDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__contactDetailsType %p -> %p\n", q, p));
	*(fimsdescription__contactDetailsType*)p = *(fimsdescription__contactDetailsType*)q;
}

void fimsdescription__entityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__entityType::contactDetails);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, &this->fimsdescription__entityType::organisationDetails);
	this->fimsdescription__entityType::role = NULL;
	this->fimsdescription__entityType::entityId = NULL;
	/* transient soap skipped */
}

void fimsdescription__entityType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__entityType::contactDetails);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, &this->fimsdescription__entityType::organisationDetails);
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, &this->fimsdescription__entityType::role);
	/* transient soap skipped */
#endif
}

int fimsdescription__entityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__entityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__entityType(struct soap *soap, const char *tag, int id, const fimsdescription__entityType *a, const char *type)
{
	if (((fimsdescription__entityType*)a)->entityId)
		soap_set_attr(soap, "entityId", soap_wchar2s(soap, ((fimsdescription__entityType*)a)->entityId->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__entityType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", -1, &(a->fimsdescription__entityType::contactDetails), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, "fimsdescription:organisationDetails", -1, &(a->fimsdescription__entityType::organisationDetails), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, "fimsdescription:role", -1, &(a->fimsdescription__entityType::role), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__entityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__entityType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__entityType * SOAP_FMAC4 soap_in_fimsdescription__entityType(struct soap *soap, const char *tag, fimsdescription__entityType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__entityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__entityType, sizeof(fimsdescription__entityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__entityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__entityType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "entityId", 0);
		if (t)
		{
			if (!(((fimsdescription__entityType*)a)->entityId = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__entityType*)a)->entityId = soap_new_std__wstring(soap, -1);
				((fimsdescription__entityType*)a)->entityId->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", &(a->fimsdescription__entityType::contactDetails), "fimsdescription:contactDetailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, "fimsdescription:organisationDetails", &(a->fimsdescription__entityType::organisationDetails), "fimsdescription:organisationDetailsType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, "fimsdescription:role", &(a->fimsdescription__entityType::role), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__entityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__entityType, 0, sizeof(fimsdescription__entityType), 0, soap_copy_fimsdescription__entityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__entityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__entityType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:entityType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__entityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__entityType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__entityType * SOAP_FMAC4 soap_get_fimsdescription__entityType(struct soap *soap, fimsdescription__entityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__entityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__entityType * SOAP_FMAC2 soap_instantiate_fimsdescription__entityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__entityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__entityType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__entityType);
		if (size)
			*size = sizeof(fimsdescription__entityType);
		((fimsdescription__entityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__entityType, n);
		if (size)
			*size = n * sizeof(fimsdescription__entityType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__entityType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__entityType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__entityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__entityType %p -> %p\n", q, p));
	*(fimsdescription__entityType*)p = *(fimsdescription__entityType*)q;
}

void fimsdescription__dateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__dateType::created = NULL;
	this->fimsdescription__dateType::modified = NULL;
	this->fimsdescription__dateType::issued = NULL;
	this->fimsdescription__dateType::alternative = NULL;
	/* transient soap skipped */
}

void fimsdescription__dateType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_fimsdescription__dateType_created(soap, &this->fimsdescription__dateType::created);
	soap_serialize_PointerTo_fimsdescription__dateType_modified(soap, &this->fimsdescription__dateType::modified);
	soap_serialize_PointerTo_fimsdescription__dateType_issued(soap, &this->fimsdescription__dateType::issued);
	soap_serialize_PointerTo_fimsdescription__dateType_alternative(soap, &this->fimsdescription__dateType::alternative);
	/* transient soap skipped */
#endif
}

int fimsdescription__dateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__dateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__dateType(struct soap *soap, const char *tag, int id, const fimsdescription__dateType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__dateType), type))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_created(soap, "fimsdescription:created", -1, &(a->fimsdescription__dateType::created), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_modified(soap, "fimsdescription:modified", -1, &(a->fimsdescription__dateType::modified), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_issued(soap, "fimsdescription:issued", -1, &(a->fimsdescription__dateType::issued), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__dateType_alternative(soap, "fimsdescription:alternative", -1, &(a->fimsdescription__dateType::alternative), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__dateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__dateType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__dateType * SOAP_FMAC4 soap_in_fimsdescription__dateType(struct soap *soap, const char *tag, fimsdescription__dateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__dateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__dateType, sizeof(fimsdescription__dateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__dateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__dateType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_created1 = 1;
	size_t soap_flag_modified1 = 1;
	size_t soap_flag_issued1 = 1;
	size_t soap_flag_alternative1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_created1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_created(soap, "fimsdescription:created", &(a->fimsdescription__dateType::created), ""))
				{	soap_flag_created1--;
					continue;
				}
			if (soap_flag_modified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_modified(soap, "fimsdescription:modified", &(a->fimsdescription__dateType::modified), ""))
				{	soap_flag_modified1--;
					continue;
				}
			if (soap_flag_issued1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_issued(soap, "fimsdescription:issued", &(a->fimsdescription__dateType::issued), ""))
				{	soap_flag_issued1--;
					continue;
				}
			if (soap_flag_alternative1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__dateType_alternative(soap, "fimsdescription:alternative", &(a->fimsdescription__dateType::alternative), ""))
				{	soap_flag_alternative1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__dateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__dateType, 0, sizeof(fimsdescription__dateType), 0, soap_copy_fimsdescription__dateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__dateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__dateType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:dateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__dateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__dateType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__dateType * SOAP_FMAC4 soap_get_fimsdescription__dateType(struct soap *soap, fimsdescription__dateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__dateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__dateType * SOAP_FMAC2 soap_instantiate_fimsdescription__dateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__dateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__dateType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__dateType);
		if (size)
			*size = sizeof(fimsdescription__dateType);
		((fimsdescription__dateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__dateType, n);
		if (size)
			*size = n * sizeof(fimsdescription__dateType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__dateType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__dateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__dateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__dateType %p -> %p\n", q, p));
	*(fimsdescription__dateType*)p = *(fimsdescription__dateType*)q;
}

void fimsdescription__textElementType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fimsdescription__textElementType::__item);
	this->fimsdescription__textElementType::xml__lang = NULL;
	/* transient soap skipped */
}

void fimsdescription__textElementType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fimsdescription__textElementType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fimsdescription__textElementType::__item);
	/* transient soap skipped */
#endif
}

int fimsdescription__textElementType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__textElementType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__textElementType(struct soap *soap, const char *tag, int id, const fimsdescription__textElementType *a, const char *type)
{
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->fimsdescription__textElementType::__item, "");
}

void *fimsdescription__textElementType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__textElementType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__textElementType * SOAP_FMAC4 soap_in_fimsdescription__textElementType(struct soap *soap, const char *tag, fimsdescription__textElementType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__textElementType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__textElementType, sizeof(fimsdescription__textElementType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__textElementType)
			return (fimsdescription__textElementType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:textElementType"))
		return NULL;
	return a;
}

int fimsdescription__textElementType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__textElementType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:textElementType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__textElementType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__textElementType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__textElementType * SOAP_FMAC4 soap_get_fimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__textElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__textElementType * SOAP_FMAC2 soap_instantiate_fimsdescription__textElementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__textElementType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__textElementType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fimsdescription:titleType"))
	{	cp->type = SOAP_TYPE_fimsdescription__titleType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fimsdescription__titleType);
			if (size)
				*size = sizeof(fimsdescription__titleType);
			((fimsdescription__titleType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__titleType, n);
			if (size)
				*size = n * sizeof(fimsdescription__titleType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fimsdescription__titleType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fimsdescription__titleType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fimsdescription:subjectType"))
	{	cp->type = SOAP_TYPE_fimsdescription__subjectType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fimsdescription__subjectType);
			if (size)
				*size = sizeof(fimsdescription__subjectType);
			((fimsdescription__subjectType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__subjectType, n);
			if (size)
				*size = n * sizeof(fimsdescription__subjectType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fimsdescription__subjectType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fimsdescription__subjectType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fimsdescription:descriptionType"))
	{	cp->type = SOAP_TYPE_fimsdescription__descriptionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fimsdescription__descriptionType);
			if (size)
				*size = sizeof(fimsdescription__descriptionType);
			((fimsdescription__descriptionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__descriptionType, n);
			if (size)
				*size = n * sizeof(fimsdescription__descriptionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fimsdescription__descriptionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fimsdescription__descriptionType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__textElementType);
		if (size)
			*size = sizeof(fimsdescription__textElementType);
		((fimsdescription__textElementType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__textElementType, n);
		if (size)
			*size = n * sizeof(fimsdescription__textElementType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__textElementType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__textElementType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__textElementType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__textElementType %p -> %p\n", q, p));
	*(fimsdescription__textElementType*)p = *(fimsdescription__textElementType*)q;
}

void fimsdescription__rightsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::rightsExpression);
	this->fimsdescription__rightsType::rightsLink = NULL;
	this->fimsdescription__rightsType::rightsHolder = NULL;
	this->fimsdescription__rightsType::exploitationIssues = NULL;
	this->fimsdescription__rightsType::coverage = NULL;
	this->fimsdescription__rightsType::rightsClearanceFlag = NULL;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::disclaimer);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__rightsType::rightsId);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__rightsType::contactDetails);
	this->fimsdescription__rightsType::typeLabel = NULL;
	this->fimsdescription__rightsType::typeDefinition = NULL;
	this->fimsdescription__rightsType::typeLink = NULL;
	this->fimsdescription__rightsType::typeLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__rightsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::rightsExpression);
	soap_serialize_PointerToxsd__anyURI(soap, &this->fimsdescription__rightsType::rightsLink);
	soap_serialize_PointerTofimsdescription__entityType(soap, &this->fimsdescription__rightsType::rightsHolder);
	soap_serialize_PointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::exploitationIssues);
	soap_serialize_PointerTofimsdescription__coverageType(soap, &this->fimsdescription__rightsType::coverage);
	soap_serialize_PointerTobool(soap, &this->fimsdescription__rightsType::rightsClearanceFlag);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__rightsType::disclaimer);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__rightsType::rightsId);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, &this->fimsdescription__rightsType::contactDetails);
	/* transient soap skipped */
#endif
}

int fimsdescription__rightsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__rightsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__rightsType(struct soap *soap, const char *tag, int id, const fimsdescription__rightsType *a, const char *type)
{
	if (((fimsdescription__rightsType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__rightsType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__rightsType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__rightsType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__rightsType*)a)->typeLanguage->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__rightsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:rightsExpression", -1, &(a->fimsdescription__rightsType::rightsExpression), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fimsdescription:rightsLink", -1, &(a->fimsdescription__rightsType::rightsLink), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__entityType(soap, "fimsdescription:rightsHolder", -1, &(a->fimsdescription__rightsType::rightsHolder), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__textElementType(soap, "fimsdescription:exploitationIssues", -1, &(a->fimsdescription__rightsType::exploitationIssues), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", -1, &(a->fimsdescription__rightsType::coverage), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fimsdescription:rightsClearanceFlag", -1, &(a->fimsdescription__rightsType::rightsClearanceFlag), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:disclaimer", -1, &(a->fimsdescription__rightsType::disclaimer), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:rightsId", -1, &(a->fimsdescription__rightsType::rightsId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", -1, &(a->fimsdescription__rightsType::contactDetails), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__rightsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__rightsType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__rightsType * SOAP_FMAC4 soap_in_fimsdescription__rightsType(struct soap *soap, const char *tag, fimsdescription__rightsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__rightsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__rightsType, sizeof(fimsdescription__rightsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__rightsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__rightsType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__rightsType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__rightsType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__rightsType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_rightsLink1 = 1;
	size_t soap_flag_rightsHolder1 = 1;
	size_t soap_flag_exploitationIssues1 = 1;
	size_t soap_flag_coverage1 = 1;
	size_t soap_flag_rightsClearanceFlag1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:rightsExpression", &(a->fimsdescription__rightsType::rightsExpression), "fimsdescription:textElementType"))
					continue;
			if (soap_flag_rightsLink1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fimsdescription:rightsLink", &(a->fimsdescription__rightsType::rightsLink), "xsd:anyURI"))
				{	soap_flag_rightsLink1--;
					continue;
				}
			if (soap_flag_rightsHolder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__entityType(soap, "fimsdescription:rightsHolder", &(a->fimsdescription__rightsType::rightsHolder), "fimsdescription:entityType"))
				{	soap_flag_rightsHolder1--;
					continue;
				}
			if (soap_flag_exploitationIssues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__textElementType(soap, "fimsdescription:exploitationIssues", &(a->fimsdescription__rightsType::exploitationIssues), "fimsdescription:textElementType"))
				{	soap_flag_exploitationIssues1--;
					continue;
				}
			if (soap_flag_coverage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", &(a->fimsdescription__rightsType::coverage), "fimsdescription:coverageType"))
				{	soap_flag_coverage1--;
					continue;
				}
			if (soap_flag_rightsClearanceFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fimsdescription:rightsClearanceFlag", &(a->fimsdescription__rightsType::rightsClearanceFlag), "xsd:boolean"))
				{	soap_flag_rightsClearanceFlag1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:disclaimer", &(a->fimsdescription__rightsType::disclaimer), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:rightsId", &(a->fimsdescription__rightsType::rightsId), "fimsdescription:identifierType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, "fimsdescription:contactDetails", &(a->fimsdescription__rightsType::contactDetails), "fimsdescription:contactDetailsType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__rightsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__rightsType, 0, sizeof(fimsdescription__rightsType), 0, soap_copy_fimsdescription__rightsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__rightsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__rightsType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:rightsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__rightsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__rightsType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__rightsType * SOAP_FMAC4 soap_get_fimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__rightsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__rightsType * SOAP_FMAC2 soap_instantiate_fimsdescription__rightsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__rightsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__rightsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__rightsType);
		if (size)
			*size = sizeof(fimsdescription__rightsType);
		((fimsdescription__rightsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__rightsType, n);
		if (size)
			*size = n * sizeof(fimsdescription__rightsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__rightsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__rightsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__rightsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__rightsType %p -> %p\n", q, p));
	*(fimsdescription__rightsType*)p = *(fimsdescription__rightsType*)q;
}

void fimsdescription__coverageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__coverageType::temporal = NULL;
	this->fimsdescription__coverageType::spatial = NULL;
	/* transient soap skipped */
}

void fimsdescription__coverageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_fimsdescription__coverageType_temporal(soap, &this->fimsdescription__coverageType::temporal);
	soap_serialize_PointerTo_fimsdescription__coverageType_spatial(soap, &this->fimsdescription__coverageType::spatial);
	/* transient soap skipped */
#endif
}

int fimsdescription__coverageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__coverageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__coverageType(struct soap *soap, const char *tag, int id, const fimsdescription__coverageType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__coverageType), type))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__coverageType_temporal(soap, "fimsdescription:temporal", -1, &(a->fimsdescription__coverageType::temporal), ""))
		return soap->error;
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial(soap, "fimsdescription:spatial", -1, &(a->fimsdescription__coverageType::spatial), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__coverageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__coverageType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__coverageType * SOAP_FMAC4 soap_in_fimsdescription__coverageType(struct soap *soap, const char *tag, fimsdescription__coverageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__coverageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__coverageType, sizeof(fimsdescription__coverageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__coverageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__coverageType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_temporal1 = 1;
	size_t soap_flag_spatial1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_temporal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__coverageType_temporal(soap, "fimsdescription:temporal", &(a->fimsdescription__coverageType::temporal), ""))
				{	soap_flag_temporal1--;
					continue;
				}
			if (soap_flag_spatial1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fimsdescription__coverageType_spatial(soap, "fimsdescription:spatial", &(a->fimsdescription__coverageType::spatial), ""))
				{	soap_flag_spatial1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__coverageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__coverageType, 0, sizeof(fimsdescription__coverageType), 0, soap_copy_fimsdescription__coverageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__coverageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__coverageType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:coverageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__coverageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__coverageType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__coverageType * SOAP_FMAC4 soap_get_fimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__coverageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__coverageType * SOAP_FMAC2 soap_instantiate_fimsdescription__coverageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__coverageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__coverageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__coverageType);
		if (size)
			*size = sizeof(fimsdescription__coverageType);
		((fimsdescription__coverageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__coverageType, n);
		if (size)
			*size = n * sizeof(fimsdescription__coverageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__coverageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__coverageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__coverageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__coverageType %p -> %p\n", q, p));
	*(fimsdescription__coverageType*)p = *(fimsdescription__coverageType*)q;
}

void fimsdescription__descriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__textElementType::soap_default(soap);
	this->fimsdescription__descriptionType::typeLabel = NULL;
	this->fimsdescription__descriptionType::typeDefinition = NULL;
	this->fimsdescription__descriptionType::typeLink = NULL;
	this->fimsdescription__descriptionType::typeLanguage = NULL;
}

void fimsdescription__descriptionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fimsdescription__textElementType::soap_serialize(soap);
#endif
}

int fimsdescription__descriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__descriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__descriptionType(struct soap *soap, const char *tag, int id, const fimsdescription__descriptionType *a, const char *type)
{
	if (((fimsdescription__descriptionType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__descriptionType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__descriptionType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__descriptionType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__descriptionType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &(a->fimsdescription__textElementType::__item), "fimsdescription:descriptionType");
}

void *fimsdescription__descriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__descriptionType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__descriptionType * SOAP_FMAC4 soap_in_fimsdescription__descriptionType(struct soap *soap, const char *tag, fimsdescription__descriptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__descriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__descriptionType)
			return (fimsdescription__descriptionType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__descriptionType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__descriptionType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__descriptionType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:descriptionType"))
		return NULL;
	return a;
}

int fimsdescription__descriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__descriptionType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:descriptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__descriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__descriptionType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__descriptionType * SOAP_FMAC4 soap_get_fimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__descriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__descriptionType * SOAP_FMAC2 soap_instantiate_fimsdescription__descriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__descriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__descriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__descriptionType);
		if (size)
			*size = sizeof(fimsdescription__descriptionType);
		((fimsdescription__descriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__descriptionType, n);
		if (size)
			*size = n * sizeof(fimsdescription__descriptionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__descriptionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__descriptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__descriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__descriptionType %p -> %p\n", q, p));
	*(fimsdescription__descriptionType*)p = *(fimsdescription__descriptionType*)q;
}

void fimsdescription__typeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__typeType::genre = NULL;
	this->fimsdescription__typeType::objectType = NULL;
	this->fimsdescription__typeType::targetAudience = NULL;
	/* transient soap skipped */
}

void fimsdescription__typeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, &this->fimsdescription__typeType::genre);
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, &this->fimsdescription__typeType::objectType);
	soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, &this->fimsdescription__typeType::targetAudience);
	/* transient soap skipped */
#endif
}

int fimsdescription__typeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__typeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__typeType(struct soap *soap, const char *tag, int id, const fimsdescription__typeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__typeType), type))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, "fimsdescription:genre", -1, &(a->fimsdescription__typeType::genre), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, "fimsdescription:objectType", -1, &(a->fimsdescription__typeType::objectType), ""))
		return soap->error;
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, "fimsdescription:targetAudience", -1, &(a->fimsdescription__typeType::targetAudience), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__typeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__typeType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__typeType * SOAP_FMAC4 soap_in_fimsdescription__typeType(struct soap *soap, const char *tag, fimsdescription__typeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__typeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__typeType, sizeof(fimsdescription__typeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__typeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__typeType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, "fimsdescription:genre", &(a->fimsdescription__typeType::genre), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, "fimsdescription:objectType", &(a->fimsdescription__typeType::objectType), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, "fimsdescription:targetAudience", &(a->fimsdescription__typeType::targetAudience), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__typeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__typeType, 0, sizeof(fimsdescription__typeType), 0, soap_copy_fimsdescription__typeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__typeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__typeType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:typeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__typeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__typeType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__typeType * SOAP_FMAC4 soap_get_fimsdescription__typeType(struct soap *soap, fimsdescription__typeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__typeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__typeType * SOAP_FMAC2 soap_instantiate_fimsdescription__typeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__typeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__typeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__typeType);
		if (size)
			*size = sizeof(fimsdescription__typeType);
		((fimsdescription__typeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__typeType, n);
		if (size)
			*size = n * sizeof(fimsdescription__typeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__typeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__typeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__typeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__typeType %p -> %p\n", q, p));
	*(fimsdescription__typeType*)p = *(fimsdescription__typeType*)q;
}

void fimsdescription__subjectType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__textElementType::soap_default(soap);
	this->fimsdescription__subjectType::typeLabel = NULL;
	this->fimsdescription__subjectType::typeDefinition = NULL;
	this->fimsdescription__subjectType::typeLink = NULL;
	this->fimsdescription__subjectType::typeLanguage = NULL;
}

void fimsdescription__subjectType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fimsdescription__textElementType::soap_serialize(soap);
#endif
}

int fimsdescription__subjectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__subjectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__subjectType(struct soap *soap, const char *tag, int id, const fimsdescription__subjectType *a, const char *type)
{
	if (((fimsdescription__subjectType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__subjectType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__subjectType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__subjectType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__subjectType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &(a->fimsdescription__textElementType::__item), "fimsdescription:subjectType");
}

void *fimsdescription__subjectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__subjectType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__subjectType * SOAP_FMAC4 soap_in_fimsdescription__subjectType(struct soap *soap, const char *tag, fimsdescription__subjectType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__subjectType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__subjectType, sizeof(fimsdescription__subjectType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__subjectType)
			return (fimsdescription__subjectType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__subjectType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__subjectType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__subjectType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:subjectType"))
		return NULL;
	return a;
}

int fimsdescription__subjectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__subjectType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:subjectType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__subjectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__subjectType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__subjectType * SOAP_FMAC4 soap_get_fimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__subjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__subjectType * SOAP_FMAC2 soap_instantiate_fimsdescription__subjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__subjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__subjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__subjectType);
		if (size)
			*size = sizeof(fimsdescription__subjectType);
		((fimsdescription__subjectType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__subjectType, n);
		if (size)
			*size = n * sizeof(fimsdescription__subjectType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__subjectType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__subjectType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__subjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__subjectType %p -> %p\n", q, p));
	*(fimsdescription__subjectType*)p = *(fimsdescription__subjectType*)q;
}

void fimsdescription__identifierType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fimsdescription__identifierType::__item);
	this->fimsdescription__identifierType::typeLabel = NULL;
	this->fimsdescription__identifierType::typeDefinition = NULL;
	this->fimsdescription__identifierType::typeLink = NULL;
	this->fimsdescription__identifierType::typeLanguage = NULL;
	this->fimsdescription__identifierType::formatLabel = NULL;
	this->fimsdescription__identifierType::formatDefinition = NULL;
	this->fimsdescription__identifierType::formatLink = NULL;
	this->fimsdescription__identifierType::formatLanguage = NULL;
	/* transient soap skipped */
}

void fimsdescription__identifierType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fimsdescription__identifierType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fimsdescription__identifierType::__item);
	/* transient soap skipped */
#endif
}

int fimsdescription__identifierType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__identifierType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__identifierType(struct soap *soap, const char *tag, int id, const fimsdescription__identifierType *a, const char *type)
{
	if (((fimsdescription__identifierType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatLabel->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatDefinition->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatLink->c_str()), 2);
	if (((fimsdescription__identifierType*)a)->formatLanguage)
		soap_set_attr(soap, "formatLanguage", soap_wchar2s(soap, ((fimsdescription__identifierType*)a)->formatLanguage->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->fimsdescription__identifierType::__item, "");
}

void *fimsdescription__identifierType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__identifierType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__identifierType * SOAP_FMAC4 soap_in_fimsdescription__identifierType(struct soap *soap, const char *tag, fimsdescription__identifierType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__identifierType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__identifierType, sizeof(fimsdescription__identifierType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__identifierType)
			return (fimsdescription__identifierType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__identifierType*)a)->formatLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__identifierType*)a)->formatLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__identifierType*)a)->formatLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__identifierType::__item), "fimsdescription:identifierType"))
		return NULL;
	return a;
}

int fimsdescription__identifierType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__identifierType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:identifierType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__identifierType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__identifierType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__identifierType * SOAP_FMAC4 soap_get_fimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__identifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__identifierType * SOAP_FMAC2 soap_instantiate_fimsdescription__identifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__identifierType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__identifierType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__identifierType);
		if (size)
			*size = sizeof(fimsdescription__identifierType);
		((fimsdescription__identifierType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__identifierType, n);
		if (size)
			*size = n * sizeof(fimsdescription__identifierType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__identifierType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__identifierType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__identifierType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__identifierType %p -> %p\n", q, p));
	*(fimsdescription__identifierType*)p = *(fimsdescription__identifierType*)q;
}

void fimsdescription__titleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fimsdescription__textElementType::soap_default(soap);
	this->fimsdescription__titleType::typeLabel = NULL;
	this->fimsdescription__titleType::typeDefinition = NULL;
	this->fimsdescription__titleType::typeLink = NULL;
	this->fimsdescription__titleType::typeLanguage = NULL;
}

void fimsdescription__titleType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fimsdescription__textElementType::soap_serialize(soap);
#endif
}

int fimsdescription__titleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__titleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__titleType(struct soap *soap, const char *tag, int id, const fimsdescription__titleType *a, const char *type)
{
	if (((fimsdescription__titleType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeLabel->c_str()), 2);
	if (((fimsdescription__titleType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeDefinition->c_str()), 2);
	if (((fimsdescription__titleType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeLink->c_str()), 2);
	if (((fimsdescription__titleType*)a)->typeLanguage)
		soap_set_attr(soap, "typeLanguage", soap_wchar2s(soap, ((fimsdescription__titleType*)a)->typeLanguage->c_str()), 2);
	if (((fimsdescription__textElementType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__textElementType*)a)->xml__lang->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &(a->fimsdescription__textElementType::__item), "fimsdescription:titleType");
}

void *fimsdescription__titleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__titleType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__titleType * SOAP_FMAC4 soap_in_fimsdescription__titleType(struct soap *soap, const char *tag, fimsdescription__titleType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fimsdescription__titleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__titleType, sizeof(fimsdescription__titleType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__titleType)
			return (fimsdescription__titleType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLanguage", 0);
		if (t)
		{
			if (!(((fimsdescription__titleType*)a)->typeLanguage = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__titleType*)a)->typeLanguage = soap_new_std__wstring(soap, -1);
				((fimsdescription__titleType*)a)->typeLanguage->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__textElementType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__textElementType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__textElementType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fimsdescription__textElementType::__item), "fimsdescription:titleType"))
		return NULL;
	return a;
}

int fimsdescription__titleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__titleType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:titleType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__titleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__titleType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__titleType * SOAP_FMAC4 soap_get_fimsdescription__titleType(struct soap *soap, fimsdescription__titleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__titleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__titleType * SOAP_FMAC2 soap_instantiate_fimsdescription__titleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__titleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__titleType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__titleType);
		if (size)
			*size = sizeof(fimsdescription__titleType);
		((fimsdescription__titleType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__titleType, n);
		if (size)
			*size = n * sizeof(fimsdescription__titleType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__titleType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__titleType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__titleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__titleType %p -> %p\n", q, p));
	*(fimsdescription__titleType*)p = *(fimsdescription__titleType*)q;
}

void fimsdescription__bmContentDescriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__bmContentDescriptionType::title);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, &this->fimsdescription__bmContentDescriptionType::alternativeTitle);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::creator);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, &this->fimsdescription__bmContentDescriptionType::subject);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, &this->fimsdescription__bmContentDescriptionType::description);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::publisher);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::contributor);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, &this->fimsdescription__bmContentDescriptionType::date);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, &this->fimsdescription__bmContentDescriptionType::type);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__bmContentDescriptionType::identifier);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, &this->fimsdescription__bmContentDescriptionType::language);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, &this->fimsdescription__bmContentDescriptionType::coverage);
	soap_default_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, &this->fimsdescription__bmContentDescriptionType::rights);
	this->fimsdescription__bmContentDescriptionType::version = NULL;
	this->fimsdescription__bmContentDescriptionType::xml__lang = NULL;
	/* transient soap skipped */
}

void fimsdescription__bmContentDescriptionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, &this->fimsdescription__bmContentDescriptionType::title);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, &this->fimsdescription__bmContentDescriptionType::alternativeTitle);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::creator);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, &this->fimsdescription__bmContentDescriptionType::subject);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, &this->fimsdescription__bmContentDescriptionType::description);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::publisher);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, &this->fimsdescription__bmContentDescriptionType::contributor);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, &this->fimsdescription__bmContentDescriptionType::date);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, &this->fimsdescription__bmContentDescriptionType::type);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, &this->fimsdescription__bmContentDescriptionType::identifier);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, &this->fimsdescription__bmContentDescriptionType::language);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, &this->fimsdescription__bmContentDescriptionType::coverage);
	soap_serialize_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, &this->fimsdescription__bmContentDescriptionType::rights);
	soap_serialize_PointerTostd__wstring(soap, &this->fimsdescription__bmContentDescriptionType::version);
	/* transient soap skipped */
#endif
}

int fimsdescription__bmContentDescriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fimsdescription__bmContentDescriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, int id, const fimsdescription__bmContentDescriptionType *a, const char *type)
{
	if (((fimsdescription__bmContentDescriptionType*)a)->xml__lang)
		soap_set_attr(soap, "xml:lang", soap_wchar2s(soap, ((fimsdescription__bmContentDescriptionType*)a)->xml__lang->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fimsdescription__bmContentDescriptionType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:title", -1, &(a->fimsdescription__bmContentDescriptionType::title), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, "fimsdescription:alternativeTitle", -1, &(a->fimsdescription__bmContentDescriptionType::alternativeTitle), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:creator", -1, &(a->fimsdescription__bmContentDescriptionType::creator), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, "fimsdescription:subject", -1, &(a->fimsdescription__bmContentDescriptionType::subject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, "fimsdescription:description", -1, &(a->fimsdescription__bmContentDescriptionType::description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:publisher", -1, &(a->fimsdescription__bmContentDescriptionType::publisher), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contributor", -1, &(a->fimsdescription__bmContentDescriptionType::contributor), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, "fimsdescription:date", -1, &(a->fimsdescription__bmContentDescriptionType::date), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, "fimsdescription:type", -1, &(a->fimsdescription__bmContentDescriptionType::type), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:identifier", -1, &(a->fimsdescription__bmContentDescriptionType::identifier), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, "fimsdescription:language", -1, &(a->fimsdescription__bmContentDescriptionType::language), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", -1, &(a->fimsdescription__bmContentDescriptionType::coverage), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, "fimsdescription:rights", -1, &(a->fimsdescription__bmContentDescriptionType::rights), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fimsdescription:version", -1, &(a->fimsdescription__bmContentDescriptionType::version), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fimsdescription__bmContentDescriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fimsdescription__bmContentDescriptionType(soap, tag, this, type);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType * SOAP_FMAC4 soap_in_fimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, fimsdescription__bmContentDescriptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fimsdescription__bmContentDescriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fimsdescription__bmContentDescriptionType, sizeof(fimsdescription__bmContentDescriptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fimsdescription__bmContentDescriptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fimsdescription__bmContentDescriptionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "xml:lang", 0);
		if (t)
		{
			if (!(((fimsdescription__bmContentDescriptionType*)a)->xml__lang = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fimsdescription__bmContentDescriptionType*)a)->xml__lang = soap_new_std__wstring(soap, -1);
				((fimsdescription__bmContentDescriptionType*)a)->xml__lang->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, "fimsdescription:title", &(a->fimsdescription__bmContentDescriptionType::title), "fimsdescription:textElementType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, "fimsdescription:alternativeTitle", &(a->fimsdescription__bmContentDescriptionType::alternativeTitle), "fimsdescription:titleType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:creator", &(a->fimsdescription__bmContentDescriptionType::creator), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, "fimsdescription:subject", &(a->fimsdescription__bmContentDescriptionType::subject), "fimsdescription:subjectType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, "fimsdescription:description", &(a->fimsdescription__bmContentDescriptionType::description), "fimsdescription:descriptionType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:publisher", &(a->fimsdescription__bmContentDescriptionType::publisher), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, "fimsdescription:contributor", &(a->fimsdescription__bmContentDescriptionType::contributor), "fimsdescription:entityType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, "fimsdescription:date", &(a->fimsdescription__bmContentDescriptionType::date), "fimsdescription:dateType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, "fimsdescription:type", &(a->fimsdescription__bmContentDescriptionType::type), "fimsdescription:typeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, "fimsdescription:identifier", &(a->fimsdescription__bmContentDescriptionType::identifier), "fimsdescription:identifierType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, "fimsdescription:language", &(a->fimsdescription__bmContentDescriptionType::language), "fimsdescription:languageType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, "fimsdescription:coverage", &(a->fimsdescription__bmContentDescriptionType::coverage), "fimsdescription:coverageType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, "fimsdescription:rights", &(a->fimsdescription__bmContentDescriptionType::rights), "fimsdescription:rightsType"))
					continue;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fimsdescription:version", &(a->fimsdescription__bmContentDescriptionType::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fimsdescription__bmContentDescriptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fimsdescription__bmContentDescriptionType, 0, sizeof(fimsdescription__bmContentDescriptionType), 0, soap_copy_fimsdescription__bmContentDescriptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fimsdescription__bmContentDescriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fimsdescription__bmContentDescriptionType);
	if (this->soap_out(soap, tag?tag:"fimsdescription:bmContentDescriptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fimsdescription__bmContentDescriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fimsdescription__bmContentDescriptionType(soap, this, tag, type);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType * SOAP_FMAC4 soap_get_fimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fimsdescription__bmContentDescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fimsdescription__bmContentDescriptionType * SOAP_FMAC2 soap_instantiate_fimsdescription__bmContentDescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fimsdescription__bmContentDescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fimsdescription__bmContentDescriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fimsdescription__bmContentDescriptionType);
		if (size)
			*size = sizeof(fimsdescription__bmContentDescriptionType);
		((fimsdescription__bmContentDescriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fimsdescription__bmContentDescriptionType, n);
		if (size)
			*size = n * sizeof(fimsdescription__bmContentDescriptionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fimsdescription__bmContentDescriptionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fimsdescription__bmContentDescriptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fimsdescription__bmContentDescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fimsdescription__bmContentDescriptionType %p -> %p\n", q, p));
	*(fimsdescription__bmContentDescriptionType*)p = *(fimsdescription__bmContentDescriptionType*)q;
}

void _fims__formatCollection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_fims__formatCollection::videoFormat = NULL;
	this->_fims__formatCollection::audioFormat = NULL;
	this->_fims__formatCollection::dataFormat = NULL;
	this->_fims__formatCollection::containerFormat = NULL;
	/* transient soap skipped */
}

void _fims__formatCollection::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__VideoFormatType(soap, &this->_fims__formatCollection::videoFormat);
	soap_serialize_PointerTofims__AudioFormatType(soap, &this->_fims__formatCollection::audioFormat);
	soap_serialize_PointerTofims__DataFormatType(soap, &this->_fims__formatCollection::dataFormat);
	soap_serialize_PointerTofims__ContainerFormatType(soap, &this->_fims__formatCollection::containerFormat);
	/* transient soap skipped */
#endif
}

int _fims__formatCollection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__fims__formatCollection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__formatCollection(struct soap *soap, const char *tag, int id, const _fims__formatCollection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__fims__formatCollection), type))
		return soap->error;
	if (soap_out_PointerTofims__VideoFormatType(soap, "fims:videoFormat", -1, &(a->_fims__formatCollection::videoFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__AudioFormatType(soap, "fims:audioFormat", -1, &(a->_fims__formatCollection::audioFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__DataFormatType(soap, "fims:dataFormat", -1, &(a->_fims__formatCollection::dataFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", -1, &(a->_fims__formatCollection::containerFormat), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_fims__formatCollection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__fims__formatCollection(soap, tag, this, type);
}

SOAP_FMAC3 _fims__formatCollection * SOAP_FMAC4 soap_in__fims__formatCollection(struct soap *soap, const char *tag, _fims__formatCollection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_fims__formatCollection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__fims__formatCollection, sizeof(_fims__formatCollection), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__fims__formatCollection)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_fims__formatCollection *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_videoFormat1 = 1;
	size_t soap_flag_audioFormat1 = 1;
	size_t soap_flag_dataFormat1 = 1;
	size_t soap_flag_containerFormat1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_videoFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__VideoFormatType(soap, "fims:videoFormat", &(a->_fims__formatCollection::videoFormat), "fims:VideoFormatType"))
				{	soap_flag_videoFormat1--;
					continue;
				}
			if (soap_flag_audioFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AudioFormatType(soap, "fims:audioFormat", &(a->_fims__formatCollection::audioFormat), "fims:AudioFormatType"))
				{	soap_flag_audioFormat1--;
					continue;
				}
			if (soap_flag_dataFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__DataFormatType(soap, "fims:dataFormat", &(a->_fims__formatCollection::dataFormat), "fims:DataFormatType"))
				{	soap_flag_dataFormat1--;
					continue;
				}
			if (soap_flag_containerFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", &(a->_fims__formatCollection::containerFormat), "fims:ContainerFormatType"))
				{	soap_flag_containerFormat1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_fims__formatCollection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__fims__formatCollection, 0, sizeof(_fims__formatCollection), 0, soap_copy__fims__formatCollection);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _fims__formatCollection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__fims__formatCollection);
	if (this->soap_out(soap, tag?tag:"fims:formatCollection", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_fims__formatCollection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__fims__formatCollection(soap, this, tag, type);
}

SOAP_FMAC3 _fims__formatCollection * SOAP_FMAC4 soap_get__fims__formatCollection(struct soap *soap, _fims__formatCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in__fims__formatCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _fims__formatCollection * SOAP_FMAC2 soap_instantiate__fims__formatCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__fims__formatCollection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__fims__formatCollection, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_fims__formatCollection);
		if (size)
			*size = sizeof(_fims__formatCollection);
		((_fims__formatCollection*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_fims__formatCollection, n);
		if (size)
			*size = n * sizeof(_fims__formatCollection);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_fims__formatCollection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_fims__formatCollection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__fims__formatCollection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _fims__formatCollection %p -> %p\n", q, p));
	*(_fims__formatCollection*)p = *(_fims__formatCollection*)q;
}

void fims__DescriptionsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__DescriptionType(soap, &this->fims__DescriptionsType::description);
	/* transient soap skipped */
}

void fims__DescriptionsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__DescriptionType(soap, &this->fims__DescriptionsType::description);
	/* transient soap skipped */
#endif
}

int fims__DescriptionsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DescriptionsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DescriptionsType(struct soap *soap, const char *tag, int id, const fims__DescriptionsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DescriptionsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__DescriptionType(soap, "fims:description", -1, &(a->fims__DescriptionsType::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__DescriptionsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DescriptionsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DescriptionsType * SOAP_FMAC4 soap_in_fims__DescriptionsType(struct soap *soap, const char *tag, fims__DescriptionsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DescriptionsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DescriptionsType, sizeof(fims__DescriptionsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DescriptionsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DescriptionsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__DescriptionType(soap, "fims:description", &(a->fims__DescriptionsType::description), "fims:DescriptionType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DescriptionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DescriptionsType, 0, sizeof(fims__DescriptionsType), 0, soap_copy_fims__DescriptionsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__DescriptionsType::description.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DescriptionsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DescriptionsType);
	if (this->soap_out(soap, tag?tag:"fims:DescriptionsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DescriptionsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DescriptionsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DescriptionsType * SOAP_FMAC4 soap_get_fims__DescriptionsType(struct soap *soap, fims__DescriptionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DescriptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DescriptionsType * SOAP_FMAC2 soap_instantiate_fims__DescriptionsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DescriptionsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DescriptionsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionsType);
		if (size)
			*size = sizeof(fims__DescriptionsType);
		((fims__DescriptionsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionsType, n);
		if (size)
			*size = n * sizeof(fims__DescriptionsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DescriptionsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DescriptionsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DescriptionsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DescriptionsType %p -> %p\n", q, p));
	*(fims__DescriptionsType*)p = *(fims__DescriptionsType*)q;
}

void fims__BMEssenceLocatorsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, &this->fims__BMEssenceLocatorsType::bmEssenceLocator);
	/* transient soap skipped */
}

void fims__BMEssenceLocatorsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, &this->fims__BMEssenceLocatorsType::bmEssenceLocator);
	/* transient soap skipped */
#endif
}

int fims__BMEssenceLocatorsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMEssenceLocatorsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMEssenceLocatorsType(struct soap *soap, const char *tag, int id, const fims__BMEssenceLocatorsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMEssenceLocatorsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, "fims:bmEssenceLocator", -1, &(a->fims__BMEssenceLocatorsType::bmEssenceLocator), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMEssenceLocatorsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMEssenceLocatorsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType * SOAP_FMAC4 soap_in_fims__BMEssenceLocatorsType(struct soap *soap, const char *tag, fims__BMEssenceLocatorsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMEssenceLocatorsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMEssenceLocatorsType, sizeof(fims__BMEssenceLocatorsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMEssenceLocatorsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMEssenceLocatorsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, "fims:bmEssenceLocator", &(a->fims__BMEssenceLocatorsType::bmEssenceLocator), "fims:BMEssenceLocatorType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMEssenceLocatorsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMEssenceLocatorsType, 0, sizeof(fims__BMEssenceLocatorsType), 0, soap_copy_fims__BMEssenceLocatorsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMEssenceLocatorsType::bmEssenceLocator.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMEssenceLocatorsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMEssenceLocatorsType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMEssenceLocatorsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMEssenceLocatorsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType * SOAP_FMAC4 soap_get_fims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMEssenceLocatorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMEssenceLocatorsType * SOAP_FMAC2 soap_instantiate_fims__BMEssenceLocatorsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMEssenceLocatorsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMEssenceLocatorsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorsType);
		if (size)
			*size = sizeof(fims__BMEssenceLocatorsType);
		((fims__BMEssenceLocatorsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorsType, n);
		if (size)
			*size = n * sizeof(fims__BMEssenceLocatorsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMEssenceLocatorsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMEssenceLocatorsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMEssenceLocatorsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMEssenceLocatorsType %p -> %p\n", q, p));
	*(fims__BMEssenceLocatorsType*)p = *(fims__BMEssenceLocatorsType*)q;
}

void fims__BMContentFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, &this->fims__BMContentFormatsType::bmContentFormat);
	/* transient soap skipped */
}

void fims__BMContentFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, &this->fims__BMContentFormatsType::bmContentFormat);
	/* transient soap skipped */
#endif
}

int fims__BMContentFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentFormatsType(struct soap *soap, const char *tag, int id, const fims__BMContentFormatsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, "fims:bmContentFormat", -1, &(a->fims__BMContentFormatsType::bmContentFormat), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentFormatsType * SOAP_FMAC4 soap_in_fims__BMContentFormatsType(struct soap *soap, const char *tag, fims__BMContentFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentFormatsType, sizeof(fims__BMContentFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, "fims:bmContentFormat", &(a->fims__BMContentFormatsType::bmContentFormat), "fims:BMContentFormatType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentFormatsType, 0, sizeof(fims__BMContentFormatsType), 0, soap_copy_fims__BMContentFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMContentFormatsType::bmContentFormat.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentFormatsType * SOAP_FMAC4 soap_get_fims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentFormatsType * SOAP_FMAC2 soap_instantiate_fims__BMContentFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatsType);
		if (size)
			*size = sizeof(fims__BMContentFormatsType);
		((fims__BMContentFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatsType, n);
		if (size)
			*size = n * sizeof(fims__BMContentFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentFormatsType %p -> %p\n", q, p));
	*(fims__BMContentFormatsType*)p = *(fims__BMContentFormatsType*)q;
}

void fims__BMContentsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMContentType(soap, &this->fims__BMContentsType::bmContent);
	/* transient soap skipped */
}

void fims__BMContentsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMContentType(soap, &this->fims__BMContentsType::bmContent);
	/* transient soap skipped */
#endif
}

int fims__BMContentsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentsType(struct soap *soap, const char *tag, int id, const fims__BMContentsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMContentType(soap, "fims:bmContent", -1, &(a->fims__BMContentsType::bmContent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentsType * SOAP_FMAC4 soap_in_fims__BMContentsType(struct soap *soap, const char *tag, fims__BMContentsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentsType, sizeof(fims__BMContentsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMContentType(soap, "fims:bmContent", &(a->fims__BMContentsType::bmContent), "fims:BMContentType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentsType, 0, sizeof(fims__BMContentsType), 0, soap_copy_fims__BMContentsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMContentsType::bmContent.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentsType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentsType * SOAP_FMAC4 soap_get_fims__BMContentsType(struct soap *soap, fims__BMContentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentsType * SOAP_FMAC2 soap_instantiate_fims__BMContentsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentsType);
		if (size)
			*size = sizeof(fims__BMContentsType);
		((fims__BMContentsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentsType, n);
		if (size)
			*size = n * sizeof(fims__BMContentsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentsType %p -> %p\n", q, p));
	*(fims__BMContentsType*)p = *(fims__BMContentsType*)q;
}

void fims__BMObjectsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTofims__BMObjectType(soap, &this->fims__BMObjectsType::bmObject);
	/* transient soap skipped */
}

void fims__BMObjectsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__BMObjectType(soap, &this->fims__BMObjectsType::bmObject);
	/* transient soap skipped */
#endif
}

int fims__BMObjectsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMObjectsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMObjectsType(struct soap *soap, const char *tag, int id, const fims__BMObjectsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMObjectsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMObjectType(soap, "fims:bmObject", -1, &(a->fims__BMObjectsType::bmObject), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMObjectsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMObjectsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMObjectsType * SOAP_FMAC4 soap_in_fims__BMObjectsType(struct soap *soap, const char *tag, fims__BMObjectsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMObjectsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMObjectsType, sizeof(fims__BMObjectsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMObjectsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMObjectsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMObjectType(soap, "fims:bmObject", &(a->fims__BMObjectsType::bmObject), "fims:BMObjectType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMObjectsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMObjectsType, 0, sizeof(fims__BMObjectsType), 0, soap_copy_fims__BMObjectsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__BMObjectsType::bmObject.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMObjectsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMObjectsType);
	if (this->soap_out(soap, tag?tag:"fims:BMObjectsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMObjectsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMObjectsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMObjectsType * SOAP_FMAC4 soap_get_fims__BMObjectsType(struct soap *soap, fims__BMObjectsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMObjectsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMObjectsType * SOAP_FMAC2 soap_instantiate_fims__BMObjectsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMObjectsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMObjectsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectsType);
		if (size)
			*size = sizeof(fims__BMObjectsType);
		((fims__BMObjectsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectsType, n);
		if (size)
			*size = n * sizeof(fims__BMObjectsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMObjectsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMObjectsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMObjectsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMObjectsType %p -> %p\n", q, p));
	*(fims__BMObjectsType*)p = *(fims__BMObjectsType*)q;
}

void fims__DataFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__DataFormatsType_sequence(soap, &this->fims__DataFormatsType::__DataFormatsType_sequence);
	/* transient soap skipped */
}

void fims__DataFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__DataFormatsType_sequence(soap, &this->fims__DataFormatsType::__DataFormatsType_sequence);
	/* transient soap skipped */
#endif
}

int fims__DataFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DataFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DataFormatsType(struct soap *soap, const char *tag, int id, const fims__DataFormatsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DataFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__DataFormatsType_sequence(soap, "-DataFormatsType-sequence", -1, &(a->fims__DataFormatsType::__DataFormatsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__DataFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DataFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DataFormatsType * SOAP_FMAC4 soap_in_fims__DataFormatsType(struct soap *soap, const char *tag, fims__DataFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DataFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DataFormatsType, sizeof(fims__DataFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DataFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DataFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__DataFormatsType_sequence(soap, "-DataFormatsType-sequence", &(a->fims__DataFormatsType::__DataFormatsType_sequence), "-fims:DataFormatsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DataFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DataFormatsType, 0, sizeof(fims__DataFormatsType), 0, soap_copy_fims__DataFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__DataFormatsType::__DataFormatsType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DataFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DataFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:DataFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DataFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DataFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DataFormatsType * SOAP_FMAC4 soap_get_fims__DataFormatsType(struct soap *soap, fims__DataFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DataFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DataFormatsType * SOAP_FMAC2 soap_instantiate_fims__DataFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DataFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DataFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatsType);
		if (size)
			*size = sizeof(fims__DataFormatsType);
		((fims__DataFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatsType, n);
		if (size)
			*size = n * sizeof(fims__DataFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DataFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DataFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DataFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DataFormatsType %p -> %p\n", q, p));
	*(fims__DataFormatsType*)p = *(fims__DataFormatsType*)q;
}

void fims__ContainerFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(soap, &this->fims__ContainerFormatsType::__ContainerFormatsType_sequence);
	/* transient soap skipped */
}

void fims__ContainerFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(soap, &this->fims__ContainerFormatsType::__ContainerFormatsType_sequence);
	/* transient soap skipped */
#endif
}

int fims__ContainerFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContainerFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContainerFormatsType(struct soap *soap, const char *tag, int id, const fims__ContainerFormatsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContainerFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(soap, "-ContainerFormatsType-sequence", -1, &(a->fims__ContainerFormatsType::__ContainerFormatsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ContainerFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContainerFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContainerFormatsType * SOAP_FMAC4 soap_in_fims__ContainerFormatsType(struct soap *soap, const char *tag, fims__ContainerFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContainerFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContainerFormatsType, sizeof(fims__ContainerFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContainerFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContainerFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(soap, "-ContainerFormatsType-sequence", &(a->fims__ContainerFormatsType::__ContainerFormatsType_sequence), "-fims:ContainerFormatsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContainerFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContainerFormatsType, 0, sizeof(fims__ContainerFormatsType), 0, soap_copy_fims__ContainerFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ContainerFormatsType::__ContainerFormatsType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ContainerFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContainerFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:ContainerFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContainerFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContainerFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContainerFormatsType * SOAP_FMAC4 soap_get_fims__ContainerFormatsType(struct soap *soap, fims__ContainerFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContainerFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContainerFormatsType * SOAP_FMAC2 soap_instantiate_fims__ContainerFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContainerFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContainerFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatsType);
		if (size)
			*size = sizeof(fims__ContainerFormatsType);
		((fims__ContainerFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatsType, n);
		if (size)
			*size = n * sizeof(fims__ContainerFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContainerFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContainerFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContainerFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContainerFormatsType %p -> %p\n", q, p));
	*(fims__ContainerFormatsType*)p = *(fims__ContainerFormatsType*)q;
}

void fims__AudioFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__AudioFormatsType_sequence(soap, &this->fims__AudioFormatsType::__AudioFormatsType_sequence);
	/* transient soap skipped */
}

void fims__AudioFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__AudioFormatsType_sequence(soap, &this->fims__AudioFormatsType::__AudioFormatsType_sequence);
	/* transient soap skipped */
#endif
}

int fims__AudioFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AudioFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AudioFormatsType(struct soap *soap, const char *tag, int id, const fims__AudioFormatsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AudioFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__AudioFormatsType_sequence(soap, "-AudioFormatsType-sequence", -1, &(a->fims__AudioFormatsType::__AudioFormatsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__AudioFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AudioFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AudioFormatsType * SOAP_FMAC4 soap_in_fims__AudioFormatsType(struct soap *soap, const char *tag, fims__AudioFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AudioFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AudioFormatsType, sizeof(fims__AudioFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AudioFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AudioFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__AudioFormatsType_sequence(soap, "-AudioFormatsType-sequence", &(a->fims__AudioFormatsType::__AudioFormatsType_sequence), "-fims:AudioFormatsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AudioFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AudioFormatsType, 0, sizeof(fims__AudioFormatsType), 0, soap_copy_fims__AudioFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__AudioFormatsType::__AudioFormatsType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__AudioFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AudioFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:AudioFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AudioFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AudioFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AudioFormatsType * SOAP_FMAC4 soap_get_fims__AudioFormatsType(struct soap *soap, fims__AudioFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AudioFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AudioFormatsType * SOAP_FMAC2 soap_instantiate_fims__AudioFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AudioFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AudioFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatsType);
		if (size)
			*size = sizeof(fims__AudioFormatsType);
		((fims__AudioFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatsType, n);
		if (size)
			*size = n * sizeof(fims__AudioFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AudioFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AudioFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AudioFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AudioFormatsType %p -> %p\n", q, p));
	*(fims__AudioFormatsType*)p = *(fims__AudioFormatsType*)q;
}

void fims__VideoFormatsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__VideoFormatsType_sequence(soap, &this->fims__VideoFormatsType::__VideoFormatsType_sequence);
	/* transient soap skipped */
}

void fims__VideoFormatsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__VideoFormatsType_sequence(soap, &this->fims__VideoFormatsType::__VideoFormatsType_sequence);
	/* transient soap skipped */
#endif
}

int fims__VideoFormatsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__VideoFormatsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__VideoFormatsType(struct soap *soap, const char *tag, int id, const fims__VideoFormatsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__VideoFormatsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__VideoFormatsType_sequence(soap, "-VideoFormatsType-sequence", -1, &(a->fims__VideoFormatsType::__VideoFormatsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__VideoFormatsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__VideoFormatsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__VideoFormatsType * SOAP_FMAC4 soap_in_fims__VideoFormatsType(struct soap *soap, const char *tag, fims__VideoFormatsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__VideoFormatsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__VideoFormatsType, sizeof(fims__VideoFormatsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__VideoFormatsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__VideoFormatsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__VideoFormatsType_sequence(soap, "-VideoFormatsType-sequence", &(a->fims__VideoFormatsType::__VideoFormatsType_sequence), "-fims:VideoFormatsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__VideoFormatsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__VideoFormatsType, 0, sizeof(fims__VideoFormatsType), 0, soap_copy_fims__VideoFormatsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__VideoFormatsType::__VideoFormatsType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__VideoFormatsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__VideoFormatsType);
	if (this->soap_out(soap, tag?tag:"fims:VideoFormatsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__VideoFormatsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__VideoFormatsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__VideoFormatsType * SOAP_FMAC4 soap_get_fims__VideoFormatsType(struct soap *soap, fims__VideoFormatsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__VideoFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__VideoFormatsType * SOAP_FMAC2 soap_instantiate_fims__VideoFormatsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__VideoFormatsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__VideoFormatsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatsType);
		if (size)
			*size = sizeof(fims__VideoFormatsType);
		((fims__VideoFormatsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatsType, n);
		if (size)
			*size = n * sizeof(fims__VideoFormatsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__VideoFormatsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__VideoFormatsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__VideoFormatsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__VideoFormatsType %p -> %p\n", q, p));
	*(fims__VideoFormatsType*)p = *(fims__VideoFormatsType*)q;
}

void fims__JobsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__JobsType_sequence(soap, &this->fims__JobsType::__JobsType_sequence);
	/* transient soap skipped */
}

void fims__JobsType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__JobsType_sequence(soap, &this->fims__JobsType::__JobsType_sequence);
	/* transient soap skipped */
#endif
}

int fims__JobsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__JobsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobsType(struct soap *soap, const char *tag, int id, const fims__JobsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobsType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__JobsType_sequence(soap, "-JobsType-sequence", -1, &(a->fims__JobsType::__JobsType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__JobsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__JobsType(soap, tag, this, type);
}

SOAP_FMAC3 fims__JobsType * SOAP_FMAC4 soap_in_fims__JobsType(struct soap *soap, const char *tag, fims__JobsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__JobsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobsType, sizeof(fims__JobsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__JobsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__JobsType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__JobsType_sequence(soap, "-JobsType-sequence", &(a->fims__JobsType::__JobsType_sequence), "-fims:JobsType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__JobsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobsType, 0, sizeof(fims__JobsType), 0, soap_copy_fims__JobsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__JobsType::__JobsType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__JobsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__JobsType);
	if (this->soap_out(soap, tag?tag:"fims:JobsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__JobsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__JobsType(soap, this, tag, type);
}

SOAP_FMAC3 fims__JobsType * SOAP_FMAC4 soap_get_fims__JobsType(struct soap *soap, fims__JobsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__JobsType * SOAP_FMAC2 soap_instantiate_fims__JobsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__JobsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__JobsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__JobsType);
		if (size)
			*size = sizeof(fims__JobsType);
		((fims__JobsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobsType, n);
		if (size)
			*size = n * sizeof(fims__JobsType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__JobsType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__JobsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__JobsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__JobsType %p -> %p\n", q, p));
	*(fims__JobsType*)p = *(fims__JobsType*)q;
}

void fims__QueuesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__QueuesType_sequence(soap, &this->fims__QueuesType::__QueuesType_sequence);
	/* transient soap skipped */
}

void fims__QueuesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__QueuesType_sequence(soap, &this->fims__QueuesType::__QueuesType_sequence);
	/* transient soap skipped */
#endif
}

int fims__QueuesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueuesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueuesType(struct soap *soap, const char *tag, int id, const fims__QueuesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueuesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__QueuesType_sequence(soap, "-QueuesType-sequence", -1, &(a->fims__QueuesType::__QueuesType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueuesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueuesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueuesType * SOAP_FMAC4 soap_in_fims__QueuesType(struct soap *soap, const char *tag, fims__QueuesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueuesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueuesType, sizeof(fims__QueuesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueuesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueuesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__QueuesType_sequence(soap, "-QueuesType-sequence", &(a->fims__QueuesType::__QueuesType_sequence), "-fims:QueuesType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueuesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueuesType, 0, sizeof(fims__QueuesType), 0, soap_copy_fims__QueuesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__QueuesType::__QueuesType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueuesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueuesType);
	if (this->soap_out(soap, tag?tag:"fims:QueuesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueuesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueuesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueuesType * SOAP_FMAC4 soap_get_fims__QueuesType(struct soap *soap, fims__QueuesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueuesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueuesType * SOAP_FMAC2 soap_instantiate_fims__QueuesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueuesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueuesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueuesType);
		if (size)
			*size = sizeof(fims__QueuesType);
		((fims__QueuesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueuesType, n);
		if (size)
			*size = n * sizeof(fims__QueuesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueuesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueuesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueuesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueuesType %p -> %p\n", q, p));
	*(fims__QueuesType*)p = *(fims__QueuesType*)q;
}

void fims__ServicesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__ServicesType_sequence(soap, &this->fims__ServicesType::__ServicesType_sequence);
	/* transient soap skipped */
}

void fims__ServicesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__ServicesType_sequence(soap, &this->fims__ServicesType::__ServicesType_sequence);
	/* transient soap skipped */
#endif
}

int fims__ServicesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ServicesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ServicesType(struct soap *soap, const char *tag, int id, const fims__ServicesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ServicesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__ServicesType_sequence(soap, "-ServicesType-sequence", -1, &(a->fims__ServicesType::__ServicesType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ServicesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ServicesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ServicesType * SOAP_FMAC4 soap_in_fims__ServicesType(struct soap *soap, const char *tag, fims__ServicesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ServicesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ServicesType, sizeof(fims__ServicesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ServicesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ServicesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__ServicesType_sequence(soap, "-ServicesType-sequence", &(a->fims__ServicesType::__ServicesType_sequence), "-fims:ServicesType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ServicesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ServicesType, 0, sizeof(fims__ServicesType), 0, soap_copy_fims__ServicesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ServicesType::__ServicesType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ServicesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ServicesType);
	if (this->soap_out(soap, tag?tag:"fims:ServicesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ServicesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ServicesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ServicesType * SOAP_FMAC4 soap_get_fims__ServicesType(struct soap *soap, fims__ServicesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ServicesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ServicesType * SOAP_FMAC2 soap_instantiate_fims__ServicesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ServicesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ServicesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ServicesType);
		if (size)
			*size = sizeof(fims__ServicesType);
		((fims__ServicesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServicesType, n);
		if (size)
			*size = n * sizeof(fims__ServicesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ServicesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ServicesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ServicesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ServicesType %p -> %p\n", q, p));
	*(fims__ServicesType*)p = *(fims__ServicesType*)q;
}

void fims__ProfilesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__ProfilesType_sequence(soap, &this->fims__ProfilesType::__ProfilesType_sequence);
	/* transient soap skipped */
}

void fims__ProfilesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__ProfilesType_sequence(soap, &this->fims__ProfilesType::__ProfilesType_sequence);
	/* transient soap skipped */
#endif
}

int fims__ProfilesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProfilesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProfilesType(struct soap *soap, const char *tag, int id, const fims__ProfilesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProfilesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__ProfilesType_sequence(soap, "-ProfilesType-sequence", -1, &(a->fims__ProfilesType::__ProfilesType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ProfilesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProfilesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProfilesType * SOAP_FMAC4 soap_in_fims__ProfilesType(struct soap *soap, const char *tag, fims__ProfilesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProfilesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProfilesType, sizeof(fims__ProfilesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProfilesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProfilesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__ProfilesType_sequence(soap, "-ProfilesType-sequence", &(a->fims__ProfilesType::__ProfilesType_sequence), "-fims:ProfilesType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProfilesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProfilesType, 0, sizeof(fims__ProfilesType), 0, soap_copy_fims__ProfilesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ProfilesType::__ProfilesType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProfilesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProfilesType);
	if (this->soap_out(soap, tag?tag:"fims:ProfilesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProfilesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProfilesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProfilesType * SOAP_FMAC4 soap_get_fims__ProfilesType(struct soap *soap, fims__ProfilesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProfilesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProfilesType * SOAP_FMAC2 soap_instantiate_fims__ProfilesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProfilesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProfilesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProfilesType);
		if (size)
			*size = sizeof(fims__ProfilesType);
		((fims__ProfilesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfilesType, n);
		if (size)
			*size = n * sizeof(fims__ProfilesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProfilesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProfilesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProfilesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProfilesType %p -> %p\n", q, p));
	*(fims__ProfilesType*)p = *(fims__ProfilesType*)q;
}

void fims__ResourcesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf__fims__ResourcesType_sequence(soap, &this->fims__ResourcesType::__ResourcesType_sequence);
	/* transient soap skipped */
}

void fims__ResourcesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf__fims__ResourcesType_sequence(soap, &this->fims__ResourcesType::__ResourcesType_sequence);
	/* transient soap skipped */
#endif
}

int fims__ResourcesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ResourcesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourcesType(struct soap *soap, const char *tag, int id, const fims__ResourcesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ResourcesType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf__fims__ResourcesType_sequence(soap, "-ResourcesType-sequence", -1, &(a->fims__ResourcesType::__ResourcesType_sequence), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ResourcesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ResourcesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ResourcesType * SOAP_FMAC4 soap_in_fims__ResourcesType(struct soap *soap, const char *tag, fims__ResourcesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ResourcesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ResourcesType, sizeof(fims__ResourcesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ResourcesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ResourcesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf__fims__ResourcesType_sequence(soap, "-ResourcesType-sequence", &(a->fims__ResourcesType::__ResourcesType_sequence), "-fims:ResourcesType-sequence"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ResourcesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ResourcesType, 0, sizeof(fims__ResourcesType), 0, soap_copy_fims__ResourcesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->fims__ResourcesType::__ResourcesType_sequence.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ResourcesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ResourcesType);
	if (this->soap_out(soap, tag?tag:"fims:ResourcesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ResourcesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ResourcesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ResourcesType * SOAP_FMAC4 soap_get_fims__ResourcesType(struct soap *soap, fims__ResourcesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourcesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ResourcesType * SOAP_FMAC2 soap_instantiate_fims__ResourcesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ResourcesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ResourcesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ResourcesType);
		if (size)
			*size = sizeof(fims__ResourcesType);
		((fims__ResourcesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourcesType, n);
		if (size)
			*size = n * sizeof(fims__ResourcesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ResourcesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ResourcesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ResourcesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ResourcesType %p -> %p\n", q, p));
	*(fims__ResourcesType*)p = *(fims__ResourcesType*)q;
}

void fims__InnerFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fims__InnerFaultType::code);
	this->fims__InnerFaultType::description = NULL;
	this->fims__InnerFaultType::detail = NULL;
	/* transient soap skipped */
}

void fims__InnerFaultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__InnerFaultType::code, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__InnerFaultType::code);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__InnerFaultType::description);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__InnerFaultType::detail);
	/* transient soap skipped */
#endif
}

int fims__InnerFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__InnerFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__InnerFaultType(struct soap *soap, const char *tag, int id, const fims__InnerFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__InnerFaultType), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "fims:code", -1, &(a->fims__InnerFaultType::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:description", -1, &(a->fims__InnerFaultType::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:detail", -1, &(a->fims__InnerFaultType::detail), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__InnerFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__InnerFaultType(soap, tag, this, type);
}

SOAP_FMAC3 fims__InnerFaultType * SOAP_FMAC4 soap_in_fims__InnerFaultType(struct soap *soap, const char *tag, fims__InnerFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__InnerFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__InnerFaultType, sizeof(fims__InnerFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__InnerFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__InnerFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_detail1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "fims:code", &(a->fims__InnerFaultType::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:description", &(a->fims__InnerFaultType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_detail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:detail", &(a->fims__InnerFaultType::detail), "xsd:string"))
				{	soap_flag_detail1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__InnerFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__InnerFaultType, 0, sizeof(fims__InnerFaultType), 0, soap_copy_fims__InnerFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__InnerFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__InnerFaultType);
	if (this->soap_out(soap, tag?tag:"fims:InnerFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__InnerFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__InnerFaultType(soap, this, tag, type);
}

SOAP_FMAC3 fims__InnerFaultType * SOAP_FMAC4 soap_get_fims__InnerFaultType(struct soap *soap, fims__InnerFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__InnerFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__InnerFaultType * SOAP_FMAC2 soap_instantiate_fims__InnerFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__InnerFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__InnerFaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__InnerFaultType);
		if (size)
			*size = sizeof(fims__InnerFaultType);
		((fims__InnerFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__InnerFaultType, n);
		if (size)
			*size = n * sizeof(fims__InnerFaultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__InnerFaultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__InnerFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__InnerFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__InnerFaultType %p -> %p\n", q, p));
	*(fims__InnerFaultType*)p = *(fims__InnerFaultType*)q;
}

void fims__FaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__ErrorCodeType(soap, &this->fims__FaultType::code);
	this->fims__FaultType::description = NULL;
	this->fims__FaultType::detail = NULL;
	soap_default_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, &this->fims__FaultType::innerFault);
	/* transient soap skipped */
}

void fims__FaultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__FaultType::description);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__FaultType::detail);
	soap_serialize_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, &this->fims__FaultType::innerFault);
	/* transient soap skipped */
#endif
}

int fims__FaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__FaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__FaultType(struct soap *soap, const char *tag, int id, const fims__FaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__FaultType), type))
		return soap->error;
	if (soap_out_fims__ErrorCodeType(soap, "fims:code", -1, &(a->fims__FaultType::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:description", -1, &(a->fims__FaultType::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:detail", -1, &(a->fims__FaultType::detail), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", -1, &(a->fims__FaultType::innerFault), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__FaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__FaultType(soap, tag, this, type);
}

SOAP_FMAC3 fims__FaultType * SOAP_FMAC4 soap_in_fims__FaultType(struct soap *soap, const char *tag, fims__FaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__FaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__FaultType, sizeof(fims__FaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__FaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__FaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_detail1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__ErrorCodeType(soap, "fims:code", &(a->fims__FaultType::code), "fims:ErrorCodeType"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:description", &(a->fims__FaultType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_detail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:detail", &(a->fims__FaultType::detail), "xsd:string"))
				{	soap_flag_detail1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", &(a->fims__FaultType::innerFault), "fims:InnerFaultType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__FaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__FaultType, 0, sizeof(fims__FaultType), 0, soap_copy_fims__FaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__FaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__FaultType);
	if (this->soap_out(soap, tag?tag:"fims:FaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__FaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__FaultType(soap, this, tag, type);
}

SOAP_FMAC3 fims__FaultType * SOAP_FMAC4 soap_get_fims__FaultType(struct soap *soap, fims__FaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__FaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__FaultType * SOAP_FMAC2 soap_instantiate_fims__FaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__FaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__FaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "edlprovider:EdlProviderFaultType"))
	{	cp->type = SOAP_TYPE_edlprovider__EdlProviderFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlProviderFaultType);
			if (size)
				*size = sizeof(edlprovider__EdlProviderFaultType);
			((edlprovider__EdlProviderFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlProviderFaultType, n);
			if (size)
				*size = n * sizeof(edlprovider__EdlProviderFaultType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((edlprovider__EdlProviderFaultType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (edlprovider__EdlProviderFaultType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__FaultType);
		if (size)
			*size = sizeof(fims__FaultType);
		((fims__FaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FaultType, n);
		if (size)
			*size = n * sizeof(fims__FaultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__FaultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__FaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__FaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__FaultType %p -> %p\n", q, p));
	*(fims__FaultType*)p = *(fims__FaultType*)q;
}

void fims__ListFilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ListFilterType::fromDate = NULL;
	this->fims__ListFilterType::toDate = NULL;
	soap_default_bool(soap, &this->fims__ListFilterType::includeQueued);
	soap_default_bool(soap, &this->fims__ListFilterType::includeActive);
	soap_default_bool(soap, &this->fims__ListFilterType::includeFinished);
	soap_default_bool(soap, &this->fims__ListFilterType::includeFailed);
	this->fims__ListFilterType::maxNumberResults = NULL;
	/* transient soap skipped */
}

void fims__ListFilterType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__ListFilterType::fromDate);
	soap_serialize_PointerTotime(soap, &this->fims__ListFilterType::toDate);
	soap_embedded(soap, &this->fims__ListFilterType::includeQueued, SOAP_TYPE_bool);
	soap_embedded(soap, &this->fims__ListFilterType::includeActive, SOAP_TYPE_bool);
	soap_embedded(soap, &this->fims__ListFilterType::includeFinished, SOAP_TYPE_bool);
	soap_embedded(soap, &this->fims__ListFilterType::includeFailed, SOAP_TYPE_bool);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__ListFilterType::maxNumberResults);
	/* transient soap skipped */
#endif
}

int fims__ListFilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ListFilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ListFilterType(struct soap *soap, const char *tag, int id, const fims__ListFilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ListFilterType), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:fromDate", -1, &(a->fims__ListFilterType::fromDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:toDate", -1, &(a->fims__ListFilterType::toDate), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeQueued", -1, &(a->fims__ListFilterType::includeQueued), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeActive", -1, &(a->fims__ListFilterType::includeActive), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeFinished", -1, &(a->fims__ListFilterType::includeFinished), ""))
		return soap->error;
	if (soap_out_bool(soap, "fims:includeFailed", -1, &(a->fims__ListFilterType::includeFailed), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:maxNumberResults", -1, &(a->fims__ListFilterType::maxNumberResults), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ListFilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ListFilterType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ListFilterType * SOAP_FMAC4 soap_in_fims__ListFilterType(struct soap *soap, const char *tag, fims__ListFilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ListFilterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ListFilterType, sizeof(fims__ListFilterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ListFilterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ListFilterType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_fromDate1 = 1;
	size_t soap_flag_toDate1 = 1;
	size_t soap_flag_includeQueued1 = 1;
	size_t soap_flag_includeActive1 = 1;
	size_t soap_flag_includeFinished1 = 1;
	size_t soap_flag_includeFailed1 = 1;
	size_t soap_flag_maxNumberResults1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fromDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:fromDate", &(a->fims__ListFilterType::fromDate), "xsd:dateTime"))
				{	soap_flag_fromDate1--;
					continue;
				}
			if (soap_flag_toDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:toDate", &(a->fims__ListFilterType::toDate), "xsd:dateTime"))
				{	soap_flag_toDate1--;
					continue;
				}
			if (soap_flag_includeQueued1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeQueued", &(a->fims__ListFilterType::includeQueued), "xsd:boolean"))
				{	soap_flag_includeQueued1--;
					continue;
				}
			if (soap_flag_includeActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeActive", &(a->fims__ListFilterType::includeActive), "xsd:boolean"))
				{	soap_flag_includeActive1--;
					continue;
				}
			if (soap_flag_includeFinished1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeFinished", &(a->fims__ListFilterType::includeFinished), "xsd:boolean"))
				{	soap_flag_includeFinished1--;
					continue;
				}
			if (soap_flag_includeFailed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fims:includeFailed", &(a->fims__ListFilterType::includeFailed), "xsd:boolean"))
				{	soap_flag_includeFailed1--;
					continue;
				}
			if (soap_flag_maxNumberResults1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:maxNumberResults", &(a->fims__ListFilterType::maxNumberResults), "xsd:nonNegativeInteger"))
				{	soap_flag_maxNumberResults1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ListFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ListFilterType, 0, sizeof(fims__ListFilterType), 0, soap_copy_fims__ListFilterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_includeQueued1 > 0 || soap_flag_includeActive1 > 0 || soap_flag_includeFinished1 > 0 || soap_flag_includeFailed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ListFilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ListFilterType);
	if (this->soap_out(soap, tag?tag:"fims:ListFilterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ListFilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ListFilterType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ListFilterType * SOAP_FMAC4 soap_get_fims__ListFilterType(struct soap *soap, fims__ListFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ListFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ListFilterType * SOAP_FMAC2 soap_instantiate_fims__ListFilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ListFilterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ListFilterType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ListFilterType);
		if (size)
			*size = sizeof(fims__ListFilterType);
		((fims__ListFilterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFilterType, n);
		if (size)
			*size = n * sizeof(fims__ListFilterType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ListFilterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ListFilterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ListFilterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ListFilterType %p -> %p\n", q, p));
	*(fims__ListFilterType*)p = *(fims__ListFilterType*)q;
}

void fims__QueryServiceDescriptionResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryServiceDescriptionResponseType::service = NULL;
	/* transient soap skipped */
}

void fims__QueryServiceDescriptionResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ServiceType(soap, &this->fims__QueryServiceDescriptionResponseType::service);
	/* transient soap skipped */
#endif
}

int fims__QueryServiceDescriptionResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryServiceDescriptionResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryServiceDescriptionResponseType(struct soap *soap, const char *tag, int id, const fims__QueryServiceDescriptionResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryServiceDescriptionResponseType), type))
		return soap->error;
	if (a->fims__QueryServiceDescriptionResponseType::service)
	{	if (soap_out_PointerTofims__ServiceType(soap, "fims:service", -1, &a->fims__QueryServiceDescriptionResponseType::service, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:service"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryServiceDescriptionResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryServiceDescriptionResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionResponseType * SOAP_FMAC4 soap_in_fims__QueryServiceDescriptionResponseType(struct soap *soap, const char *tag, fims__QueryServiceDescriptionResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryServiceDescriptionResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryServiceDescriptionResponseType, sizeof(fims__QueryServiceDescriptionResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryServiceDescriptionResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryServiceDescriptionResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_service1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_service1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ServiceType(soap, "fims:service", &(a->fims__QueryServiceDescriptionResponseType::service), "fims:ServiceType"))
				{	soap_flag_service1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryServiceDescriptionResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryServiceDescriptionResponseType, 0, sizeof(fims__QueryServiceDescriptionResponseType), 0, soap_copy_fims__QueryServiceDescriptionResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_service1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryServiceDescriptionResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryServiceDescriptionResponseType);
	if (this->soap_out(soap, tag?tag:"fims:QueryServiceDescriptionResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryServiceDescriptionResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryServiceDescriptionResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionResponseType * SOAP_FMAC4 soap_get_fims__QueryServiceDescriptionResponseType(struct soap *soap, fims__QueryServiceDescriptionResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryServiceDescriptionResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryServiceDescriptionResponseType * SOAP_FMAC2 soap_instantiate_fims__QueryServiceDescriptionResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryServiceDescriptionResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryServiceDescriptionResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryServiceDescriptionResponseType);
		if (size)
			*size = sizeof(fims__QueryServiceDescriptionResponseType);
		((fims__QueryServiceDescriptionResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryServiceDescriptionResponseType, n);
		if (size)
			*size = n * sizeof(fims__QueryServiceDescriptionResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryServiceDescriptionResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryServiceDescriptionResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryServiceDescriptionResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryServiceDescriptionResponseType %p -> %p\n", q, p));
	*(fims__QueryServiceDescriptionResponseType*)p = *(fims__QueryServiceDescriptionResponseType*)q;
}

void fims__QueryServiceDescriptionRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryServiceDescriptionRequestType::responseType = (enum _fims__QueryServiceDescriptionRequestType_responseType)1;
	/* transient soap skipped */
}

void fims__QueryServiceDescriptionRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__QueryServiceDescriptionRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryServiceDescriptionRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryServiceDescriptionRequestType(struct soap *soap, const char *tag, int id, const fims__QueryServiceDescriptionRequestType *a, const char *type)
{
	soap_set_attr(soap, "responseType", soap__fims__QueryServiceDescriptionRequestType_responseType2s(soap, ((fims__QueryServiceDescriptionRequestType*)a)->responseType), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryServiceDescriptionRequestType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryServiceDescriptionRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryServiceDescriptionRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionRequestType * SOAP_FMAC4 soap_in_fims__QueryServiceDescriptionRequestType(struct soap *soap, const char *tag, fims__QueryServiceDescriptionRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryServiceDescriptionRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryServiceDescriptionRequestType, sizeof(fims__QueryServiceDescriptionRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryServiceDescriptionRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryServiceDescriptionRequestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_fims__QueryServiceDescriptionRequestType_responseType(soap, soap_attr_value(soap, "responseType", 0), &((fims__QueryServiceDescriptionRequestType*)a)->responseType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryServiceDescriptionRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryServiceDescriptionRequestType, 0, sizeof(fims__QueryServiceDescriptionRequestType), 0, soap_copy_fims__QueryServiceDescriptionRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__QueryServiceDescriptionRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryServiceDescriptionRequestType);
	if (this->soap_out(soap, tag?tag:"fims:QueryServiceDescriptionRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryServiceDescriptionRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryServiceDescriptionRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryServiceDescriptionRequestType * SOAP_FMAC4 soap_get_fims__QueryServiceDescriptionRequestType(struct soap *soap, fims__QueryServiceDescriptionRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryServiceDescriptionRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryServiceDescriptionRequestType * SOAP_FMAC2 soap_instantiate_fims__QueryServiceDescriptionRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryServiceDescriptionRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryServiceDescriptionRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryServiceDescriptionRequestType);
		if (size)
			*size = sizeof(fims__QueryServiceDescriptionRequestType);
		((fims__QueryServiceDescriptionRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryServiceDescriptionRequestType, n);
		if (size)
			*size = n * sizeof(fims__QueryServiceDescriptionRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryServiceDescriptionRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryServiceDescriptionRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryServiceDescriptionRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryServiceDescriptionRequestType %p -> %p\n", q, p));
	*(fims__QueryServiceDescriptionRequestType*)p = *(fims__QueryServiceDescriptionRequestType*)q;
}

void fims__QueryJobResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryJobResponseType::jobs = NULL;
	this->fims__QueryJobResponseType::notReportedResultsNumber = NULL;
	this->fims__QueryJobResponseType::ExtensionGroup = NULL;
	this->fims__QueryJobResponseType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__QueryJobResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__JobsType(soap, &this->fims__QueryJobResponseType::jobs);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__QueryJobResponseType::notReportedResultsNumber);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__QueryJobResponseType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__QueryJobResponseType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__QueryJobResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobResponseType(struct soap *soap, const char *tag, int id, const fims__QueryJobResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobResponseType), type))
		return soap->error;
	if (soap_out_PointerTofims__JobsType(soap, "fims:jobs", -1, &(a->fims__QueryJobResponseType::jobs), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:notReportedResultsNumber", -1, &(a->fims__QueryJobResponseType::notReportedResultsNumber), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobResponseType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobResponseType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobResponseType * SOAP_FMAC4 soap_in_fims__QueryJobResponseType(struct soap *soap, const char *tag, fims__QueryJobResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobResponseType, sizeof(fims__QueryJobResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobs1 = 1;
	size_t soap_flag_notReportedResultsNumber1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobsType(soap, "fims:jobs", &(a->fims__QueryJobResponseType::jobs), "fims:JobsType"))
				{	soap_flag_jobs1--;
					continue;
				}
			if (soap_flag_notReportedResultsNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:notReportedResultsNumber", &(a->fims__QueryJobResponseType::notReportedResultsNumber), "xsd:nonNegativeInteger"))
				{	soap_flag_notReportedResultsNumber1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobResponseType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobResponseType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobResponseType, 0, sizeof(fims__QueryJobResponseType), 0, soap_copy_fims__QueryJobResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__QueryJobResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobResponseType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobResponseType * SOAP_FMAC4 soap_get_fims__QueryJobResponseType(struct soap *soap, fims__QueryJobResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobResponseType * SOAP_FMAC2 soap_instantiate_fims__QueryJobResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobResponseType);
		if (size)
			*size = sizeof(fims__QueryJobResponseType);
		((fims__QueryJobResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobResponseType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobResponseType %p -> %p\n", q, p));
	*(fims__QueryJobResponseType*)p = *(fims__QueryJobResponseType*)q;
}

void fims__QueryJobRequestByFilterType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryJobRequestType::soap_default(soap);
	this->fims__QueryJobRequestByFilterType::listFilter = NULL;
}

void fims__QueryJobRequestByFilterType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ListFilterType(soap, &this->fims__QueryJobRequestByFilterType::listFilter);
	this->fims__QueryJobRequestType::soap_serialize(soap);
#endif
}

int fims__QueryJobRequestByFilterType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobRequestByFilterType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobRequestByFilterType(struct soap *soap, const char *tag, int id, const fims__QueryJobRequestByFilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobRequestByFilterType), "fims:QueryJobRequestByFilterType"))
		return soap->error;
	if (soap_out_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", -1, &(a->fims__QueryJobRequestType::jobInfoSelection), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__QueryJobRequestByFilterType::listFilter)
	{	if (soap_out_PointerTofims__ListFilterType(soap, "fims:listFilter", -1, &a->fims__QueryJobRequestByFilterType::listFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:listFilter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobRequestByFilterType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobRequestByFilterType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobRequestByFilterType * SOAP_FMAC4 soap_in_fims__QueryJobRequestByFilterType(struct soap *soap, const char *tag, fims__QueryJobRequestByFilterType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobRequestByFilterType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobRequestByFilterType, sizeof(fims__QueryJobRequestByFilterType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobRequestByFilterType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobRequestByFilterType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobInfoSelection2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_listFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobInfoSelection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", &(a->fims__QueryJobRequestType::jobInfoSelection), "fims:JobInfoSelectionType"))
				{	soap_flag_jobInfoSelection2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_listFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ListFilterType(soap, "fims:listFilter", &(a->fims__QueryJobRequestByFilterType::listFilter), "fims:ListFilterType"))
				{	soap_flag_listFilter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobRequestByFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobRequestByFilterType, 0, sizeof(fims__QueryJobRequestByFilterType), 0, soap_copy_fims__QueryJobRequestByFilterType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobInfoSelection2 > 0 || soap_flag_listFilter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryJobRequestByFilterType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobRequestByFilterType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobRequestByFilterType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobRequestByFilterType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobRequestByFilterType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobRequestByFilterType * SOAP_FMAC4 soap_get_fims__QueryJobRequestByFilterType(struct soap *soap, fims__QueryJobRequestByFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobRequestByFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobRequestByFilterType * SOAP_FMAC2 soap_instantiate_fims__QueryJobRequestByFilterType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobRequestByFilterType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobRequestByFilterType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByFilterType);
		if (size)
			*size = sizeof(fims__QueryJobRequestByFilterType);
		((fims__QueryJobRequestByFilterType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByFilterType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobRequestByFilterType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobRequestByFilterType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobRequestByFilterType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobRequestByFilterType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobRequestByFilterType %p -> %p\n", q, p));
	*(fims__QueryJobRequestByFilterType*)p = *(fims__QueryJobRequestByFilterType*)q;
}

void fims__QueryJobRequestByIDType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__QueryJobRequestType::soap_default(soap);
	soap_default_std__vectorTemplateOffims__UID(soap, &this->fims__QueryJobRequestByIDType::jobID);
}

void fims__QueryJobRequestByIDType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOffims__UID(soap, &this->fims__QueryJobRequestByIDType::jobID);
	this->fims__QueryJobRequestType::soap_serialize(soap);
#endif
}

int fims__QueryJobRequestByIDType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobRequestByIDType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobRequestByIDType(struct soap *soap, const char *tag, int id, const fims__QueryJobRequestByIDType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobRequestByIDType), "fims:QueryJobRequestByIDType"))
		return soap->error;
	if (soap_out_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", -1, &(a->fims__QueryJobRequestType::jobInfoSelection), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOffims__UID(soap, "fims:jobID", -1, &(a->fims__QueryJobRequestByIDType::jobID), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobRequestByIDType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobRequestByIDType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobRequestByIDType * SOAP_FMAC4 soap_in_fims__QueryJobRequestByIDType(struct soap *soap, const char *tag, fims__QueryJobRequestByIDType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobRequestByIDType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobRequestByIDType, sizeof(fims__QueryJobRequestByIDType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobRequestByIDType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobRequestByIDType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobInfoSelection2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobInfoSelection2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", &(a->fims__QueryJobRequestType::jobInfoSelection), "fims:JobInfoSelectionType"))
				{	soap_flag_jobInfoSelection2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOffims__UID(soap, "fims:jobID", &(a->fims__QueryJobRequestByIDType::jobID), "fims:UID"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobRequestByIDType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobRequestByIDType, 0, sizeof(fims__QueryJobRequestByIDType), 0, soap_copy_fims__QueryJobRequestByIDType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobInfoSelection2 > 0 || a->fims__QueryJobRequestByIDType::jobID.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryJobRequestByIDType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobRequestByIDType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobRequestByIDType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobRequestByIDType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobRequestByIDType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobRequestByIDType * SOAP_FMAC4 soap_get_fims__QueryJobRequestByIDType(struct soap *soap, fims__QueryJobRequestByIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobRequestByIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobRequestByIDType * SOAP_FMAC2 soap_instantiate_fims__QueryJobRequestByIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobRequestByIDType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobRequestByIDType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByIDType);
		if (size)
			*size = sizeof(fims__QueryJobRequestByIDType);
		((fims__QueryJobRequestByIDType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByIDType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobRequestByIDType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobRequestByIDType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobRequestByIDType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobRequestByIDType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobRequestByIDType %p -> %p\n", q, p));
	*(fims__QueryJobRequestByIDType*)p = *(fims__QueryJobRequestByIDType*)q;
}

void fims__QueryJobRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__JobInfoSelectionType(soap, &this->fims__QueryJobRequestType::jobInfoSelection);
	this->fims__QueryJobRequestType::ExtensionGroup = NULL;
	this->fims__QueryJobRequestType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__QueryJobRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__QueryJobRequestType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__QueryJobRequestType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__QueryJobRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueryJobRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueryJobRequestType(struct soap *soap, const char *tag, int id, const fims__QueryJobRequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueryJobRequestType), type))
		return soap->error;
	if (soap_out_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", -1, &(a->fims__QueryJobRequestType::jobInfoSelection), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__QueryJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__QueryJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__QueryJobRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueryJobRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueryJobRequestType * SOAP_FMAC4 soap_in_fims__QueryJobRequestType(struct soap *soap, const char *tag, fims__QueryJobRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueryJobRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueryJobRequestType, sizeof(fims__QueryJobRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueryJobRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueryJobRequestType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobInfoSelection1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobInfoSelection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobInfoSelectionType(soap, "fims:jobInfoSelection", &(a->fims__QueryJobRequestType::jobInfoSelection), "fims:JobInfoSelectionType"))
				{	soap_flag_jobInfoSelection1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__QueryJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__QueryJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueryJobRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueryJobRequestType, 0, sizeof(fims__QueryJobRequestType), 0, soap_copy_fims__QueryJobRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobInfoSelection1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueryJobRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueryJobRequestType);
	if (this->soap_out(soap, tag?tag:"fims:QueryJobRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueryJobRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueryJobRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueryJobRequestType * SOAP_FMAC4 soap_get_fims__QueryJobRequestType(struct soap *soap, fims__QueryJobRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueryJobRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueryJobRequestType * SOAP_FMAC2 soap_instantiate_fims__QueryJobRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueryJobRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueryJobRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:QueryJobRequestByIDType"))
	{	cp->type = SOAP_TYPE_fims__QueryJobRequestByIDType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByIDType);
			if (size)
				*size = sizeof(fims__QueryJobRequestByIDType);
			((fims__QueryJobRequestByIDType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByIDType, n);
			if (size)
				*size = n * sizeof(fims__QueryJobRequestByIDType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueryJobRequestByIDType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueryJobRequestByIDType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:QueryJobRequestByFilterType"))
	{	cp->type = SOAP_TYPE_fims__QueryJobRequestByFilterType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestByFilterType);
			if (size)
				*size = sizeof(fims__QueryJobRequestByFilterType);
			((fims__QueryJobRequestByFilterType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestByFilterType, n);
			if (size)
				*size = n * sizeof(fims__QueryJobRequestByFilterType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueryJobRequestByFilterType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueryJobRequestByFilterType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueryJobRequestType);
		if (size)
			*size = sizeof(fims__QueryJobRequestType);
		((fims__QueryJobRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueryJobRequestType, n);
		if (size)
			*size = n * sizeof(fims__QueryJobRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueryJobRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueryJobRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueryJobRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueryJobRequestType %p -> %p\n", q, p));
	*(fims__QueryJobRequestType*)p = *(fims__QueryJobRequestType*)q;
}

void fims__ManageQueueResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ManageQueueResponseType::queue = NULL;
	this->fims__ManageQueueResponseType::ExtensionGroup = NULL;
	this->fims__ManageQueueResponseType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__ManageQueueResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__QueueType(soap, &this->fims__ManageQueueResponseType::queue);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageQueueResponseType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageQueueResponseType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageQueueResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageQueueResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageQueueResponseType(struct soap *soap, const char *tag, int id, const fims__ManageQueueResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageQueueResponseType), type))
		return soap->error;
	if (a->fims__ManageQueueResponseType::queue)
	{	if (soap_out_PointerTofims__QueueType(soap, "fims:queue", -1, &a->fims__ManageQueueResponseType::queue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:queue"))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageQueueResponseType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageQueueResponseType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageQueueResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageQueueResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageQueueResponseType * SOAP_FMAC4 soap_in_fims__ManageQueueResponseType(struct soap *soap, const char *tag, fims__ManageQueueResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageQueueResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageQueueResponseType, sizeof(fims__ManageQueueResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageQueueResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageQueueResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_queue1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueueType(soap, "fims:queue", &(a->fims__ManageQueueResponseType::queue), "fims:QueueType"))
				{	soap_flag_queue1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageQueueResponseType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageQueueResponseType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageQueueResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageQueueResponseType, 0, sizeof(fims__ManageQueueResponseType), 0, soap_copy_fims__ManageQueueResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_queue1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageQueueResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageQueueResponseType);
	if (this->soap_out(soap, tag?tag:"fims:ManageQueueResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageQueueResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageQueueResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageQueueResponseType * SOAP_FMAC4 soap_get_fims__ManageQueueResponseType(struct soap *soap, fims__ManageQueueResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageQueueResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageQueueResponseType * SOAP_FMAC2 soap_instantiate_fims__ManageQueueResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageQueueResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageQueueResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageQueueResponseType);
		if (size)
			*size = sizeof(fims__ManageQueueResponseType);
		((fims__ManageQueueResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageQueueResponseType, n);
		if (size)
			*size = n * sizeof(fims__ManageQueueResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageQueueResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageQueueResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageQueueResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageQueueResponseType %p -> %p\n", q, p));
	*(fims__ManageQueueResponseType*)p = *(fims__ManageQueueResponseType*)q;
}

void fims__ManageQueueRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ManageQueueRequestType::queueID = NULL;
	soap_default_fims__QueueCommandType(soap, &this->fims__ManageQueueRequestType::queueCommand);
	this->fims__ManageQueueRequestType::ExtensionGroup = NULL;
	this->fims__ManageQueueRequestType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__ManageQueueRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__UID(soap, &this->fims__ManageQueueRequestType::queueID);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageQueueRequestType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageQueueRequestType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageQueueRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageQueueRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageQueueRequestType(struct soap *soap, const char *tag, int id, const fims__ManageQueueRequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageQueueRequestType), type))
		return soap->error;
	if (soap_out_PointerTofims__UID(soap, "fims:queueID", -1, &(a->fims__ManageQueueRequestType::queueID), ""))
		return soap->error;
	if (soap_out_fims__QueueCommandType(soap, "fims:queueCommand", -1, &(a->fims__ManageQueueRequestType::queueCommand), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageQueueRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageQueueRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageQueueRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageQueueRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageQueueRequestType * SOAP_FMAC4 soap_in_fims__ManageQueueRequestType(struct soap *soap, const char *tag, fims__ManageQueueRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageQueueRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageQueueRequestType, sizeof(fims__ManageQueueRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageQueueRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageQueueRequestType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_queueID1 = 1;
	size_t soap_flag_queueCommand1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queueID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__UID(soap, "fims:queueID", &(a->fims__ManageQueueRequestType::queueID), "fims:UID"))
				{	soap_flag_queueID1--;
					continue;
				}
			if (soap_flag_queueCommand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__QueueCommandType(soap, "fims:queueCommand", &(a->fims__ManageQueueRequestType::queueCommand), "fims:QueueCommandType"))
				{	soap_flag_queueCommand1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageQueueRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageQueueRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageQueueRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageQueueRequestType, 0, sizeof(fims__ManageQueueRequestType), 0, soap_copy_fims__ManageQueueRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_queueCommand1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageQueueRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageQueueRequestType);
	if (this->soap_out(soap, tag?tag:"fims:ManageQueueRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageQueueRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageQueueRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageQueueRequestType * SOAP_FMAC4 soap_get_fims__ManageQueueRequestType(struct soap *soap, fims__ManageQueueRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageQueueRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageQueueRequestType * SOAP_FMAC2 soap_instantiate_fims__ManageQueueRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageQueueRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageQueueRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageQueueRequestType);
		if (size)
			*size = sizeof(fims__ManageQueueRequestType);
		((fims__ManageQueueRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageQueueRequestType, n);
		if (size)
			*size = n * sizeof(fims__ManageQueueRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageQueueRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageQueueRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageQueueRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageQueueRequestType %p -> %p\n", q, p));
	*(fims__ManageQueueRequestType*)p = *(fims__ManageQueueRequestType*)q;
}

void fims__ManageJobResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ManageJobResponseType::job = NULL;
	this->fims__ManageJobResponseType::ExtensionGroup = NULL;
	this->fims__ManageJobResponseType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__ManageJobResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__JobType(soap, &this->fims__ManageJobResponseType::job);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageJobResponseType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageJobResponseType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageJobResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageJobResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageJobResponseType(struct soap *soap, const char *tag, int id, const fims__ManageJobResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageJobResponseType), type))
		return soap->error;
	if (a->fims__ManageJobResponseType::job)
	{	if (soap_out_PointerTofims__JobType(soap, "fims:job", -1, &a->fims__ManageJobResponseType::job, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:job"))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageJobResponseType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageJobResponseType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageJobResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageJobResponseType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageJobResponseType * SOAP_FMAC4 soap_in_fims__ManageJobResponseType(struct soap *soap, const char *tag, fims__ManageJobResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageJobResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageJobResponseType, sizeof(fims__ManageJobResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageJobResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageJobResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_job1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobType(soap, "fims:job", &(a->fims__ManageJobResponseType::job), "fims:JobType"))
				{	soap_flag_job1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageJobResponseType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageJobResponseType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageJobResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageJobResponseType, 0, sizeof(fims__ManageJobResponseType), 0, soap_copy_fims__ManageJobResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_job1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageJobResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageJobResponseType);
	if (this->soap_out(soap, tag?tag:"fims:ManageJobResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageJobResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageJobResponseType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageJobResponseType * SOAP_FMAC4 soap_get_fims__ManageJobResponseType(struct soap *soap, fims__ManageJobResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageJobResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageJobResponseType * SOAP_FMAC2 soap_instantiate_fims__ManageJobResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageJobResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageJobResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageJobResponseType);
		if (size)
			*size = sizeof(fims__ManageJobResponseType);
		((fims__ManageJobResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageJobResponseType, n);
		if (size)
			*size = n * sizeof(fims__ManageJobResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageJobResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageJobResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageJobResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageJobResponseType %p -> %p\n", q, p));
	*(fims__ManageJobResponseType*)p = *(fims__ManageJobResponseType*)q;
}

void fims__ManageJobRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__UID(soap, &this->fims__ManageJobRequestType::jobID);
	soap_default_fims__JobCommandType(soap, &this->fims__ManageJobRequestType::jobCommand);
	this->fims__ManageJobRequestType::priority = NULL;
	this->fims__ManageJobRequestType::ExtensionGroup = NULL;
	this->fims__ManageJobRequestType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__ManageJobRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ManageJobRequestType::jobID, SOAP_TYPE_fims__UID);
	soap_serialize_fims__UID(soap, &this->fims__ManageJobRequestType::jobID);
	soap_serialize_PointerTofims__PriorityType(soap, &this->fims__ManageJobRequestType::priority);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ManageJobRequestType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ManageJobRequestType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__ManageJobRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ManageJobRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ManageJobRequestType(struct soap *soap, const char *tag, int id, const fims__ManageJobRequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ManageJobRequestType), type))
		return soap->error;
	if (soap_out_fims__UID(soap, "fims:jobID", -1, &(a->fims__ManageJobRequestType::jobID), ""))
		return soap->error;
	if (soap_out_fims__JobCommandType(soap, "fims:jobCommand", -1, &(a->fims__ManageJobRequestType::jobCommand), ""))
		return soap->error;
	if (soap_out_PointerTofims__PriorityType(soap, "fims:priority", -1, &(a->fims__ManageJobRequestType::priority), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ManageJobRequestType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ManageJobRequestType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ManageJobRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ManageJobRequestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ManageJobRequestType * SOAP_FMAC4 soap_in_fims__ManageJobRequestType(struct soap *soap, const char *tag, fims__ManageJobRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ManageJobRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ManageJobRequestType, sizeof(fims__ManageJobRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ManageJobRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ManageJobRequestType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobID1 = 1;
	size_t soap_flag_jobCommand1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__UID(soap, "fims:jobID", &(a->fims__ManageJobRequestType::jobID), "fims:UID"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap_flag_jobCommand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__JobCommandType(soap, "fims:jobCommand", &(a->fims__ManageJobRequestType::jobCommand), "fims:JobCommandType"))
				{	soap_flag_jobCommand1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__PriorityType(soap, "fims:priority", &(a->fims__ManageJobRequestType::priority), "fims:PriorityType"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ManageJobRequestType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ManageJobRequestType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ManageJobRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ManageJobRequestType, 0, sizeof(fims__ManageJobRequestType), 0, soap_copy_fims__ManageJobRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobID1 > 0 || soap_flag_jobCommand1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ManageJobRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ManageJobRequestType);
	if (this->soap_out(soap, tag?tag:"fims:ManageJobRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ManageJobRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ManageJobRequestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ManageJobRequestType * SOAP_FMAC4 soap_get_fims__ManageJobRequestType(struct soap *soap, fims__ManageJobRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ManageJobRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ManageJobRequestType * SOAP_FMAC2 soap_instantiate_fims__ManageJobRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ManageJobRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ManageJobRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ManageJobRequestType);
		if (size)
			*size = sizeof(fims__ManageJobRequestType);
		((fims__ManageJobRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ManageJobRequestType, n);
		if (size)
			*size = n * sizeof(fims__ManageJobRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ManageJobRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ManageJobRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ManageJobRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ManageJobRequestType %p -> %p\n", q, p));
	*(fims__ManageJobRequestType*)p = *(fims__ManageJobRequestType*)q;
}

void fims__StartJobByLatestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartJobType::soap_default(soap);
}

void fims__StartJobByLatestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fims__StartJobType::soap_serialize(soap);
#endif
}

int fims__StartJobByLatestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobByLatestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobByLatestType(struct soap *soap, const char *tag, int id, const fims__StartJobByLatestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobByLatestType), "fims:StartJobByLatestType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobByLatestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobByLatestType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobByLatestType * SOAP_FMAC4 soap_in_fims__StartJobByLatestType(struct soap *soap, const char *tag, fims__StartJobByLatestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobByLatestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobByLatestType, sizeof(fims__StartJobByLatestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobByLatestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobByLatestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobByLatestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobByLatestType, 0, sizeof(fims__StartJobByLatestType), 0, soap_copy_fims__StartJobByLatestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartJobByLatestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobByLatestType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobByLatestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobByLatestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobByLatestType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobByLatestType * SOAP_FMAC4 soap_get_fims__StartJobByLatestType(struct soap *soap, fims__StartJobByLatestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobByLatestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobByLatestType * SOAP_FMAC2 soap_instantiate_fims__StartJobByLatestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobByLatestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobByLatestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByLatestType);
		if (size)
			*size = sizeof(fims__StartJobByLatestType);
		((fims__StartJobByLatestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByLatestType, n);
		if (size)
			*size = n * sizeof(fims__StartJobByLatestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobByLatestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobByLatestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobByLatestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobByLatestType %p -> %p\n", q, p));
	*(fims__StartJobByLatestType*)p = *(fims__StartJobByLatestType*)q;
}

void fims__StartJobByTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartJobType::soap_default(soap);
	soap_default_time(soap, &this->fims__StartJobByTimeType::time);
}

void fims__StartJobByTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__StartJobByTimeType::time, SOAP_TYPE_time);
	this->fims__StartJobType::soap_serialize(soap);
#endif
}

int fims__StartJobByTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobByTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobByTimeType(struct soap *soap, const char *tag, int id, const fims__StartJobByTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobByTimeType), "fims:StartJobByTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "fims:time", -1, &(a->fims__StartJobByTimeType::time), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobByTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobByTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobByTimeType * SOAP_FMAC4 soap_in_fims__StartJobByTimeType(struct soap *soap, const char *tag, fims__StartJobByTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobByTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobByTimeType, sizeof(fims__StartJobByTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobByTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobByTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "fims:time", &(a->fims__StartJobByTimeType::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobByTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobByTimeType, 0, sizeof(fims__StartJobByTimeType), 0, soap_copy_fims__StartJobByTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StartJobByTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobByTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobByTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobByTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobByTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobByTimeType * SOAP_FMAC4 soap_get_fims__StartJobByTimeType(struct soap *soap, fims__StartJobByTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobByTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobByTimeType * SOAP_FMAC2 soap_instantiate_fims__StartJobByTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobByTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobByTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByTimeType);
		if (size)
			*size = sizeof(fims__StartJobByTimeType);
		((fims__StartJobByTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByTimeType, n);
		if (size)
			*size = n * sizeof(fims__StartJobByTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobByTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobByTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobByTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobByTimeType %p -> %p\n", q, p));
	*(fims__StartJobByTimeType*)p = *(fims__StartJobByTimeType*)q;
}

void fims__StartJobByNoWaitType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartJobType::soap_default(soap);
}

void fims__StartJobByNoWaitType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->fims__StartJobType::soap_serialize(soap);
#endif
}

int fims__StartJobByNoWaitType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobByNoWaitType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobByNoWaitType(struct soap *soap, const char *tag, int id, const fims__StartJobByNoWaitType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobByNoWaitType), "fims:StartJobByNoWaitType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobByNoWaitType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobByNoWaitType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobByNoWaitType * SOAP_FMAC4 soap_in_fims__StartJobByNoWaitType(struct soap *soap, const char *tag, fims__StartJobByNoWaitType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobByNoWaitType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobByNoWaitType, sizeof(fims__StartJobByNoWaitType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobByNoWaitType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobByNoWaitType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobByNoWaitType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobByNoWaitType, 0, sizeof(fims__StartJobByNoWaitType), 0, soap_copy_fims__StartJobByNoWaitType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartJobByNoWaitType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobByNoWaitType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobByNoWaitType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobByNoWaitType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobByNoWaitType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobByNoWaitType * SOAP_FMAC4 soap_get_fims__StartJobByNoWaitType(struct soap *soap, fims__StartJobByNoWaitType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobByNoWaitType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobByNoWaitType * SOAP_FMAC2 soap_instantiate_fims__StartJobByNoWaitType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobByNoWaitType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobByNoWaitType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByNoWaitType);
		if (size)
			*size = sizeof(fims__StartJobByNoWaitType);
		((fims__StartJobByNoWaitType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByNoWaitType, n);
		if (size)
			*size = n * sizeof(fims__StartJobByNoWaitType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobByNoWaitType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobByNoWaitType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobByNoWaitType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobByNoWaitType %p -> %p\n", q, p));
	*(fims__StartJobByNoWaitType*)p = *(fims__StartJobByNoWaitType*)q;
}

void fims__StartJobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__StartJobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StartJobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartJobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartJobType(struct soap *soap, const char *tag, int id, const fims__StartJobType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartJobType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartJobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartJobType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartJobType * SOAP_FMAC4 soap_in_fims__StartJobType(struct soap *soap, const char *tag, fims__StartJobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartJobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartJobType, sizeof(fims__StartJobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartJobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartJobType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartJobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartJobType, 0, sizeof(fims__StartJobType), 0, soap_copy_fims__StartJobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartJobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartJobType);
	if (this->soap_out(soap, tag?tag:"fims:StartJobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartJobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartJobType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartJobType * SOAP_FMAC4 soap_get_fims__StartJobType(struct soap *soap, fims__StartJobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartJobType * SOAP_FMAC2 soap_instantiate_fims__StartJobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartJobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartJobType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:StartJobByNoWaitType"))
	{	cp->type = SOAP_TYPE_fims__StartJobByNoWaitType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByNoWaitType);
			if (size)
				*size = sizeof(fims__StartJobByNoWaitType);
			((fims__StartJobByNoWaitType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByNoWaitType, n);
			if (size)
				*size = n * sizeof(fims__StartJobByNoWaitType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartJobByNoWaitType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartJobByNoWaitType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartJobByTimeType"))
	{	cp->type = SOAP_TYPE_fims__StartJobByTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByTimeType);
			if (size)
				*size = sizeof(fims__StartJobByTimeType);
			((fims__StartJobByTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByTimeType, n);
			if (size)
				*size = n * sizeof(fims__StartJobByTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartJobByTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartJobByTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartJobByLatestType"))
	{	cp->type = SOAP_TYPE_fims__StartJobByLatestType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartJobByLatestType);
			if (size)
				*size = sizeof(fims__StartJobByLatestType);
			((fims__StartJobByLatestType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobByLatestType, n);
			if (size)
				*size = n * sizeof(fims__StartJobByLatestType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartJobByLatestType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartJobByLatestType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartJobType);
		if (size)
			*size = sizeof(fims__StartJobType);
		((fims__StartJobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartJobType, n);
		if (size)
			*size = n * sizeof(fims__StartJobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartJobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartJobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartJobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartJobType %p -> %p\n", q, p));
	*(fims__StartJobType*)p = *(fims__StartJobType*)q;
}

void fims__StopProcessByOpenEndType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByOpenEndType::actualStopTime = NULL;
	this->fims__StopProcessByOpenEndType::actualStopMark = NULL;
}

void fims__StopProcessByOpenEndType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StopProcessByOpenEndType::actualStopTime);
	soap_serialize_PointerTofims__TimeType(soap, &this->fims__StopProcessByOpenEndType::actualStopMark);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByOpenEndType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByOpenEndType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByOpenEndType(struct soap *soap, const char *tag, int id, const fims__StopProcessByOpenEndType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByOpenEndType), "fims:StopProcessByOpenEndType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStopTime", -1, &(a->fims__StopProcessByOpenEndType::actualStopTime), ""))
		return soap->error;
	if (soap_out_PointerTofims__TimeType(soap, "fims:actualStopMark", -1, &(a->fims__StopProcessByOpenEndType::actualStopMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByOpenEndType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByOpenEndType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByOpenEndType * SOAP_FMAC4 soap_in_fims__StopProcessByOpenEndType(struct soap *soap, const char *tag, fims__StopProcessByOpenEndType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByOpenEndType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByOpenEndType, sizeof(fims__StopProcessByOpenEndType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByOpenEndType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByOpenEndType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStopTime1 = 1;
	size_t soap_flag_actualStopMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStopTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStopTime", &(a->fims__StopProcessByOpenEndType::actualStopTime), "xsd:dateTime"))
				{	soap_flag_actualStopTime1--;
					continue;
				}
			if (soap_flag_actualStopMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__TimeType(soap, "fims:actualStopMark", &(a->fims__StopProcessByOpenEndType::actualStopMark), "fims:TimeType"))
				{	soap_flag_actualStopMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByOpenEndType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByOpenEndType, 0, sizeof(fims__StopProcessByOpenEndType), 0, soap_copy_fims__StopProcessByOpenEndType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StopProcessByOpenEndType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByOpenEndType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByOpenEndType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByOpenEndType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByOpenEndType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByOpenEndType * SOAP_FMAC4 soap_get_fims__StopProcessByOpenEndType(struct soap *soap, fims__StopProcessByOpenEndType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByOpenEndType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByOpenEndType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByOpenEndType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByOpenEndType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByOpenEndType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByOpenEndType);
		if (size)
			*size = sizeof(fims__StopProcessByOpenEndType);
		((fims__StopProcessByOpenEndType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByOpenEndType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByOpenEndType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByOpenEndType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByOpenEndType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByOpenEndType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByOpenEndType %p -> %p\n", q, p));
	*(fims__StopProcessByOpenEndType*)p = *(fims__StopProcessByOpenEndType*)q;
}

void fims__StopProcessByServiceDefinedTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByServiceDefinedTimeType::actualStopTime = NULL;
	this->fims__StopProcessByServiceDefinedTimeType::actualStopMark = NULL;
}

void fims__StopProcessByServiceDefinedTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StopProcessByServiceDefinedTimeType::actualStopTime);
	soap_serialize_PointerTofims__TimeType(soap, &this->fims__StopProcessByServiceDefinedTimeType::actualStopMark);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByServiceDefinedTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByServiceDefinedTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, int id, const fims__StopProcessByServiceDefinedTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType), "fims:StopProcessByServiceDefinedTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStopTime", -1, &(a->fims__StopProcessByServiceDefinedTimeType::actualStopTime), ""))
		return soap->error;
	if (soap_out_PointerTofims__TimeType(soap, "fims:actualStopMark", -1, &(a->fims__StopProcessByServiceDefinedTimeType::actualStopMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByServiceDefinedTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByServiceDefinedTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_in_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, fims__StopProcessByServiceDefinedTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByServiceDefinedTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType, sizeof(fims__StopProcessByServiceDefinedTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByServiceDefinedTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStopTime1 = 1;
	size_t soap_flag_actualStopMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStopTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStopTime", &(a->fims__StopProcessByServiceDefinedTimeType::actualStopTime), "xsd:dateTime"))
				{	soap_flag_actualStopTime1--;
					continue;
				}
			if (soap_flag_actualStopMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__TimeType(soap, "fims:actualStopMark", &(a->fims__StopProcessByServiceDefinedTimeType::actualStopMark), "fims:TimeType"))
				{	soap_flag_actualStopMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByServiceDefinedTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType, 0, sizeof(fims__StopProcessByServiceDefinedTimeType), 0, soap_copy_fims__StopProcessByServiceDefinedTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StopProcessByServiceDefinedTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByServiceDefinedTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByServiceDefinedTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByServiceDefinedTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_get_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, fims__StopProcessByServiceDefinedTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByServiceDefinedTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByServiceDefinedTimeType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByServiceDefinedTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByServiceDefinedTimeType);
		if (size)
			*size = sizeof(fims__StopProcessByServiceDefinedTimeType);
		((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByServiceDefinedTimeType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByServiceDefinedTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByServiceDefinedTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByServiceDefinedTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByServiceDefinedTimeType %p -> %p\n", q, p));
	*(fims__StopProcessByServiceDefinedTimeType*)p = *(fims__StopProcessByServiceDefinedTimeType*)q;
}

void fims__StopProcessByTimeMarkType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByTimeMarkType::timeMark = NULL;
}

void fims__StopProcessByTimeMarkType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__TimeType(soap, &this->fims__StopProcessByTimeMarkType::timeMark);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByTimeMarkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByTimeMarkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByTimeMarkType(struct soap *soap, const char *tag, int id, const fims__StopProcessByTimeMarkType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByTimeMarkType), "fims:StopProcessByTimeMarkType"))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__StopProcessByTimeMarkType::timeMark)
	{	if (soap_out_PointerTofims__TimeType(soap, "fims:timeMark", -1, &a->fims__StopProcessByTimeMarkType::timeMark, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:timeMark"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByTimeMarkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByTimeMarkType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByTimeMarkType * SOAP_FMAC4 soap_in_fims__StopProcessByTimeMarkType(struct soap *soap, const char *tag, fims__StopProcessByTimeMarkType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByTimeMarkType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByTimeMarkType, sizeof(fims__StopProcessByTimeMarkType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByTimeMarkType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByTimeMarkType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_timeMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_timeMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__TimeType(soap, "fims:timeMark", &(a->fims__StopProcessByTimeMarkType::timeMark), "fims:TimeType"))
				{	soap_flag_timeMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByTimeMarkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByTimeMarkType, 0, sizeof(fims__StopProcessByTimeMarkType), 0, soap_copy_fims__StopProcessByTimeMarkType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeMark1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StopProcessByTimeMarkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByTimeMarkType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByTimeMarkType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByTimeMarkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByTimeMarkType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByTimeMarkType * SOAP_FMAC4 soap_get_fims__StopProcessByTimeMarkType(struct soap *soap, fims__StopProcessByTimeMarkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByTimeMarkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByTimeMarkType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByTimeMarkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByTimeMarkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByTimeMarkType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeMarkType);
		if (size)
			*size = sizeof(fims__StopProcessByTimeMarkType);
		((fims__StopProcessByTimeMarkType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeMarkType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByTimeMarkType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByTimeMarkType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByTimeMarkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByTimeMarkType %p -> %p\n", q, p));
	*(fims__StopProcessByTimeMarkType*)p = *(fims__StopProcessByTimeMarkType*)q;
}

void fims__StopProcessByDurationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	this->fims__StopProcessByDurationType::duration = NULL;
}

void fims__StopProcessByDurationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__DurationType(soap, &this->fims__StopProcessByDurationType::duration);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByDurationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByDurationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByDurationType(struct soap *soap, const char *tag, int id, const fims__StopProcessByDurationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByDurationType), "fims:StopProcessByDurationType"))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__StopProcessByDurationType::duration)
	{	if (soap_out_PointerTofims__DurationType(soap, "fims:duration", -1, &a->fims__StopProcessByDurationType::duration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:duration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByDurationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByDurationType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByDurationType * SOAP_FMAC4 soap_in_fims__StopProcessByDurationType(struct soap *soap, const char *tag, fims__StopProcessByDurationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByDurationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByDurationType, sizeof(fims__StopProcessByDurationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByDurationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByDurationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_duration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__DurationType(soap, "fims:duration", &(a->fims__StopProcessByDurationType::duration), "fims:DurationType"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByDurationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByDurationType, 0, sizeof(fims__StopProcessByDurationType), 0, soap_copy_fims__StopProcessByDurationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_duration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StopProcessByDurationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByDurationType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByDurationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByDurationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByDurationType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByDurationType * SOAP_FMAC4 soap_get_fims__StopProcessByDurationType(struct soap *soap, fims__StopProcessByDurationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByDurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByDurationType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByDurationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByDurationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByDurationType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByDurationType);
		if (size)
			*size = sizeof(fims__StopProcessByDurationType);
		((fims__StopProcessByDurationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByDurationType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByDurationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByDurationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByDurationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByDurationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByDurationType %p -> %p\n", q, p));
	*(fims__StopProcessByDurationType*)p = *(fims__StopProcessByDurationType*)q;
}

void fims__StopProcessByTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StopProcessType::soap_default(soap);
	soap_default_time(soap, &this->fims__StopProcessByTimeType::time);
}

void fims__StopProcessByTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__StopProcessByTimeType::time, SOAP_TYPE_time);
	this->fims__StopProcessType::soap_serialize(soap);
#endif
}

int fims__StopProcessByTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessByTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessByTimeType(struct soap *soap, const char *tag, int id, const fims__StopProcessByTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessByTimeType), "fims:StopProcessByTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "fims:time", -1, &(a->fims__StopProcessByTimeType::time), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessByTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessByTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessByTimeType * SOAP_FMAC4 soap_in_fims__StopProcessByTimeType(struct soap *soap, const char *tag, fims__StopProcessByTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessByTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessByTimeType, sizeof(fims__StopProcessByTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessByTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessByTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "fims:time", &(a->fims__StopProcessByTimeType::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessByTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessByTimeType, 0, sizeof(fims__StopProcessByTimeType), 0, soap_copy_fims__StopProcessByTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StopProcessByTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessByTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessByTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessByTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessByTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessByTimeType * SOAP_FMAC4 soap_get_fims__StopProcessByTimeType(struct soap *soap, fims__StopProcessByTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessByTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessByTimeType * SOAP_FMAC2 soap_instantiate_fims__StopProcessByTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessByTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessByTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeType);
		if (size)
			*size = sizeof(fims__StopProcessByTimeType);
		((fims__StopProcessByTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessByTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessByTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessByTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessByTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessByTimeType %p -> %p\n", q, p));
	*(fims__StopProcessByTimeType*)p = *(fims__StopProcessByTimeType*)q;
}

void fims__StopProcessType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__StopProcessType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StopProcessType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StopProcessType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StopProcessType(struct soap *soap, const char *tag, int id, const fims__StopProcessType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StopProcessType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StopProcessType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StopProcessType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StopProcessType * SOAP_FMAC4 soap_in_fims__StopProcessType(struct soap *soap, const char *tag, fims__StopProcessType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StopProcessType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StopProcessType, sizeof(fims__StopProcessType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StopProcessType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StopProcessType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StopProcessType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StopProcessType, 0, sizeof(fims__StopProcessType), 0, soap_copy_fims__StopProcessType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StopProcessType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StopProcessType);
	if (this->soap_out(soap, tag?tag:"fims:StopProcessType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StopProcessType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StopProcessType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StopProcessType * SOAP_FMAC4 soap_get_fims__StopProcessType(struct soap *soap, fims__StopProcessType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StopProcessType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StopProcessType * SOAP_FMAC2 soap_instantiate_fims__StopProcessType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StopProcessType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StopProcessType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByTimeType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeType);
			if (size)
				*size = sizeof(fims__StopProcessByTimeType);
			((fims__StopProcessByTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByDurationType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByDurationType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByDurationType);
			if (size)
				*size = sizeof(fims__StopProcessByDurationType);
			((fims__StopProcessByDurationType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByDurationType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByDurationType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByDurationType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByDurationType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByTimeMarkType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByTimeMarkType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByTimeMarkType);
			if (size)
				*size = sizeof(fims__StopProcessByTimeMarkType);
			((fims__StopProcessByTimeMarkType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByTimeMarkType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByTimeMarkType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByTimeMarkType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByServiceDefinedTimeType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByServiceDefinedTimeType);
			if (size)
				*size = sizeof(fims__StopProcessByServiceDefinedTimeType);
			((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByServiceDefinedTimeType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByServiceDefinedTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByServiceDefinedTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StopProcessByOpenEndType"))
	{	cp->type = SOAP_TYPE_fims__StopProcessByOpenEndType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessByOpenEndType);
			if (size)
				*size = sizeof(fims__StopProcessByOpenEndType);
			((fims__StopProcessByOpenEndType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessByOpenEndType, n);
			if (size)
				*size = n * sizeof(fims__StopProcessByOpenEndType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StopProcessByOpenEndType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StopProcessByOpenEndType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StopProcessType);
		if (size)
			*size = sizeof(fims__StopProcessType);
		((fims__StopProcessType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StopProcessType, n);
		if (size)
			*size = n * sizeof(fims__StopProcessType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StopProcessType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StopProcessType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StopProcessType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StopProcessType %p -> %p\n", q, p));
	*(fims__StopProcessType*)p = *(fims__StopProcessType*)q;
}

void fims__StartProcessByServiceDefinedTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	this->fims__StartProcessByServiceDefinedTimeType::actualStartTime = NULL;
	this->fims__StartProcessByServiceDefinedTimeType::actualStartMark = NULL;
}

void fims__StartProcessByServiceDefinedTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StartProcessByServiceDefinedTimeType::actualStartTime);
	soap_serialize_PointerTofims__TimeType(soap, &this->fims__StartProcessByServiceDefinedTimeType::actualStartMark);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByServiceDefinedTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByServiceDefinedTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, int id, const fims__StartProcessByServiceDefinedTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType), "fims:StartProcessByServiceDefinedTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStartTime", -1, &(a->fims__StartProcessByServiceDefinedTimeType::actualStartTime), ""))
		return soap->error;
	if (soap_out_PointerTofims__TimeType(soap, "fims:actualStartMark", -1, &(a->fims__StartProcessByServiceDefinedTimeType::actualStartMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByServiceDefinedTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByServiceDefinedTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_in_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, const char *tag, fims__StartProcessByServiceDefinedTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByServiceDefinedTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType, sizeof(fims__StartProcessByServiceDefinedTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByServiceDefinedTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStartTime1 = 1;
	size_t soap_flag_actualStartMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStartTime", &(a->fims__StartProcessByServiceDefinedTimeType::actualStartTime), "xsd:dateTime"))
				{	soap_flag_actualStartTime1--;
					continue;
				}
			if (soap_flag_actualStartMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__TimeType(soap, "fims:actualStartMark", &(a->fims__StartProcessByServiceDefinedTimeType::actualStartMark), "fims:TimeType"))
				{	soap_flag_actualStartMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByServiceDefinedTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType, 0, sizeof(fims__StartProcessByServiceDefinedTimeType), 0, soap_copy_fims__StartProcessByServiceDefinedTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartProcessByServiceDefinedTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByServiceDefinedTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByServiceDefinedTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByServiceDefinedTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByServiceDefinedTimeType * SOAP_FMAC4 soap_get_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, fims__StartProcessByServiceDefinedTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByServiceDefinedTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByServiceDefinedTimeType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByServiceDefinedTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByServiceDefinedTimeType);
		if (size)
			*size = sizeof(fims__StartProcessByServiceDefinedTimeType);
		((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByServiceDefinedTimeType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByServiceDefinedTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByServiceDefinedTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByServiceDefinedTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByServiceDefinedTimeType %p -> %p\n", q, p));
	*(fims__StartProcessByServiceDefinedTimeType*)p = *(fims__StartProcessByServiceDefinedTimeType*)q;
}

void fims__StartProcessByTimeMarkType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	this->fims__StartProcessByTimeMarkType::timeMark = NULL;
}

void fims__StartProcessByTimeMarkType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__TimeType(soap, &this->fims__StartProcessByTimeMarkType::timeMark);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByTimeMarkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByTimeMarkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByTimeMarkType(struct soap *soap, const char *tag, int id, const fims__StartProcessByTimeMarkType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByTimeMarkType), "fims:StartProcessByTimeMarkType"))
		return soap->error;
	/* transient soap skipped */
	if (a->fims__StartProcessByTimeMarkType::timeMark)
	{	if (soap_out_PointerTofims__TimeType(soap, "fims:timeMark", -1, &a->fims__StartProcessByTimeMarkType::timeMark, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:timeMark"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByTimeMarkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByTimeMarkType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByTimeMarkType * SOAP_FMAC4 soap_in_fims__StartProcessByTimeMarkType(struct soap *soap, const char *tag, fims__StartProcessByTimeMarkType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByTimeMarkType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByTimeMarkType, sizeof(fims__StartProcessByTimeMarkType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByTimeMarkType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByTimeMarkType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_timeMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_timeMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__TimeType(soap, "fims:timeMark", &(a->fims__StartProcessByTimeMarkType::timeMark), "fims:TimeType"))
				{	soap_flag_timeMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByTimeMarkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByTimeMarkType, 0, sizeof(fims__StartProcessByTimeMarkType), 0, soap_copy_fims__StartProcessByTimeMarkType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_timeMark1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StartProcessByTimeMarkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByTimeMarkType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByTimeMarkType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByTimeMarkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByTimeMarkType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByTimeMarkType * SOAP_FMAC4 soap_get_fims__StartProcessByTimeMarkType(struct soap *soap, fims__StartProcessByTimeMarkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByTimeMarkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByTimeMarkType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByTimeMarkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByTimeMarkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByTimeMarkType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeMarkType);
		if (size)
			*size = sizeof(fims__StartProcessByTimeMarkType);
		((fims__StartProcessByTimeMarkType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeMarkType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByTimeMarkType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByTimeMarkType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByTimeMarkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByTimeMarkType %p -> %p\n", q, p));
	*(fims__StartProcessByTimeMarkType*)p = *(fims__StartProcessByTimeMarkType*)q;
}

void fims__StartProcessByTimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	soap_default_time(soap, &this->fims__StartProcessByTimeType::time);
}

void fims__StartProcessByTimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__StartProcessByTimeType::time, SOAP_TYPE_time);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByTimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByTimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByTimeType(struct soap *soap, const char *tag, int id, const fims__StartProcessByTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByTimeType), "fims:StartProcessByTimeType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_time(soap, "fims:time", -1, &(a->fims__StartProcessByTimeType::time), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByTimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByTimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByTimeType * SOAP_FMAC4 soap_in_fims__StartProcessByTimeType(struct soap *soap, const char *tag, fims__StartProcessByTimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByTimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByTimeType, sizeof(fims__StartProcessByTimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByTimeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByTimeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "fims:time", &(a->fims__StartProcessByTimeType::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByTimeType, 0, sizeof(fims__StartProcessByTimeType), 0, soap_copy_fims__StartProcessByTimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__StartProcessByTimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByTimeType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByTimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByTimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByTimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByTimeType * SOAP_FMAC4 soap_get_fims__StartProcessByTimeType(struct soap *soap, fims__StartProcessByTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByTimeType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByTimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByTimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByTimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeType);
		if (size)
			*size = sizeof(fims__StartProcessByTimeType);
		((fims__StartProcessByTimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByTimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByTimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByTimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByTimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByTimeType %p -> %p\n", q, p));
	*(fims__StartProcessByTimeType*)p = *(fims__StartProcessByTimeType*)q;
}

void fims__StartProcessByNoWaitType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__StartProcessType::soap_default(soap);
	this->fims__StartProcessByNoWaitType::actualStartTime = NULL;
	this->fims__StartProcessByNoWaitType::actualStartMark = NULL;
}

void fims__StartProcessByNoWaitType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__StartProcessByNoWaitType::actualStartTime);
	soap_serialize_PointerTofims__TimeType(soap, &this->fims__StartProcessByNoWaitType::actualStartMark);
	this->fims__StartProcessType::soap_serialize(soap);
#endif
}

int fims__StartProcessByNoWaitType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessByNoWaitType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessByNoWaitType(struct soap *soap, const char *tag, int id, const fims__StartProcessByNoWaitType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessByNoWaitType), "fims:StartProcessByNoWaitType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:actualStartTime", -1, &(a->fims__StartProcessByNoWaitType::actualStartTime), ""))
		return soap->error;
	if (soap_out_PointerTofims__TimeType(soap, "fims:actualStartMark", -1, &(a->fims__StartProcessByNoWaitType::actualStartMark), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessByNoWaitType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessByNoWaitType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessByNoWaitType * SOAP_FMAC4 soap_in_fims__StartProcessByNoWaitType(struct soap *soap, const char *tag, fims__StartProcessByNoWaitType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessByNoWaitType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessByNoWaitType, sizeof(fims__StartProcessByNoWaitType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessByNoWaitType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessByNoWaitType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_actualStartTime1 = 1;
	size_t soap_flag_actualStartMark1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_actualStartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:actualStartTime", &(a->fims__StartProcessByNoWaitType::actualStartTime), "xsd:dateTime"))
				{	soap_flag_actualStartTime1--;
					continue;
				}
			if (soap_flag_actualStartMark1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__TimeType(soap, "fims:actualStartMark", &(a->fims__StartProcessByNoWaitType::actualStartMark), "fims:TimeType"))
				{	soap_flag_actualStartMark1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessByNoWaitType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessByNoWaitType, 0, sizeof(fims__StartProcessByNoWaitType), 0, soap_copy_fims__StartProcessByNoWaitType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartProcessByNoWaitType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessByNoWaitType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessByNoWaitType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessByNoWaitType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessByNoWaitType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessByNoWaitType * SOAP_FMAC4 soap_get_fims__StartProcessByNoWaitType(struct soap *soap, fims__StartProcessByNoWaitType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessByNoWaitType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessByNoWaitType * SOAP_FMAC2 soap_instantiate_fims__StartProcessByNoWaitType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessByNoWaitType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessByNoWaitType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByNoWaitType);
		if (size)
			*size = sizeof(fims__StartProcessByNoWaitType);
		((fims__StartProcessByNoWaitType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByNoWaitType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessByNoWaitType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessByNoWaitType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessByNoWaitType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessByNoWaitType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessByNoWaitType %p -> %p\n", q, p));
	*(fims__StartProcessByNoWaitType*)p = *(fims__StartProcessByNoWaitType*)q;
}

void fims__StartProcessType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void fims__StartProcessType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StartProcessType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StartProcessType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StartProcessType(struct soap *soap, const char *tag, int id, const fims__StartProcessType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__StartProcessType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__StartProcessType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StartProcessType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StartProcessType * SOAP_FMAC4 soap_in_fims__StartProcessType(struct soap *soap, const char *tag, fims__StartProcessType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__StartProcessType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StartProcessType, sizeof(fims__StartProcessType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StartProcessType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__StartProcessType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__StartProcessType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__StartProcessType, 0, sizeof(fims__StartProcessType), 0, soap_copy_fims__StartProcessType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__StartProcessType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StartProcessType);
	if (this->soap_out(soap, tag?tag:"fims:StartProcessType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StartProcessType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StartProcessType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StartProcessType * SOAP_FMAC4 soap_get_fims__StartProcessType(struct soap *soap, fims__StartProcessType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StartProcessType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StartProcessType * SOAP_FMAC2 soap_instantiate_fims__StartProcessType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StartProcessType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StartProcessType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByNoWaitType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByNoWaitType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByNoWaitType);
			if (size)
				*size = sizeof(fims__StartProcessByNoWaitType);
			((fims__StartProcessByNoWaitType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByNoWaitType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByNoWaitType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByNoWaitType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByNoWaitType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByTimeType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeType);
			if (size)
				*size = sizeof(fims__StartProcessByTimeType);
			((fims__StartProcessByTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByTimeType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByTimeMarkType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByTimeMarkType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByTimeMarkType);
			if (size)
				*size = sizeof(fims__StartProcessByTimeMarkType);
			((fims__StartProcessByTimeMarkType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByTimeMarkType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByTimeMarkType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByTimeMarkType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByTimeMarkType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:StartProcessByServiceDefinedTimeType"))
	{	cp->type = SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessByServiceDefinedTimeType);
			if (size)
				*size = sizeof(fims__StartProcessByServiceDefinedTimeType);
			((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessByServiceDefinedTimeType, n);
			if (size)
				*size = n * sizeof(fims__StartProcessByServiceDefinedTimeType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__StartProcessByServiceDefinedTimeType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__StartProcessByServiceDefinedTimeType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StartProcessType);
		if (size)
			*size = sizeof(fims__StartProcessType);
		((fims__StartProcessType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StartProcessType, n);
		if (size)
			*size = n * sizeof(fims__StartProcessType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StartProcessType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StartProcessType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StartProcessType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StartProcessType %p -> %p\n", q, p));
	*(fims__StartProcessType*)p = *(fims__StartProcessType*)q;
}

void fims__HashFunctionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__HashFunctionTypes(soap, &this->fims__HashFunctionType::__item);
	this->fims__HashFunctionType::typeLabel = NULL;
	this->fims__HashFunctionType::typeDefinition = NULL;
	this->fims__HashFunctionType::typeLink = NULL;
	this->fims__HashFunctionType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__HashFunctionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__HashFunctionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__HashFunctionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__HashFunctionType(struct soap *soap, const char *tag, int id, const fims__HashFunctionType *a, const char *type)
{
	if (((fims__HashFunctionType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__HashFunctionType*)a)->typeLabel->c_str()), 2);
	if (((fims__HashFunctionType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__HashFunctionType*)a)->typeDefinition->c_str()), 2);
	if (((fims__HashFunctionType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__HashFunctionType*)a)->typeLink->c_str()), 2);
	if (((fims__HashFunctionType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__HashFunctionType*)a)->__anyAttribute, 1);
	return soap_out_fims__HashFunctionTypes(soap, tag, id, &a->fims__HashFunctionType::__item, "");
}

void *fims__HashFunctionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__HashFunctionType(soap, tag, this, type);
}

SOAP_FMAC3 fims__HashFunctionType * SOAP_FMAC4 soap_in_fims__HashFunctionType(struct soap *soap, const char *tag, fims__HashFunctionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__HashFunctionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__HashFunctionType, sizeof(fims__HashFunctionType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__HashFunctionType)
			return (fims__HashFunctionType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__HashFunctionType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__HashFunctionType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__HashFunctionType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__HashFunctionType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__HashFunctionType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__HashFunctionType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__HashFunctionType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__HashFunctionType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__HashFunctionType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__HashFunctionType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_fims__HashFunctionTypes(soap, tag, &(a->fims__HashFunctionType::__item), "fims:HashFunctionType"))
		return NULL;
	return a;
}

int fims__HashFunctionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__HashFunctionType);
	if (this->soap_out(soap, tag?tag:"fims:HashFunctionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__HashFunctionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__HashFunctionType(soap, this, tag, type);
}

SOAP_FMAC3 fims__HashFunctionType * SOAP_FMAC4 soap_get_fims__HashFunctionType(struct soap *soap, fims__HashFunctionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__HashFunctionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__HashFunctionType * SOAP_FMAC2 soap_instantiate_fims__HashFunctionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__HashFunctionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__HashFunctionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__HashFunctionType);
		if (size)
			*size = sizeof(fims__HashFunctionType);
		((fims__HashFunctionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__HashFunctionType, n);
		if (size)
			*size = n * sizeof(fims__HashFunctionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__HashFunctionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__HashFunctionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__HashFunctionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__HashFunctionType %p -> %p\n", q, p));
	*(fims__HashFunctionType*)p = *(fims__HashFunctionType*)q;
}

void fims__StorageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__StorageTypes(soap, &this->fims__StorageType::__item);
	this->fims__StorageType::typeLabel = NULL;
	this->fims__StorageType::typeDefinition = NULL;
	this->fims__StorageType::typeLink = NULL;
	this->fims__StorageType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__StorageType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__StorageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__StorageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__StorageType(struct soap *soap, const char *tag, int id, const fims__StorageType *a, const char *type)
{
	if (((fims__StorageType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__StorageType*)a)->typeLabel->c_str()), 2);
	if (((fims__StorageType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__StorageType*)a)->typeDefinition->c_str()), 2);
	if (((fims__StorageType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__StorageType*)a)->typeLink->c_str()), 2);
	if (((fims__StorageType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__StorageType*)a)->__anyAttribute, 1);
	return soap_out_fims__StorageTypes(soap, tag, id, &a->fims__StorageType::__item, "");
}

void *fims__StorageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__StorageType(soap, tag, this, type);
}

SOAP_FMAC3 fims__StorageType * SOAP_FMAC4 soap_in_fims__StorageType(struct soap *soap, const char *tag, fims__StorageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__StorageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__StorageType, sizeof(fims__StorageType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__StorageType)
			return (fims__StorageType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__StorageType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__StorageType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__StorageType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__StorageType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__StorageType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__StorageType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__StorageType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__StorageType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__StorageType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__StorageType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_fims__StorageTypes(soap, tag, &(a->fims__StorageType::__item), "fims:StorageType"))
		return NULL;
	return a;
}

int fims__StorageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__StorageType);
	if (this->soap_out(soap, tag?tag:"fims:StorageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__StorageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__StorageType(soap, this, tag, type);
}

SOAP_FMAC3 fims__StorageType * SOAP_FMAC4 soap_get_fims__StorageType(struct soap *soap, fims__StorageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__StorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__StorageType * SOAP_FMAC2 soap_instantiate_fims__StorageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__StorageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__StorageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__StorageType);
		if (size)
			*size = sizeof(fims__StorageType);
		((fims__StorageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__StorageType, n);
		if (size)
			*size = n * sizeof(fims__StorageType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__StorageType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__StorageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__StorageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__StorageType %p -> %p\n", q, p));
	*(fims__StorageType*)p = *(fims__StorageType*)q;
}

void fims__TimeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__TimeType::__union_TimeType = 0;
	/* transient soap skipped */
}

void fims__TimeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__fims__union_TimeType(soap, this->fims__TimeType::__union_TimeType, &this->fims__TimeType::union_TimeType);
	/* transient soap skipped */
#endif
}

int fims__TimeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__TimeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TimeType(struct soap *soap, const char *tag, int id, const fims__TimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__TimeType), type))
		return soap->error;
	if (soap_out__fims__union_TimeType(soap, a->fims__TimeType::__union_TimeType, &a->fims__TimeType::union_TimeType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__TimeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__TimeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__TimeType * SOAP_FMAC4 soap_in_fims__TimeType(struct soap *soap, const char *tag, fims__TimeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__TimeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__TimeType, sizeof(fims__TimeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__fims__union_TimeType(soap, &a->__union_TimeType, &a->union_TimeType))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__TimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__TimeType, 0, sizeof(fims__TimeType), 0, soap_copy_fims__TimeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__TimeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__TimeType);
	if (this->soap_out(soap, tag?tag:"fims:TimeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__TimeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__TimeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__TimeType * SOAP_FMAC4 soap_get_fims__TimeType(struct soap *soap, fims__TimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__TimeType * SOAP_FMAC2 soap_instantiate_fims__TimeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__TimeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__TimeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__TimeType);
		if (size)
			*size = sizeof(fims__TimeType);
		((fims__TimeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__TimeType, n);
		if (size)
			*size = n * sizeof(fims__TimeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__TimeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__TimeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__TimeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__TimeType %p -> %p\n", q, p));
	*(fims__TimeType*)p = *(fims__TimeType*)q;
}

void fims__DurationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__DurationType::__union_DurationType = 0;
	/* transient soap skipped */
}

void fims__DurationType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__fims__union_DurationType(soap, this->fims__DurationType::__union_DurationType, &this->fims__DurationType::union_DurationType);
	/* transient soap skipped */
#endif
}

int fims__DurationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DurationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DurationType(struct soap *soap, const char *tag, int id, const fims__DurationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DurationType), type))
		return soap->error;
	if (soap_out__fims__union_DurationType(soap, a->fims__DurationType::__union_DurationType, &a->fims__DurationType::union_DurationType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__DurationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DurationType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DurationType * SOAP_FMAC4 soap_in_fims__DurationType(struct soap *soap, const char *tag, fims__DurationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DurationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DurationType, sizeof(fims__DurationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && !*soap->href))
	{
		if (!soap_in__fims__union_DurationType(soap, &a->__union_DurationType, &a->union_DurationType))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DurationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DurationType, 0, sizeof(fims__DurationType), 0, soap_copy_fims__DurationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__DurationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DurationType);
	if (this->soap_out(soap, tag?tag:"fims:DurationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DurationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DurationType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DurationType * SOAP_FMAC4 soap_get_fims__DurationType(struct soap *soap, fims__DurationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DurationType * SOAP_FMAC2 soap_instantiate_fims__DurationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DurationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DurationType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DurationType);
		if (size)
			*size = sizeof(fims__DurationType);
		((fims__DurationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DurationType, n);
		if (size)
			*size = n * sizeof(fims__DurationType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DurationType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DurationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DurationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DurationType %p -> %p\n", q, p));
	*(fims__DurationType*)p = *(fims__DurationType*)q;
}

void fims__ProcessedInfoByFramesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ProcessedInfoType::soap_default(soap);
	soap_default_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoByFramesType::processedFramesCount);
}

void fims__ProcessedInfoByFramesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ProcessedInfoByFramesType::processedFramesCount, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoByFramesType::processedFramesCount);
	this->fims__ProcessedInfoType::soap_serialize(soap);
#endif
}

int fims__ProcessedInfoByFramesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProcessedInfoByFramesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProcessedInfoByFramesType(struct soap *soap, const char *tag, int id, const fims__ProcessedInfoByFramesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProcessedInfoByFramesType), "fims:ProcessedInfoByFramesType"))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", -1, &(a->fims__ProcessedInfoType::percentageProcessedCompleted), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:processedFramesCount", -1, &(a->fims__ProcessedInfoByFramesType::processedFramesCount), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ProcessedInfoByFramesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProcessedInfoByFramesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProcessedInfoByFramesType * SOAP_FMAC4 soap_in_fims__ProcessedInfoByFramesType(struct soap *soap, const char *tag, fims__ProcessedInfoByFramesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProcessedInfoByFramesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProcessedInfoByFramesType, sizeof(fims__ProcessedInfoByFramesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProcessedInfoByFramesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProcessedInfoByFramesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_percentageProcessedCompleted2 = 1;
	size_t soap_flag_processedFramesCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentageProcessedCompleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", &(a->fims__ProcessedInfoType::percentageProcessedCompleted), "xsd:nonNegativeInteger"))
				{	soap_flag_percentageProcessedCompleted2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_processedFramesCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:processedFramesCount", &(a->fims__ProcessedInfoByFramesType::processedFramesCount), "xsd:nonNegativeInteger"))
				{	soap_flag_processedFramesCount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProcessedInfoByFramesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProcessedInfoByFramesType, 0, sizeof(fims__ProcessedInfoByFramesType), 0, soap_copy_fims__ProcessedInfoByFramesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentageProcessedCompleted2 > 0 || soap_flag_processedFramesCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProcessedInfoByFramesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProcessedInfoByFramesType);
	if (this->soap_out(soap, tag?tag:"fims:ProcessedInfoByFramesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProcessedInfoByFramesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProcessedInfoByFramesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProcessedInfoByFramesType * SOAP_FMAC4 soap_get_fims__ProcessedInfoByFramesType(struct soap *soap, fims__ProcessedInfoByFramesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProcessedInfoByFramesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProcessedInfoByFramesType * SOAP_FMAC2 soap_instantiate_fims__ProcessedInfoByFramesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProcessedInfoByFramesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProcessedInfoByFramesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByFramesType);
		if (size)
			*size = sizeof(fims__ProcessedInfoByFramesType);
		((fims__ProcessedInfoByFramesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByFramesType, n);
		if (size)
			*size = n * sizeof(fims__ProcessedInfoByFramesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProcessedInfoByFramesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProcessedInfoByFramesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProcessedInfoByFramesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProcessedInfoByFramesType %p -> %p\n", q, p));
	*(fims__ProcessedInfoByFramesType*)p = *(fims__ProcessedInfoByFramesType*)q;
}

void fims__ProcessedInfoByBytesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ProcessedInfoType::soap_default(soap);
	soap_default_unsignedLONG64(soap, &this->fims__ProcessedInfoByBytesType::processedBytesCount);
}

void fims__ProcessedInfoByBytesType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ProcessedInfoByBytesType::processedBytesCount, SOAP_TYPE_unsignedLONG64);
	this->fims__ProcessedInfoType::soap_serialize(soap);
#endif
}

int fims__ProcessedInfoByBytesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProcessedInfoByBytesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProcessedInfoByBytesType(struct soap *soap, const char *tag, int id, const fims__ProcessedInfoByBytesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProcessedInfoByBytesType), "fims:ProcessedInfoByBytesType"))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", -1, &(a->fims__ProcessedInfoType::percentageProcessedCompleted), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_unsignedLONG64(soap, "fims:processedBytesCount", -1, &(a->fims__ProcessedInfoByBytesType::processedBytesCount), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ProcessedInfoByBytesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProcessedInfoByBytesType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProcessedInfoByBytesType * SOAP_FMAC4 soap_in_fims__ProcessedInfoByBytesType(struct soap *soap, const char *tag, fims__ProcessedInfoByBytesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProcessedInfoByBytesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProcessedInfoByBytesType, sizeof(fims__ProcessedInfoByBytesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProcessedInfoByBytesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProcessedInfoByBytesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_percentageProcessedCompleted2 = 1;
	size_t soap_flag_processedBytesCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentageProcessedCompleted2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", &(a->fims__ProcessedInfoType::percentageProcessedCompleted), "xsd:nonNegativeInteger"))
				{	soap_flag_percentageProcessedCompleted2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_processedBytesCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "fims:processedBytesCount", &(a->fims__ProcessedInfoByBytesType::processedBytesCount), "xsd:unsignedLong"))
				{	soap_flag_processedBytesCount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProcessedInfoByBytesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProcessedInfoByBytesType, 0, sizeof(fims__ProcessedInfoByBytesType), 0, soap_copy_fims__ProcessedInfoByBytesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentageProcessedCompleted2 > 0 || soap_flag_processedBytesCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProcessedInfoByBytesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProcessedInfoByBytesType);
	if (this->soap_out(soap, tag?tag:"fims:ProcessedInfoByBytesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProcessedInfoByBytesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProcessedInfoByBytesType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProcessedInfoByBytesType * SOAP_FMAC4 soap_get_fims__ProcessedInfoByBytesType(struct soap *soap, fims__ProcessedInfoByBytesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProcessedInfoByBytesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProcessedInfoByBytesType * SOAP_FMAC2 soap_instantiate_fims__ProcessedInfoByBytesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProcessedInfoByBytesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProcessedInfoByBytesType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByBytesType);
		if (size)
			*size = sizeof(fims__ProcessedInfoByBytesType);
		((fims__ProcessedInfoByBytesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByBytesType, n);
		if (size)
			*size = n * sizeof(fims__ProcessedInfoByBytesType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProcessedInfoByBytesType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProcessedInfoByBytesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProcessedInfoByBytesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProcessedInfoByBytesType %p -> %p\n", q, p));
	*(fims__ProcessedInfoByBytesType*)p = *(fims__ProcessedInfoByBytesType*)q;
}

void fims__ProcessedInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoType::percentageProcessedCompleted);
	/* transient soap skipped */
}

void fims__ProcessedInfoType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__ProcessedInfoType::percentageProcessedCompleted, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->fims__ProcessedInfoType::percentageProcessedCompleted);
	/* transient soap skipped */
#endif
}

int fims__ProcessedInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProcessedInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProcessedInfoType(struct soap *soap, const char *tag, int id, const fims__ProcessedInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProcessedInfoType), type))
		return soap->error;
	if (soap_out_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", -1, &(a->fims__ProcessedInfoType::percentageProcessedCompleted), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ProcessedInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProcessedInfoType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProcessedInfoType * SOAP_FMAC4 soap_in_fims__ProcessedInfoType(struct soap *soap, const char *tag, fims__ProcessedInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProcessedInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProcessedInfoType, sizeof(fims__ProcessedInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProcessedInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProcessedInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_percentageProcessedCompleted1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentageProcessedCompleted1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__nonNegativeInteger(soap, "fims:percentageProcessedCompleted", &(a->fims__ProcessedInfoType::percentageProcessedCompleted), "xsd:nonNegativeInteger"))
				{	soap_flag_percentageProcessedCompleted1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProcessedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProcessedInfoType, 0, sizeof(fims__ProcessedInfoType), 0, soap_copy_fims__ProcessedInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentageProcessedCompleted1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProcessedInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProcessedInfoType);
	if (this->soap_out(soap, tag?tag:"fims:ProcessedInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProcessedInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProcessedInfoType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProcessedInfoType * SOAP_FMAC4 soap_get_fims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProcessedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProcessedInfoType * SOAP_FMAC2 soap_instantiate_fims__ProcessedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProcessedInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProcessedInfoType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ProcessedInfoByBytesType"))
	{	cp->type = SOAP_TYPE_fims__ProcessedInfoByBytesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByBytesType);
			if (size)
				*size = sizeof(fims__ProcessedInfoByBytesType);
			((fims__ProcessedInfoByBytesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByBytesType, n);
			if (size)
				*size = n * sizeof(fims__ProcessedInfoByBytesType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProcessedInfoByBytesType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProcessedInfoByBytesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ProcessedInfoByFramesType"))
	{	cp->type = SOAP_TYPE_fims__ProcessedInfoByFramesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoByFramesType);
			if (size)
				*size = sizeof(fims__ProcessedInfoByFramesType);
			((fims__ProcessedInfoByFramesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoByFramesType, n);
			if (size)
				*size = n * sizeof(fims__ProcessedInfoByFramesType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProcessedInfoByFramesType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProcessedInfoByFramesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProcessedInfoType);
		if (size)
			*size = sizeof(fims__ProcessedInfoType);
		((fims__ProcessedInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProcessedInfoType, n);
		if (size)
			*size = n * sizeof(fims__ProcessedInfoType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProcessedInfoType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProcessedInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProcessedInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProcessedInfoType %p -> %p\n", q, p));
	*(fims__ProcessedInfoType*)p = *(fims__ProcessedInfoType*)q;
}

void fims__EditUnitNumberType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->fims__EditUnitNumberType::__item);
	soap_default_xsd__positiveInteger(soap, &this->fims__EditUnitNumberType::editRate);
	soap_default_xsd__positiveInteger(soap, &this->fims__EditUnitNumberType::factorNumerator);
	soap_default_xsd__positiveInteger(soap, &this->fims__EditUnitNumberType::factorDenominator);
	/* transient soap skipped */
}

void fims__EditUnitNumberType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__EditUnitNumberType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__EditUnitNumberType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__EditUnitNumberType(struct soap *soap, const char *tag, int id, const fims__EditUnitNumberType *a, const char *type)
{
	soap_set_attr(soap, "editRate", soap_wchar2s(soap, ((fims__EditUnitNumberType*)a)->editRate.c_str()), 2);
	soap_set_attr(soap, "factorNumerator", soap_wchar2s(soap, ((fims__EditUnitNumberType*)a)->factorNumerator.c_str()), 2);
	soap_set_attr(soap, "factorDenominator", soap_wchar2s(soap, ((fims__EditUnitNumberType*)a)->factorDenominator.c_str()), 2);
	return soap_out_LONG64(soap, tag, id, &a->fims__EditUnitNumberType::__item, "");
}

void *fims__EditUnitNumberType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__EditUnitNumberType(soap, tag, this, type);
}

SOAP_FMAC3 fims__EditUnitNumberType * SOAP_FMAC4 soap_in_fims__EditUnitNumberType(struct soap *soap, const char *tag, fims__EditUnitNumberType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__EditUnitNumberType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__EditUnitNumberType, sizeof(fims__EditUnitNumberType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__EditUnitNumberType)
			return (fims__EditUnitNumberType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "editRate", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fims__EditUnitNumberType*)a)->editRate.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "factorNumerator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fims__EditUnitNumberType*)a)->factorNumerator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "factorDenominator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fims__EditUnitNumberType*)a)->factorDenominator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_LONG64(soap, tag, &(a->fims__EditUnitNumberType::__item), "fims:EditUnitNumberType"))
		return NULL;
	return a;
}

int fims__EditUnitNumberType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__EditUnitNumberType);
	if (this->soap_out(soap, tag?tag:"fims:EditUnitNumberType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__EditUnitNumberType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__EditUnitNumberType(soap, this, tag, type);
}

SOAP_FMAC3 fims__EditUnitNumberType * SOAP_FMAC4 soap_get_fims__EditUnitNumberType(struct soap *soap, fims__EditUnitNumberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__EditUnitNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__EditUnitNumberType * SOAP_FMAC2 soap_instantiate_fims__EditUnitNumberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__EditUnitNumberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__EditUnitNumberType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__EditUnitNumberType);
		if (size)
			*size = sizeof(fims__EditUnitNumberType);
		((fims__EditUnitNumberType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__EditUnitNumberType, n);
		if (size)
			*size = n * sizeof(fims__EditUnitNumberType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__EditUnitNumberType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__EditUnitNumberType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__EditUnitNumberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__EditUnitNumberType %p -> %p\n", q, p));
	*(fims__EditUnitNumberType*)p = *(fims__EditUnitNumberType*)q;
}

void fims__HashType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__HashType::hashFunction = NULL;
	this->fims__HashType::value.xsd__hexBinary::soap_default(soap);
	/* transient soap skipped */
}

void fims__HashType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__HashFunctionType(soap, &this->fims__HashType::hashFunction);
	this->fims__HashType::value.soap_serialize(soap);
	/* transient soap skipped */
#endif
}

int fims__HashType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__HashType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__HashType(struct soap *soap, const char *tag, int id, const fims__HashType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__HashType), type))
		return soap->error;
	if (a->fims__HashType::hashFunction)
	{	if (soap_out_PointerTofims__HashFunctionType(soap, "fims:hashFunction", -1, &a->fims__HashType::hashFunction, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "fims:hashFunction"))
		return soap->error;
	if ((a->fims__HashType::value).soap_out(soap, "fims:value", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__HashType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__HashType(soap, tag, this, type);
}

SOAP_FMAC3 fims__HashType * SOAP_FMAC4 soap_in_fims__HashType(struct soap *soap, const char *tag, fims__HashType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__HashType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__HashType, sizeof(fims__HashType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__HashType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__HashType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_hashFunction1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hashFunction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__HashFunctionType(soap, "fims:hashFunction", &(a->fims__HashType::hashFunction), "fims:HashFunctionType"))
				{	soap_flag_hashFunction1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fims__HashType::value).soap_in(soap, "fims:value", "xsd:hexBinary"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__HashType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__HashType, 0, sizeof(fims__HashType), 0, soap_copy_fims__HashType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hashFunction1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__HashType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__HashType);
	if (this->soap_out(soap, tag?tag:"fims:HashType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__HashType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__HashType(soap, this, tag, type);
}

SOAP_FMAC3 fims__HashType * SOAP_FMAC4 soap_get_fims__HashType(struct soap *soap, fims__HashType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__HashType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__HashType * SOAP_FMAC2 soap_instantiate_fims__HashType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__HashType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__HashType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__HashType);
		if (size)
			*size = sizeof(fims__HashType);
		((fims__HashType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__HashType, n);
		if (size)
			*size = n * sizeof(fims__HashType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__HashType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__HashType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__HashType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__HashType %p -> %p\n", q, p));
	*(fims__HashType*)p = *(fims__HashType*)q;
}

void fims__RationalType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->fims__RationalType::__item);
	soap_default_xsd__positiveInteger(soap, &this->fims__RationalType::numerator);
	soap_default_xsd__positiveInteger(soap, &this->fims__RationalType::denominator);
	/* transient soap skipped */
}

void fims__RationalType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__RationalType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__RationalType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__RationalType(struct soap *soap, const char *tag, int id, const fims__RationalType *a, const char *type)
{
	soap_set_attr(soap, "numerator", soap_wchar2s(soap, ((fims__RationalType*)a)->numerator.c_str()), 2);
	soap_set_attr(soap, "denominator", soap_wchar2s(soap, ((fims__RationalType*)a)->denominator.c_str()), 2);
	return soap_out_LONG64(soap, tag, id, &a->fims__RationalType::__item, "");
}

void *fims__RationalType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__RationalType(soap, tag, this, type);
}

SOAP_FMAC3 fims__RationalType * SOAP_FMAC4 soap_in_fims__RationalType(struct soap *soap, const char *tag, fims__RationalType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__RationalType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__RationalType, sizeof(fims__RationalType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__RationalType)
			return (fims__RationalType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "numerator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fims__RationalType*)a)->numerator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "denominator", 1);
		if (t)
		{	wchar_t *s;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			((fims__RationalType*)a)->denominator.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_LONG64(soap, tag, &(a->fims__RationalType::__item), "fims:RationalType"))
		return NULL;
	return a;
}

int fims__RationalType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__RationalType);
	if (this->soap_out(soap, tag?tag:"fims:RationalType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__RationalType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__RationalType(soap, this, tag, type);
}

SOAP_FMAC3 fims__RationalType * SOAP_FMAC4 soap_get_fims__RationalType(struct soap *soap, fims__RationalType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__RationalType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__RationalType * SOAP_FMAC2 soap_instantiate_fims__RationalType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__RationalType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__RationalType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__RationalType);
		if (size)
			*size = sizeof(fims__RationalType);
		((fims__RationalType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__RationalType, n);
		if (size)
			*size = n * sizeof(fims__RationalType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__RationalType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__RationalType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__RationalType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__RationalType %p -> %p\n", q, p));
	*(fims__RationalType*)p = *(fims__RationalType*)q;
}

void fims__LengthType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->fims__LengthType::__item);
	this->fims__LengthType::unit = NULL;
	/* transient soap skipped */
}

void fims__LengthType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__LengthType::__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->fims__LengthType::__item);
	/* transient soap skipped */
#endif
}

int fims__LengthType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__LengthType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__LengthType(struct soap *soap, const char *tag, int id, const fims__LengthType *a, const char *type)
{
	if (((fims__LengthType*)a)->unit)
		soap_set_attr(soap, "unit", soap_wchar2s(soap, ((fims__LengthType*)a)->unit->c_str()), 2);
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->fims__LengthType::__item, "");
}

void *fims__LengthType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__LengthType(soap, tag, this, type);
}

SOAP_FMAC3 fims__LengthType * SOAP_FMAC4 soap_in_fims__LengthType(struct soap *soap, const char *tag, fims__LengthType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__LengthType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__LengthType, sizeof(fims__LengthType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__LengthType)
			return (fims__LengthType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "unit", 0);
		if (t)
		{
			if (!(((fims__LengthType*)a)->unit = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__LengthType*)a)->unit = soap_new_std__wstring(soap, -1);
				((fims__LengthType*)a)->unit->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->fims__LengthType::__item), "fims:LengthType"))
		return NULL;
	return a;
}

int fims__LengthType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__LengthType);
	if (this->soap_out(soap, tag?tag:"fims:LengthType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__LengthType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__LengthType(soap, this, tag, type);
}

SOAP_FMAC3 fims__LengthType * SOAP_FMAC4 soap_get_fims__LengthType(struct soap *soap, fims__LengthType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__LengthType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__LengthType * SOAP_FMAC2 soap_instantiate_fims__LengthType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__LengthType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__LengthType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__LengthType);
		if (size)
			*size = sizeof(fims__LengthType);
		((fims__LengthType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__LengthType, n);
		if (size)
			*size = n * sizeof(fims__LengthType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__LengthType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__LengthType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__LengthType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__LengthType %p -> %p\n", q, p));
	*(fims__LengthType*)p = *(fims__LengthType*)q;
}

void fims__TechnicalAttributeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fims__TechnicalAttributeType::__item);
	this->fims__TechnicalAttributeType::typeLabel = NULL;
	this->fims__TechnicalAttributeType::typeDefinition = NULL;
	this->fims__TechnicalAttributeType::typeLink = NULL;
	this->fims__TechnicalAttributeType::formatLabel = NULL;
	this->fims__TechnicalAttributeType::formatDefinition = NULL;
	this->fims__TechnicalAttributeType::formatLink = NULL;
	/* transient soap skipped */
}

void fims__TechnicalAttributeType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__TechnicalAttributeType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__TechnicalAttributeType::__item);
	/* transient soap skipped */
#endif
}

int fims__TechnicalAttributeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__TechnicalAttributeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TechnicalAttributeType(struct soap *soap, const char *tag, int id, const fims__TechnicalAttributeType *a, const char *type)
{
	if (((fims__TechnicalAttributeType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->typeLabel->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->typeDefinition->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->typeLink->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->formatLabel->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->formatDefinition->c_str()), 2);
	if (((fims__TechnicalAttributeType*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((fims__TechnicalAttributeType*)a)->formatLink->c_str()), 2);
	return soap_out_std__wstring(soap, tag, id, &a->fims__TechnicalAttributeType::__item, "");
}

void *fims__TechnicalAttributeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__TechnicalAttributeType(soap, tag, this, type);
}

SOAP_FMAC3 fims__TechnicalAttributeType * SOAP_FMAC4 soap_in_fims__TechnicalAttributeType(struct soap *soap, const char *tag, fims__TechnicalAttributeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__TechnicalAttributeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__TechnicalAttributeType, sizeof(fims__TechnicalAttributeType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__TechnicalAttributeType)
			return (fims__TechnicalAttributeType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((fims__TechnicalAttributeType*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__TechnicalAttributeType*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((fims__TechnicalAttributeType*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_std__wstring(soap, tag, &(a->fims__TechnicalAttributeType::__item), "fims:TechnicalAttributeType"))
		return NULL;
	return a;
}

int fims__TechnicalAttributeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__TechnicalAttributeType);
	if (this->soap_out(soap, tag?tag:"fims:TechnicalAttributeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__TechnicalAttributeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__TechnicalAttributeType(soap, this, tag, type);
}

SOAP_FMAC3 fims__TechnicalAttributeType * SOAP_FMAC4 soap_get_fims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TechnicalAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__TechnicalAttributeType * SOAP_FMAC2 soap_instantiate_fims__TechnicalAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__TechnicalAttributeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__TechnicalAttributeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__TechnicalAttributeType);
		if (size)
			*size = sizeof(fims__TechnicalAttributeType);
		((fims__TechnicalAttributeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__TechnicalAttributeType, n);
		if (size)
			*size = n * sizeof(fims__TechnicalAttributeType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__TechnicalAttributeType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__TechnicalAttributeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__TechnicalAttributeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__TechnicalAttributeType %p -> %p\n", q, p));
	*(fims__TechnicalAttributeType*)p = *(fims__TechnicalAttributeType*)q;
}

void fims__TransformAtomType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__TransformAtomType::videoFormat = NULL;
	this->fims__TransformAtomType::audioFormat = NULL;
	this->fims__TransformAtomType::containerFormat = NULL;
	this->fims__TransformAtomType::ExtensionGroup = NULL;
	this->fims__TransformAtomType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__TransformAtomType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__VideoFormatType(soap, &this->fims__TransformAtomType::videoFormat);
	soap_serialize_PointerTofims__AudioFormatType(soap, &this->fims__TransformAtomType::audioFormat);
	soap_serialize_PointerTofims__ContainerFormatType(soap, &this->fims__TransformAtomType::containerFormat);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__TransformAtomType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__TransformAtomType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__TransformAtomType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__TransformAtomType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TransformAtomType(struct soap *soap, const char *tag, int id, const fims__TransformAtomType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__TransformAtomType), type))
		return soap->error;
	if (soap_out_PointerTofims__VideoFormatType(soap, "fims:videoFormat", -1, &(a->fims__TransformAtomType::videoFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__AudioFormatType(soap, "fims:audioFormat", -1, &(a->fims__TransformAtomType::audioFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", -1, &(a->fims__TransformAtomType::containerFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__TransformAtomType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__TransformAtomType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__TransformAtomType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__TransformAtomType(soap, tag, this, type);
}

SOAP_FMAC3 fims__TransformAtomType * SOAP_FMAC4 soap_in_fims__TransformAtomType(struct soap *soap, const char *tag, fims__TransformAtomType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__TransformAtomType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__TransformAtomType, sizeof(fims__TransformAtomType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__TransformAtomType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__TransformAtomType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_videoFormat1 = 1;
	size_t soap_flag_audioFormat1 = 1;
	size_t soap_flag_containerFormat1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_videoFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__VideoFormatType(soap, "fims:videoFormat", &(a->fims__TransformAtomType::videoFormat), "fims:VideoFormatType"))
				{	soap_flag_videoFormat1--;
					continue;
				}
			if (soap_flag_audioFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AudioFormatType(soap, "fims:audioFormat", &(a->fims__TransformAtomType::audioFormat), "fims:AudioFormatType"))
				{	soap_flag_audioFormat1--;
					continue;
				}
			if (soap_flag_containerFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ContainerFormatType(soap, "fims:containerFormat", &(a->fims__TransformAtomType::containerFormat), "fims:ContainerFormatType"))
				{	soap_flag_containerFormat1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__TransformAtomType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__TransformAtomType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__TransformAtomType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__TransformAtomType, 0, sizeof(fims__TransformAtomType), 0, soap_copy_fims__TransformAtomType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__TransformAtomType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__TransformAtomType);
	if (this->soap_out(soap, tag?tag:"fims:TransformAtomType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__TransformAtomType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__TransformAtomType(soap, this, tag, type);
}

SOAP_FMAC3 fims__TransformAtomType * SOAP_FMAC4 soap_get_fims__TransformAtomType(struct soap *soap, fims__TransformAtomType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TransformAtomType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__TransformAtomType * SOAP_FMAC2 soap_instantiate_fims__TransformAtomType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__TransformAtomType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__TransformAtomType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__TransformAtomType);
		if (size)
			*size = sizeof(fims__TransformAtomType);
		((fims__TransformAtomType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__TransformAtomType, n);
		if (size)
			*size = n * sizeof(fims__TransformAtomType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__TransformAtomType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__TransformAtomType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__TransformAtomType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__TransformAtomType %p -> %p\n", q, p));
	*(fims__TransformAtomType*)p = *(fims__TransformAtomType*)q;
}

void fims__TransferAtomType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->fims__TransferAtomType::destination);
	this->fims__TransferAtomType::ExtensionGroup = NULL;
	this->fims__TransferAtomType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__TransferAtomType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__TransferAtomType::destination, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->fims__TransferAtomType::destination);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__TransferAtomType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__TransferAtomType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__TransferAtomType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__TransferAtomType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__TransferAtomType(struct soap *soap, const char *tag, int id, const fims__TransferAtomType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__TransferAtomType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fims:destination", -1, &(a->fims__TransferAtomType::destination), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__TransferAtomType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__TransferAtomType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__TransferAtomType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__TransferAtomType(soap, tag, this, type);
}

SOAP_FMAC3 fims__TransferAtomType * SOAP_FMAC4 soap_in_fims__TransferAtomType(struct soap *soap, const char *tag, fims__TransferAtomType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__TransferAtomType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__TransferAtomType, sizeof(fims__TransferAtomType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__TransferAtomType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__TransferAtomType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_destination1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_destination1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fims:destination", &(a->fims__TransferAtomType::destination), "xsd:anyURI"))
				{	soap_flag_destination1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__TransferAtomType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__TransferAtomType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__TransferAtomType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__TransferAtomType, 0, sizeof(fims__TransferAtomType), 0, soap_copy_fims__TransferAtomType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_destination1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__TransferAtomType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__TransferAtomType);
	if (this->soap_out(soap, tag?tag:"fims:TransferAtomType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__TransferAtomType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__TransferAtomType(soap, this, tag, type);
}

SOAP_FMAC3 fims__TransferAtomType * SOAP_FMAC4 soap_get_fims__TransferAtomType(struct soap *soap, fims__TransferAtomType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__TransferAtomType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__TransferAtomType * SOAP_FMAC2 soap_instantiate_fims__TransferAtomType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__TransferAtomType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__TransferAtomType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__TransferAtomType);
		if (size)
			*size = sizeof(fims__TransferAtomType);
		((fims__TransferAtomType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__TransferAtomType, n);
		if (size)
			*size = n * sizeof(fims__TransferAtomType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__TransferAtomType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__TransferAtomType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__TransferAtomType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__TransferAtomType %p -> %p\n", q, p));
	*(fims__TransferAtomType*)p = *(fims__TransferAtomType*)q;
}

void fims__FolderLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMEssenceLocatorType::soap_default(soap);
	this->fims__FolderLocatorType::folder = NULL;
}

void fims__FolderLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__FolderLocatorType::folder);
	this->fims__BMEssenceLocatorType::soap_serialize(soap);
#endif
}

int fims__FolderLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__FolderLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__FolderLocatorType(struct soap *soap, const char *tag, int id, const fims__FolderLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__FolderLocatorType), "fims:FolderLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:folder", -1, &(a->fims__FolderLocatorType::folder), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__FolderLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__FolderLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__FolderLocatorType * SOAP_FMAC4 soap_in_fims__FolderLocatorType(struct soap *soap, const char *tag, fims__FolderLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__FolderLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__FolderLocatorType, sizeof(fims__FolderLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__FolderLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__FolderLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_storageType2 = 1;
	size_t soap_flag_locatorInfo2 = 1;
	size_t soap_flag_containerMimeType2 = 1;
	size_t soap_flag_folder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap_flag_storageType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType2--;
					continue;
				}
			if (soap_flag_locatorInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo2--;
					continue;
				}
			if (soap_flag_containerMimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType2--;
					continue;
				}
			if (soap_flag_folder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:folder", &(a->fims__FolderLocatorType::folder), "xsd:anyURI"))
				{	soap_flag_folder1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__FolderLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__FolderLocatorType, 0, sizeof(fims__FolderLocatorType), 0, soap_copy_fims__FolderLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__FolderLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__FolderLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:FolderLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__FolderLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__FolderLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__FolderLocatorType * SOAP_FMAC4 soap_get_fims__FolderLocatorType(struct soap *soap, fims__FolderLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__FolderLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__FolderLocatorType * SOAP_FMAC2 soap_instantiate_fims__FolderLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__FolderLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__FolderLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
		if (size)
			*size = sizeof(fims__FolderLocatorType);
		((fims__FolderLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
		if (size)
			*size = n * sizeof(fims__FolderLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__FolderLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__FolderLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__FolderLocatorType %p -> %p\n", q, p));
	*(fims__FolderLocatorType*)p = *(fims__FolderLocatorType*)q;
}

void fims__ListFileLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMEssenceLocatorType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->fims__ListFileLocatorType::file);
}

void fims__ListFileLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->fims__ListFileLocatorType::file);
	this->fims__BMEssenceLocatorType::soap_serialize(soap);
#endif
}

int fims__ListFileLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ListFileLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ListFileLocatorType(struct soap *soap, const char *tag, int id, const fims__ListFileLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ListFileLocatorType), "fims:ListFileLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "fims:file", -1, &(a->fims__ListFileLocatorType::file), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ListFileLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ListFileLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ListFileLocatorType * SOAP_FMAC4 soap_in_fims__ListFileLocatorType(struct soap *soap, const char *tag, fims__ListFileLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ListFileLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ListFileLocatorType, sizeof(fims__ListFileLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ListFileLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ListFileLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_storageType2 = 1;
	size_t soap_flag_locatorInfo2 = 1;
	size_t soap_flag_containerMimeType2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap_flag_storageType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType2--;
					continue;
				}
			if (soap_flag_locatorInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo2--;
					continue;
				}
			if (soap_flag_containerMimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "fims:file", &(a->fims__ListFileLocatorType::file), "xsd:anyURI"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ListFileLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ListFileLocatorType, 0, sizeof(fims__ListFileLocatorType), 0, soap_copy_fims__ListFileLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ListFileLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ListFileLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:ListFileLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ListFileLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ListFileLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ListFileLocatorType * SOAP_FMAC4 soap_get_fims__ListFileLocatorType(struct soap *soap, fims__ListFileLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ListFileLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ListFileLocatorType * SOAP_FMAC2 soap_instantiate_fims__ListFileLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ListFileLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ListFileLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
		if (size)
			*size = sizeof(fims__ListFileLocatorType);
		((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
		if (size)
			*size = n * sizeof(fims__ListFileLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ListFileLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ListFileLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ListFileLocatorType %p -> %p\n", q, p));
	*(fims__ListFileLocatorType*)p = *(fims__ListFileLocatorType*)q;
}

void fims__SimpleFileLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMEssenceLocatorType::soap_default(soap);
	this->fims__SimpleFileLocatorType::file = NULL;
}

void fims__SimpleFileLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__SimpleFileLocatorType::file);
	this->fims__BMEssenceLocatorType::soap_serialize(soap);
#endif
}

int fims__SimpleFileLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__SimpleFileLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__SimpleFileLocatorType(struct soap *soap, const char *tag, int id, const fims__SimpleFileLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__SimpleFileLocatorType), "fims:SimpleFileLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:file", -1, &(a->fims__SimpleFileLocatorType::file), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__SimpleFileLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__SimpleFileLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__SimpleFileLocatorType * SOAP_FMAC4 soap_in_fims__SimpleFileLocatorType(struct soap *soap, const char *tag, fims__SimpleFileLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__SimpleFileLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__SimpleFileLocatorType, sizeof(fims__SimpleFileLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__SimpleFileLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__SimpleFileLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_storageType2 = 1;
	size_t soap_flag_locatorInfo2 = 1;
	size_t soap_flag_containerMimeType2 = 1;
	size_t soap_flag_file1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap_flag_storageType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType2--;
					continue;
				}
			if (soap_flag_locatorInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo2--;
					continue;
				}
			if (soap_flag_containerMimeType2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType2--;
					continue;
				}
			if (soap_flag_file1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:file", &(a->fims__SimpleFileLocatorType::file), "xsd:anyURI"))
				{	soap_flag_file1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__SimpleFileLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__SimpleFileLocatorType, 0, sizeof(fims__SimpleFileLocatorType), 0, soap_copy_fims__SimpleFileLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__SimpleFileLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__SimpleFileLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:SimpleFileLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__SimpleFileLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__SimpleFileLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__SimpleFileLocatorType * SOAP_FMAC4 soap_get_fims__SimpleFileLocatorType(struct soap *soap, fims__SimpleFileLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__SimpleFileLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__SimpleFileLocatorType * SOAP_FMAC2 soap_instantiate_fims__SimpleFileLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__SimpleFileLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__SimpleFileLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
		if (size)
			*size = sizeof(fims__SimpleFileLocatorType);
		((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
		if (size)
			*size = n * sizeof(fims__SimpleFileLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__SimpleFileLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__SimpleFileLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__SimpleFileLocatorType %p -> %p\n", q, p));
	*(fims__SimpleFileLocatorType*)p = *(fims__SimpleFileLocatorType*)q;
}

void fims__BMEssenceLocatorType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMEssenceLocatorType::storageType = NULL;
	this->fims__BMEssenceLocatorType::locatorInfo = NULL;
	this->fims__BMEssenceLocatorType::containerMimeType = NULL;
}

void fims__BMEssenceLocatorType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__StorageType(soap, &this->fims__BMEssenceLocatorType::storageType);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__BMEssenceLocatorType::locatorInfo);
	soap_serialize_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, &this->fims__BMEssenceLocatorType::containerMimeType);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMEssenceLocatorType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMEssenceLocatorType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMEssenceLocatorType(struct soap *soap, const char *tag, int id, const fims__BMEssenceLocatorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMEssenceLocatorType), "fims:BMEssenceLocatorType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__StorageType(soap, "fims:storageType", -1, &(a->fims__BMEssenceLocatorType::storageType), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:locatorInfo", -1, &(a->fims__BMEssenceLocatorType::locatorInfo), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", -1, &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMEssenceLocatorType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMEssenceLocatorType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorType * SOAP_FMAC4 soap_in_fims__BMEssenceLocatorType(struct soap *soap, const char *tag, fims__BMEssenceLocatorType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMEssenceLocatorType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMEssenceLocatorType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMEssenceLocatorType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_storageType1 = 1;
	size_t soap_flag_locatorInfo1 = 1;
	size_t soap_flag_containerMimeType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_storageType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StorageType(soap, "fims:storageType", &(a->fims__BMEssenceLocatorType::storageType), "fims:StorageType"))
				{	soap_flag_storageType1--;
					continue;
				}
			if (soap_flag_locatorInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:locatorInfo", &(a->fims__BMEssenceLocatorType::locatorInfo), "xsd:string"))
				{	soap_flag_locatorInfo1--;
					continue;
				}
			if (soap_flag_containerMimeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, "fims:containerMimeType", &(a->fims__BMEssenceLocatorType::containerMimeType), ""))
				{	soap_flag_containerMimeType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMEssenceLocatorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMEssenceLocatorType, 0, sizeof(fims__BMEssenceLocatorType), 0, soap_copy_fims__BMEssenceLocatorType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMEssenceLocatorType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMEssenceLocatorType);
	if (this->soap_out(soap, tag?tag:"fims:BMEssenceLocatorType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMEssenceLocatorType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMEssenceLocatorType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorType * SOAP_FMAC4 soap_get_fims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMEssenceLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMEssenceLocatorType * SOAP_FMAC2 soap_instantiate_fims__BMEssenceLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMEssenceLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMEssenceLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:SimpleFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__SimpleFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
			if (size)
				*size = sizeof(fims__SimpleFileLocatorType);
			((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__SimpleFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SimpleFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ListFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__ListFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
			if (size)
				*size = sizeof(fims__ListFileLocatorType);
			((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__ListFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ListFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FolderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__FolderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
			if (size)
				*size = sizeof(fims__FolderLocatorType);
			((fims__FolderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__FolderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FolderLocatorType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorType);
		if (size)
			*size = sizeof(fims__BMEssenceLocatorType);
		((fims__BMEssenceLocatorType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorType, n);
		if (size)
			*size = n * sizeof(fims__BMEssenceLocatorType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMEssenceLocatorType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMEssenceLocatorType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMEssenceLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMEssenceLocatorType %p -> %p\n", q, p));
	*(fims__BMEssenceLocatorType*)p = *(fims__BMEssenceLocatorType*)q;
}

void fims__BMContentFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMContentFormatType::bmEssenceLocators = NULL;
	this->fims__BMContentFormatType::formatCollection = NULL;
	this->fims__BMContentFormatType::duration = NULL;
	this->fims__BMContentFormatType::hash = NULL;
	this->fims__BMContentFormatType::packageSize = NULL;
	this->fims__BMContentFormatType::mimeType = NULL;
}

void fims__BMContentFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMEssenceLocatorsType(soap, &this->fims__BMContentFormatType::bmEssenceLocators);
	soap_serialize_PointerTo_fims__formatCollection(soap, &this->fims__BMContentFormatType::formatCollection);
	soap_serialize_PointerTofims__DurationType(soap, &this->fims__BMContentFormatType::duration);
	soap_serialize_PointerTofims__HashType(soap, &this->fims__BMContentFormatType::hash);
	soap_serialize_PointerTounsignedLONG64(soap, &this->fims__BMContentFormatType::packageSize);
	soap_serialize_PointerTo_fims__BMContentFormatType_mimeType(soap, &this->fims__BMContentFormatType::mimeType);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMContentFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentFormatType(struct soap *soap, const char *tag, int id, const fims__BMContentFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentFormatType), "fims:BMContentFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMEssenceLocatorsType(soap, "fims:bmEssenceLocators", -1, &(a->fims__BMContentFormatType::bmEssenceLocators), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__formatCollection(soap, "fims:formatCollection", -1, &(a->fims__BMContentFormatType::formatCollection), ""))
		return soap->error;
	if (soap_out_PointerTofims__DurationType(soap, "fims:duration", -1, &(a->fims__BMContentFormatType::duration), ""))
		return soap->error;
	if (soap_out_PointerTofims__HashType(soap, "fims:hash", -1, &(a->fims__BMContentFormatType::hash), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "fims:packageSize", -1, &(a->fims__BMContentFormatType::packageSize), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__BMContentFormatType_mimeType(soap, "fims:mimeType", -1, &(a->fims__BMContentFormatType::mimeType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentFormatType * SOAP_FMAC4 soap_in_fims__BMContentFormatType(struct soap *soap, const char *tag, fims__BMContentFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentFormatType, sizeof(fims__BMContentFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_bmEssenceLocators1 = 1;
	size_t soap_flag_formatCollection1 = 1;
	size_t soap_flag_duration1 = 1;
	size_t soap_flag_hash1 = 1;
	size_t soap_flag_packageSize1 = 1;
	size_t soap_flag_mimeType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_bmEssenceLocators1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMEssenceLocatorsType(soap, "fims:bmEssenceLocators", &(a->fims__BMContentFormatType::bmEssenceLocators), "fims:BMEssenceLocatorsType"))
				{	soap_flag_bmEssenceLocators1--;
					continue;
				}
			if (soap_flag_formatCollection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__formatCollection(soap, "fims:formatCollection", &(a->fims__BMContentFormatType::formatCollection), ""))
				{	soap_flag_formatCollection1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__DurationType(soap, "fims:duration", &(a->fims__BMContentFormatType::duration), "fims:DurationType"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap_flag_hash1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__HashType(soap, "fims:hash", &(a->fims__BMContentFormatType::hash), "fims:HashType"))
				{	soap_flag_hash1--;
					continue;
				}
			if (soap_flag_packageSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "fims:packageSize", &(a->fims__BMContentFormatType::packageSize), "xsd:unsignedLong"))
				{	soap_flag_packageSize1--;
					continue;
				}
			if (soap_flag_mimeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__BMContentFormatType_mimeType(soap, "fims:mimeType", &(a->fims__BMContentFormatType::mimeType), ""))
				{	soap_flag_mimeType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentFormatType, 0, sizeof(fims__BMContentFormatType), 0, soap_copy_fims__BMContentFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentFormatType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentFormatType * SOAP_FMAC4 soap_get_fims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentFormatType * SOAP_FMAC2 soap_instantiate_fims__BMContentFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatType);
		if (size)
			*size = sizeof(fims__BMContentFormatType);
		((fims__BMContentFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatType, n);
		if (size)
			*size = n * sizeof(fims__BMContentFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentFormatType %p -> %p\n", q, p));
	*(fims__BMContentFormatType*)p = *(fims__BMContentFormatType*)q;
}

void fims__DescriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__DescriptionType::fimsdescription__bmContentDescription = NULL;
}

void fims__DescriptionType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofimsdescription__bmContentDescriptionType(soap, &this->fims__DescriptionType::fimsdescription__bmContentDescription);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__DescriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DescriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DescriptionType(struct soap *soap, const char *tag, int id, const fims__DescriptionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DescriptionType), "fims:DescriptionType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofimsdescription__bmContentDescriptionType(soap, "fimsdescription:bmContentDescription", -1, &(a->fims__DescriptionType::fimsdescription__bmContentDescription), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__DescriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DescriptionType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DescriptionType * SOAP_FMAC4 soap_in_fims__DescriptionType(struct soap *soap, const char *tag, fims__DescriptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DescriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DescriptionType, sizeof(fims__DescriptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DescriptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DescriptionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_fimsdescription__bmContentDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_fimsdescription__bmContentDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofimsdescription__bmContentDescriptionType(soap, "fimsdescription:bmContentDescription", &(a->fims__DescriptionType::fimsdescription__bmContentDescription), "fimsdescription:bmContentDescriptionType"))
				{	soap_flag_fimsdescription__bmContentDescription1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DescriptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DescriptionType, 0, sizeof(fims__DescriptionType), 0, soap_copy_fims__DescriptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DescriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DescriptionType);
	if (this->soap_out(soap, tag?tag:"fims:DescriptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DescriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DescriptionType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DescriptionType * SOAP_FMAC4 soap_get_fims__DescriptionType(struct soap *soap, fims__DescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DescriptionType * SOAP_FMAC2 soap_instantiate_fims__DescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DescriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionType);
		if (size)
			*size = sizeof(fims__DescriptionType);
		((fims__DescriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionType, n);
		if (size)
			*size = n * sizeof(fims__DescriptionType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DescriptionType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DescriptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DescriptionType %p -> %p\n", q, p));
	*(fims__DescriptionType*)p = *(fims__DescriptionType*)q;
}

void fims__BMContentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMContentType::bmContentFormats = NULL;
	this->fims__BMContentType::descriptions = NULL;
}

void fims__BMContentType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMContentFormatsType(soap, &this->fims__BMContentType::bmContentFormats);
	soap_serialize_PointerTofims__DescriptionsType(soap, &this->fims__BMContentType::descriptions);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMContentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMContentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMContentType(struct soap *soap, const char *tag, int id, const fims__BMContentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMContentType), "fims:BMContentType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMContentFormatsType(soap, "fims:bmContentFormats", -1, &(a->fims__BMContentType::bmContentFormats), ""))
		return soap->error;
	if (soap_out_PointerTofims__DescriptionsType(soap, "fims:descriptions", -1, &(a->fims__BMContentType::descriptions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMContentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMContentType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMContentType * SOAP_FMAC4 soap_in_fims__BMContentType(struct soap *soap, const char *tag, fims__BMContentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMContentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMContentType, sizeof(fims__BMContentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMContentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMContentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_bmContentFormats1 = 1;
	size_t soap_flag_descriptions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_bmContentFormats1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMContentFormatsType(soap, "fims:bmContentFormats", &(a->fims__BMContentType::bmContentFormats), "fims:BMContentFormatsType"))
				{	soap_flag_bmContentFormats1--;
					continue;
				}
			if (soap_flag_descriptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__DescriptionsType(soap, "fims:descriptions", &(a->fims__BMContentType::descriptions), "fims:DescriptionsType"))
				{	soap_flag_descriptions1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMContentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMContentType, 0, sizeof(fims__BMContentType), 0, soap_copy_fims__BMContentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMContentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMContentType);
	if (this->soap_out(soap, tag?tag:"fims:BMContentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMContentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMContentType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMContentType * SOAP_FMAC4 soap_get_fims__BMContentType(struct soap *soap, fims__BMContentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMContentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMContentType * SOAP_FMAC2 soap_instantiate_fims__BMContentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMContentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMContentType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMContentType);
		if (size)
			*size = sizeof(fims__BMContentType);
		((fims__BMContentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentType, n);
		if (size)
			*size = n * sizeof(fims__BMContentType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMContentType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMContentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMContentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMContentType %p -> %p\n", q, p));
	*(fims__BMContentType*)p = *(fims__BMContentType*)q;
}

void fims__BMObjectType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__BMObjectType::bmContents = NULL;
}

void fims__BMObjectType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__BMContentsType(soap, &this->fims__BMObjectType::bmContents);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__BMObjectType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMObjectType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMObjectType(struct soap *soap, const char *tag, int id, const fims__BMObjectType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMObjectType), "fims:BMObjectType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMContentsType(soap, "fims:bmContents", -1, &(a->fims__BMObjectType::bmContents), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__BMObjectType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMObjectType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMObjectType * SOAP_FMAC4 soap_in_fims__BMObjectType(struct soap *soap, const char *tag, fims__BMObjectType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMObjectType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMObjectType, sizeof(fims__BMObjectType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMObjectType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMObjectType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_bmContents1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_bmContents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMContentsType(soap, "fims:bmContents", &(a->fims__BMObjectType::bmContents), "fims:BMContentsType"))
				{	soap_flag_bmContents1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMObjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMObjectType, 0, sizeof(fims__BMObjectType), 0, soap_copy_fims__BMObjectType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__BMObjectType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMObjectType);
	if (this->soap_out(soap, tag?tag:"fims:BMObjectType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMObjectType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMObjectType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMObjectType * SOAP_FMAC4 soap_get_fims__BMObjectType(struct soap *soap, fims__BMObjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMObjectType * SOAP_FMAC2 soap_instantiate_fims__BMObjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMObjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMObjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectType);
		if (size)
			*size = sizeof(fims__BMObjectType);
		((fims__BMObjectType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectType, n);
		if (size)
			*size = n * sizeof(fims__BMObjectType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMObjectType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMObjectType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMObjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMObjectType %p -> %p\n", q, p));
	*(fims__BMObjectType*)p = *(fims__BMObjectType*)q;
}

void fims__CodecType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__CodecType::name = NULL;
	this->fims__CodecType::vendor = NULL;
	this->fims__CodecType::version = NULL;
	this->fims__CodecType::family = NULL;
	this->fims__CodecType::typeLabel = NULL;
	this->fims__CodecType::typeDefinition = NULL;
	this->fims__CodecType::typeLink = NULL;
	/* transient soap skipped */
}

void fims__CodecType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::name);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::vendor);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::version);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__CodecType::family);
	/* transient soap skipped */
#endif
}

int fims__CodecType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CodecType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CodecType(struct soap *soap, const char *tag, int id, const fims__CodecType *a, const char *type)
{
	if (((fims__CodecType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__CodecType*)a)->typeLabel->c_str()), 2);
	if (((fims__CodecType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__CodecType*)a)->typeDefinition->c_str()), 2);
	if (((fims__CodecType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__CodecType*)a)->typeLink->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__CodecType), type))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:name", -1, &(a->fims__CodecType::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:vendor", -1, &(a->fims__CodecType::vendor), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:version", -1, &(a->fims__CodecType::version), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:family", -1, &(a->fims__CodecType::family), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__CodecType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CodecType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CodecType * SOAP_FMAC4 soap_in_fims__CodecType(struct soap *soap, const char *tag, fims__CodecType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__CodecType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CodecType, sizeof(fims__CodecType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CodecType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__CodecType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__CodecType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CodecType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__CodecType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__CodecType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CodecType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__CodecType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__CodecType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CodecType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__CodecType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_vendor1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_family1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:name", &(a->fims__CodecType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_vendor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:vendor", &(a->fims__CodecType::vendor), "xsd:string"))
				{	soap_flag_vendor1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:version", &(a->fims__CodecType::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_family1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:family", &(a->fims__CodecType::family), "xsd:string"))
				{	soap_flag_family1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__CodecType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__CodecType, 0, sizeof(fims__CodecType), 0, soap_copy_fims__CodecType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__CodecType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CodecType);
	if (this->soap_out(soap, tag?tag:"fims:CodecType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CodecType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CodecType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CodecType * SOAP_FMAC4 soap_get_fims__CodecType(struct soap *soap, fims__CodecType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CodecType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CodecType * SOAP_FMAC2 soap_instantiate_fims__CodecType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CodecType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CodecType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CodecType);
		if (size)
			*size = sizeof(fims__CodecType);
		((fims__CodecType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CodecType, n);
		if (size)
			*size = n * sizeof(fims__CodecType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CodecType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CodecType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CodecType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CodecType %p -> %p\n", q, p));
	*(fims__CodecType*)p = *(fims__CodecType*)q;
}

void fims__BMTrackType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__BMTrackType::ExtensionGroup = NULL;
	this->fims__BMTrackType::ExtensionAttributes = NULL;
	this->fims__BMTrackType::trackID = NULL;
	this->fims__BMTrackType::trackName = NULL;
	this->fims__BMTrackType::language = NULL;
	this->fims__BMTrackType::typeLabel = NULL;
	this->fims__BMTrackType::typeDefinition = NULL;
	this->fims__BMTrackType::typeLink = NULL;
	/* transient soap skipped */
}

void fims__BMTrackType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__BMTrackType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__BMTrackType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__BMTrackType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__BMTrackType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__BMTrackType(struct soap *soap, const char *tag, int id, const fims__BMTrackType *a, const char *type)
{
	if (((fims__BMTrackType*)a)->trackID)
		soap_set_attr(soap, "trackID", soap_wchar2s(soap, ((fims__BMTrackType*)a)->trackID->c_str()), 2);
	if (((fims__BMTrackType*)a)->trackName)
		soap_set_attr(soap, "trackName", soap_wchar2s(soap, ((fims__BMTrackType*)a)->trackName->c_str()), 2);
	if (((fims__BMTrackType*)a)->language)
		soap_set_attr(soap, "language", soap_wchar2s(soap, ((fims__BMTrackType*)a)->language->c_str()), 2);
	if (((fims__BMTrackType*)a)->typeLabel)
		soap_set_attr(soap, "typeLabel", soap_wchar2s(soap, ((fims__BMTrackType*)a)->typeLabel->c_str()), 2);
	if (((fims__BMTrackType*)a)->typeDefinition)
		soap_set_attr(soap, "typeDefinition", soap_wchar2s(soap, ((fims__BMTrackType*)a)->typeDefinition->c_str()), 2);
	if (((fims__BMTrackType*)a)->typeLink)
		soap_set_attr(soap, "typeLink", soap_wchar2s(soap, ((fims__BMTrackType*)a)->typeLink->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__BMTrackType), type))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__BMTrackType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__BMTrackType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__BMTrackType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__BMTrackType(soap, tag, this, type);
}

SOAP_FMAC3 fims__BMTrackType * SOAP_FMAC4 soap_in_fims__BMTrackType(struct soap *soap, const char *tag, fims__BMTrackType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__BMTrackType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__BMTrackType, sizeof(fims__BMTrackType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__BMTrackType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__BMTrackType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "trackID", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->trackID = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->trackID = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->trackID->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "trackName", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->trackName = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->trackName = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->trackName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "language", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->language = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->language = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->language->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLabel", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->typeLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->typeLabel = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->typeLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeDefinition", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->typeDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->typeDefinition = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->typeDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "typeLink", 0);
		if (t)
		{
			if (!(((fims__BMTrackType*)a)->typeLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__BMTrackType*)a)->typeLink = soap_new_std__wstring(soap, -1);
				((fims__BMTrackType*)a)->typeLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__BMTrackType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__BMTrackType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__BMTrackType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__BMTrackType, 0, sizeof(fims__BMTrackType), 0, soap_copy_fims__BMTrackType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__BMTrackType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__BMTrackType);
	if (this->soap_out(soap, tag?tag:"fims:BMTrackType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__BMTrackType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__BMTrackType(soap, this, tag, type);
}

SOAP_FMAC3 fims__BMTrackType * SOAP_FMAC4 soap_get_fims__BMTrackType(struct soap *soap, fims__BMTrackType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__BMTrackType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__BMTrackType * SOAP_FMAC2 soap_instantiate_fims__BMTrackType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__BMTrackType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__BMTrackType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__BMTrackType);
		if (size)
			*size = sizeof(fims__BMTrackType);
		((fims__BMTrackType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMTrackType, n);
		if (size)
			*size = n * sizeof(fims__BMTrackType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__BMTrackType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__BMTrackType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__BMTrackType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__BMTrackType %p -> %p\n", q, p));
	*(fims__BMTrackType*)p = *(fims__BMTrackType*)q;
}

void fims__ContainerFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	this->fims__ContainerFormatType::containerFormat = NULL;
}

void fims__ContainerFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_fims__ContainerFormatType_containerFormat(soap, &this->fims__ContainerFormatType::containerFormat);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__ContainerFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ContainerFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ContainerFormatType(struct soap *soap, const char *tag, int id, const fims__ContainerFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ContainerFormatType), "fims:ContainerFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__ContainerFormatType_containerFormat(soap, "fims:containerFormat", -1, &(a->fims__ContainerFormatType::containerFormat), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ContainerFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ContainerFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ContainerFormatType * SOAP_FMAC4 soap_in_fims__ContainerFormatType(struct soap *soap, const char *tag, fims__ContainerFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ContainerFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ContainerFormatType, sizeof(fims__ContainerFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ContainerFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ContainerFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_containerFormat1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap_flag_containerFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__ContainerFormatType_containerFormat(soap, "fims:containerFormat", &(a->fims__ContainerFormatType::containerFormat), ""))
				{	soap_flag_containerFormat1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ContainerFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ContainerFormatType, 0, sizeof(fims__ContainerFormatType), 0, soap_copy_fims__ContainerFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ContainerFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ContainerFormatType);
	if (this->soap_out(soap, tag?tag:"fims:ContainerFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ContainerFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ContainerFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ContainerFormatType * SOAP_FMAC4 soap_get_fims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ContainerFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ContainerFormatType * SOAP_FMAC2 soap_instantiate_fims__ContainerFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ContainerFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ContainerFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
		if (size)
			*size = sizeof(fims__ContainerFormatType);
		((fims__ContainerFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
		if (size)
			*size = n * sizeof(fims__ContainerFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ContainerFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ContainerFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ContainerFormatType %p -> %p\n", q, p));
	*(fims__ContainerFormatType*)p = *(fims__ContainerFormatType*)q;
}

void fims__AncillaryDataFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__AncillaryDataFormatType::DID = NULL;
	this->fims__AncillaryDataFormatType::SDID = NULL;
	this->fims__AncillaryDataFormatType::lineNumber = NULL;
	this->fims__AncillaryDataFormatType::wrappingType = NULL;
	this->fims__AncillaryDataFormatType::ExtensionGroup = NULL;
	this->fims__AncillaryDataFormatType::ExtensionAttributes = NULL;
	/* transient soap skipped */
}

void fims__AncillaryDataFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::DID);
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::SDID);
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::lineNumber);
	soap_serialize_PointerToxsd__integer(soap, &this->fims__AncillaryDataFormatType::wrappingType);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__AncillaryDataFormatType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__AncillaryDataFormatType::ExtensionAttributes);
	/* transient soap skipped */
#endif
}

int fims__AncillaryDataFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AncillaryDataFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AncillaryDataFormatType(struct soap *soap, const char *tag, int id, const fims__AncillaryDataFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AncillaryDataFormatType), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:DID", -1, &(a->fims__AncillaryDataFormatType::DID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:SDID", -1, &(a->fims__AncillaryDataFormatType::SDID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:lineNumber", -1, &(a->fims__AncillaryDataFormatType::lineNumber), ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "fims:wrappingType", -1, &(a->fims__AncillaryDataFormatType::wrappingType), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__AncillaryDataFormatType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__AncillaryDataFormatType::ExtensionAttributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__AncillaryDataFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AncillaryDataFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AncillaryDataFormatType * SOAP_FMAC4 soap_in_fims__AncillaryDataFormatType(struct soap *soap, const char *tag, fims__AncillaryDataFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AncillaryDataFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AncillaryDataFormatType, sizeof(fims__AncillaryDataFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AncillaryDataFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AncillaryDataFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DID1 = 1;
	size_t soap_flag_SDID1 = 1;
	size_t soap_flag_lineNumber1 = 1;
	size_t soap_flag_wrappingType1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:DID", &(a->fims__AncillaryDataFormatType::DID), "xsd:integer"))
				{	soap_flag_DID1--;
					continue;
				}
			if (soap_flag_SDID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:SDID", &(a->fims__AncillaryDataFormatType::SDID), "xsd:integer"))
				{	soap_flag_SDID1--;
					continue;
				}
			if (soap_flag_lineNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:lineNumber", &(a->fims__AncillaryDataFormatType::lineNumber), "xsd:integer"))
				{	soap_flag_lineNumber1--;
					continue;
				}
			if (soap_flag_wrappingType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "fims:wrappingType", &(a->fims__AncillaryDataFormatType::wrappingType), "xsd:integer"))
				{	soap_flag_wrappingType1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__AncillaryDataFormatType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__AncillaryDataFormatType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AncillaryDataFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AncillaryDataFormatType, 0, sizeof(fims__AncillaryDataFormatType), 0, soap_copy_fims__AncillaryDataFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__AncillaryDataFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AncillaryDataFormatType);
	if (this->soap_out(soap, tag?tag:"fims:AncillaryDataFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AncillaryDataFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AncillaryDataFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AncillaryDataFormatType * SOAP_FMAC4 soap_get_fims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AncillaryDataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AncillaryDataFormatType * SOAP_FMAC2 soap_instantiate_fims__AncillaryDataFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AncillaryDataFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AncillaryDataFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AncillaryDataFormatType);
		if (size)
			*size = sizeof(fims__AncillaryDataFormatType);
		((fims__AncillaryDataFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AncillaryDataFormatType, n);
		if (size)
			*size = n * sizeof(fims__AncillaryDataFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AncillaryDataFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AncillaryDataFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AncillaryDataFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AncillaryDataFormatType %p -> %p\n", q, p));
	*(fims__AncillaryDataFormatType*)p = *(fims__AncillaryDataFormatType*)q;
}

void fims__CaptioningFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->fims__CaptioningFormatType::__item);
	this->fims__CaptioningFormatType::captioningSourceUri = NULL;
	this->fims__CaptioningFormatType::language = NULL;
	this->fims__CaptioningFormatType::formatLabel = NULL;
	this->fims__CaptioningFormatType::formatDefinition = NULL;
	this->fims__CaptioningFormatType::formatLink = NULL;
	this->fims__CaptioningFormatType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__CaptioningFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__CaptioningFormatType::__item, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->fims__CaptioningFormatType::__item);
	/* transient soap skipped */
#endif
}

int fims__CaptioningFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__CaptioningFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__CaptioningFormatType(struct soap *soap, const char *tag, int id, const fims__CaptioningFormatType *a, const char *type)
{
	if (((fims__CaptioningFormatType*)a)->captioningSourceUri)
		soap_set_attr(soap, "captioningSourceUri", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->captioningSourceUri->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->language)
		soap_set_attr(soap, "language", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->language->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->formatLabel)
		soap_set_attr(soap, "formatLabel", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->formatLabel->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->formatDefinition)
		soap_set_attr(soap, "formatDefinition", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->formatDefinition->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->formatLink)
		soap_set_attr(soap, "formatLink", soap_wchar2s(soap, ((fims__CaptioningFormatType*)a)->formatLink->c_str()), 2);
	if (((fims__CaptioningFormatType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__CaptioningFormatType*)a)->__anyAttribute, 1);
	return soap_out_std__wstring(soap, tag, id, &a->fims__CaptioningFormatType::__item, "");
}

void *fims__CaptioningFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__CaptioningFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__CaptioningFormatType * SOAP_FMAC4 soap_in_fims__CaptioningFormatType(struct soap *soap, const char *tag, fims__CaptioningFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (fims__CaptioningFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__CaptioningFormatType, sizeof(fims__CaptioningFormatType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__CaptioningFormatType)
			return (fims__CaptioningFormatType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "captioningSourceUri", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->captioningSourceUri = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->captioningSourceUri = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->captioningSourceUri->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "language", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->language = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->language = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->language->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLabel", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->formatLabel = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->formatLabel = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->formatLabel->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatDefinition", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->formatDefinition = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->formatDefinition = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->formatDefinition->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "formatLink", 0);
		if (t)
		{
			if (!(((fims__CaptioningFormatType*)a)->formatLink = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__CaptioningFormatType*)a)->formatLink = soap_new_std__wstring(soap, -1);
				((fims__CaptioningFormatType*)a)->formatLink->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__CaptioningFormatType*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_std__wstring(soap, tag, &(a->fims__CaptioningFormatType::__item), "fims:CaptioningFormatType"))
		return NULL;
	return a;
}

int fims__CaptioningFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__CaptioningFormatType);
	if (this->soap_out(soap, tag?tag:"fims:CaptioningFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__CaptioningFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__CaptioningFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__CaptioningFormatType * SOAP_FMAC4 soap_get_fims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__CaptioningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__CaptioningFormatType * SOAP_FMAC2 soap_instantiate_fims__CaptioningFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__CaptioningFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__CaptioningFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__CaptioningFormatType);
		if (size)
			*size = sizeof(fims__CaptioningFormatType);
		((fims__CaptioningFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__CaptioningFormatType, n);
		if (size)
			*size = n * sizeof(fims__CaptioningFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__CaptioningFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__CaptioningFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__CaptioningFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__CaptioningFormatType %p -> %p\n", q, p));
	*(fims__CaptioningFormatType*)p = *(fims__CaptioningFormatType*)q;
}

void fims__DataFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, &this->fims__DataFormatType::captioningFormat);
	soap_default_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, &this->fims__DataFormatType::ancillaryDataFormat);
}

void fims__DataFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, &this->fims__DataFormatType::captioningFormat);
	soap_serialize_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, &this->fims__DataFormatType::ancillaryDataFormat);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__DataFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__DataFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__DataFormatType(struct soap *soap, const char *tag, int id, const fims__DataFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__DataFormatType), "fims:DataFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, "fims:captioningFormat", -1, &(a->fims__DataFormatType::captioningFormat), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, "fims:ancillaryDataFormat", -1, &(a->fims__DataFormatType::ancillaryDataFormat), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__DataFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__DataFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__DataFormatType * SOAP_FMAC4 soap_in_fims__DataFormatType(struct soap *soap, const char *tag, fims__DataFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__DataFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__DataFormatType, sizeof(fims__DataFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__DataFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__DataFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, "fims:captioningFormat", &(a->fims__DataFormatType::captioningFormat), "fims:CaptioningFormatType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, "fims:ancillaryDataFormat", &(a->fims__DataFormatType::ancillaryDataFormat), "fims:AncillaryDataFormatType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__DataFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__DataFormatType, 0, sizeof(fims__DataFormatType), 0, soap_copy_fims__DataFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__DataFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__DataFormatType);
	if (this->soap_out(soap, tag?tag:"fims:DataFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__DataFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__DataFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__DataFormatType * SOAP_FMAC4 soap_get_fims__DataFormatType(struct soap *soap, fims__DataFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__DataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__DataFormatType * SOAP_FMAC2 soap_instantiate_fims__DataFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__DataFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__DataFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
		if (size)
			*size = sizeof(fims__DataFormatType);
		((fims__DataFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
		if (size)
			*size = n * sizeof(fims__DataFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__DataFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__DataFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__DataFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__DataFormatType %p -> %p\n", q, p));
	*(fims__DataFormatType*)p = *(fims__DataFormatType*)q;
}

void fims__AudioFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	this->fims__AudioFormatType::samplingRate = NULL;
	this->fims__AudioFormatType::audioEncoding = NULL;
	this->fims__AudioFormatType::trackConfiguration = NULL;
	soap_default_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__AudioFormatType::audioTrack);
	this->fims__AudioFormatType::channels = NULL;
	this->fims__AudioFormatType::bitRate = NULL;
	this->fims__AudioFormatType::bitRateMode = NULL;
	this->fims__AudioFormatType::sampleSize = NULL;
	this->fims__AudioFormatType::sampleType = NULL;
}

void fims__AudioFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__decimal(soap, &this->fims__AudioFormatType::samplingRate);
	soap_serialize_PointerTofims__CodecType(soap, &this->fims__AudioFormatType::audioEncoding);
	soap_serialize_PointerTo_fims__AudioFormatType_trackConfiguration(soap, &this->fims__AudioFormatType::trackConfiguration);
	soap_serialize_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__AudioFormatType::audioTrack);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__AudioFormatType::channels);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__AudioFormatType::bitRate);
	soap_serialize_PointerTofims__BitRateModeType(soap, &this->fims__AudioFormatType::bitRateMode);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__AudioFormatType::sampleSize);
	soap_serialize_PointerTofims__AudioSampleType(soap, &this->fims__AudioFormatType::sampleType);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__AudioFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AudioFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AudioFormatType(struct soap *soap, const char *tag, int id, const fims__AudioFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AudioFormatType), "fims:AudioFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_PointerToxsd__decimal(soap, "fims:samplingRate", -1, &(a->fims__AudioFormatType::samplingRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__CodecType(soap, "fims:audioEncoding", -1, &(a->fims__AudioFormatType::audioEncoding), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(soap, "fims:trackConfiguration", -1, &(a->fims__AudioFormatType::trackConfiguration), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:audioTrack", -1, &(a->fims__AudioFormatType::audioTrack), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:channels", -1, &(a->fims__AudioFormatType::channels), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", -1, &(a->fims__AudioFormatType::bitRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", -1, &(a->fims__AudioFormatType::bitRateMode), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:sampleSize", -1, &(a->fims__AudioFormatType::sampleSize), ""))
		return soap->error;
	if (soap_out_PointerTofims__AudioSampleType(soap, "fims:sampleType", -1, &(a->fims__AudioFormatType::sampleType), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__AudioFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AudioFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AudioFormatType * SOAP_FMAC4 soap_in_fims__AudioFormatType(struct soap *soap, const char *tag, fims__AudioFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AudioFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AudioFormatType, sizeof(fims__AudioFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AudioFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AudioFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_samplingRate1 = 1;
	size_t soap_flag_audioEncoding1 = 1;
	size_t soap_flag_trackConfiguration1 = 1;
	size_t soap_flag_channels1 = 1;
	size_t soap_flag_bitRate1 = 1;
	size_t soap_flag_bitRateMode1 = 1;
	size_t soap_flag_sampleSize1 = 1;
	size_t soap_flag_sampleType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap_flag_samplingRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__decimal(soap, "fims:samplingRate", &(a->fims__AudioFormatType::samplingRate), "xsd:decimal"))
				{	soap_flag_samplingRate1--;
					continue;
				}
			if (soap_flag_audioEncoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__CodecType(soap, "fims:audioEncoding", &(a->fims__AudioFormatType::audioEncoding), "fims:CodecType"))
				{	soap_flag_audioEncoding1--;
					continue;
				}
			if (soap_flag_trackConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(soap, "fims:trackConfiguration", &(a->fims__AudioFormatType::trackConfiguration), ""))
				{	soap_flag_trackConfiguration1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:audioTrack", &(a->fims__AudioFormatType::audioTrack), "fims:BMTrackType"))
					continue;
			if (soap_flag_channels1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:channels", &(a->fims__AudioFormatType::channels), "xsd:nonNegativeInteger"))
				{	soap_flag_channels1--;
					continue;
				}
			if (soap_flag_bitRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", &(a->fims__AudioFormatType::bitRate), "xsd:nonNegativeInteger"))
				{	soap_flag_bitRate1--;
					continue;
				}
			if (soap_flag_bitRateMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", &(a->fims__AudioFormatType::bitRateMode), "fims:BitRateModeType"))
				{	soap_flag_bitRateMode1--;
					continue;
				}
			if (soap_flag_sampleSize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:sampleSize", &(a->fims__AudioFormatType::sampleSize), "xsd:nonNegativeInteger"))
				{	soap_flag_sampleSize1--;
					continue;
				}
			if (soap_flag_sampleType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AudioSampleType(soap, "fims:sampleType", &(a->fims__AudioFormatType::sampleType), "fims:AudioSampleType"))
				{	soap_flag_sampleType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AudioFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AudioFormatType, 0, sizeof(fims__AudioFormatType), 0, soap_copy_fims__AudioFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__AudioFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AudioFormatType);
	if (this->soap_out(soap, tag?tag:"fims:AudioFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AudioFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AudioFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AudioFormatType * SOAP_FMAC4 soap_get_fims__AudioFormatType(struct soap *soap, fims__AudioFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AudioFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AudioFormatType * SOAP_FMAC2 soap_instantiate_fims__AudioFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AudioFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AudioFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
		if (size)
			*size = sizeof(fims__AudioFormatType);
		((fims__AudioFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
		if (size)
			*size = n * sizeof(fims__AudioFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AudioFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AudioFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AudioFormatType %p -> %p\n", q, p));
	*(fims__AudioFormatType*)p = *(fims__AudioFormatType*)q;
}

void fims__VideoFormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FormatType::soap_default(soap);
	this->fims__VideoFormatType::displayWidth = NULL;
	this->fims__VideoFormatType::displayHeight = NULL;
	this->fims__VideoFormatType::frameRate = NULL;
	this->fims__VideoFormatType::aspectRatio = NULL;
	this->fims__VideoFormatType::videoEncoding = NULL;
	soap_default_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__VideoFormatType::videoTrack);
	this->fims__VideoFormatType::bitRate = NULL;
	this->fims__VideoFormatType::bitRateMode = NULL;
	this->fims__VideoFormatType::lines = NULL;
	this->fims__VideoFormatType::scanningFormat = NULL;
	this->fims__VideoFormatType::scanningOrder = NULL;
	this->fims__VideoFormatType::noiseFilter = NULL;
}

void fims__VideoFormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__LengthType(soap, &this->fims__VideoFormatType::displayWidth);
	soap_serialize_PointerTofims__LengthType(soap, &this->fims__VideoFormatType::displayHeight);
	soap_serialize_PointerTofims__RationalType(soap, &this->fims__VideoFormatType::frameRate);
	soap_serialize_PointerTofims__RationalType(soap, &this->fims__VideoFormatType::aspectRatio);
	soap_serialize_PointerTofims__CodecType(soap, &this->fims__VideoFormatType::videoEncoding);
	soap_serialize_std__vectorTemplateOfPointerTofims__BMTrackType(soap, &this->fims__VideoFormatType::videoTrack);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__VideoFormatType::bitRate);
	soap_serialize_PointerTofims__BitRateModeType(soap, &this->fims__VideoFormatType::bitRateMode);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__VideoFormatType::lines);
	soap_serialize_PointerTofims__ScanningFormatType(soap, &this->fims__VideoFormatType::scanningFormat);
	soap_serialize_PointerTofims__ScanningOrderType(soap, &this->fims__VideoFormatType::scanningOrder);
	soap_serialize_PointerTobool(soap, &this->fims__VideoFormatType::noiseFilter);
	this->fims__FormatType::soap_serialize(soap);
#endif
}

int fims__VideoFormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__VideoFormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__VideoFormatType(struct soap *soap, const char *tag, int id, const fims__VideoFormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__VideoFormatType), "fims:VideoFormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	if (soap_out_PointerTofims__LengthType(soap, "fims:displayWidth", -1, &(a->fims__VideoFormatType::displayWidth), ""))
		return soap->error;
	if (soap_out_PointerTofims__LengthType(soap, "fims:displayHeight", -1, &(a->fims__VideoFormatType::displayHeight), ""))
		return soap->error;
	if (soap_out_PointerTofims__RationalType(soap, "fims:frameRate", -1, &(a->fims__VideoFormatType::frameRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__RationalType(soap, "fims:aspectRatio", -1, &(a->fims__VideoFormatType::aspectRatio), ""))
		return soap->error;
	if (soap_out_PointerTofims__CodecType(soap, "fims:videoEncoding", -1, &(a->fims__VideoFormatType::videoEncoding), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:videoTrack", -1, &(a->fims__VideoFormatType::videoTrack), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", -1, &(a->fims__VideoFormatType::bitRate), ""))
		return soap->error;
	if (soap_out_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", -1, &(a->fims__VideoFormatType::bitRateMode), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:lines", -1, &(a->fims__VideoFormatType::lines), ""))
		return soap->error;
	if (soap_out_PointerTofims__ScanningFormatType(soap, "fims:scanningFormat", -1, &(a->fims__VideoFormatType::scanningFormat), ""))
		return soap->error;
	if (soap_out_PointerTofims__ScanningOrderType(soap, "fims:scanningOrder", -1, &(a->fims__VideoFormatType::scanningOrder), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:noiseFilter", -1, &(a->fims__VideoFormatType::noiseFilter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__VideoFormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__VideoFormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__VideoFormatType * SOAP_FMAC4 soap_in_fims__VideoFormatType(struct soap *soap, const char *tag, fims__VideoFormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__VideoFormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__VideoFormatType, sizeof(fims__VideoFormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__VideoFormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__VideoFormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID4 = 1;
	size_t soap_flag_revisionID4 = 1;
	size_t soap_flag_location4 = 1;
	size_t soap_flag_resourceCreationDate3 = 1;
	size_t soap_flag_resourceModifiedDate3 = 1;
	size_t soap_flag_notifyAt3 = 1;
	size_t soap_flag_ExtensionGroup3 = 1;
	size_t soap_flag_ExtensionAttributes3 = 1;
	size_t soap_flag_displayWidth1 = 1;
	size_t soap_flag_displayHeight1 = 1;
	size_t soap_flag_frameRate1 = 1;
	size_t soap_flag_aspectRatio1 = 1;
	size_t soap_flag_videoEncoding1 = 1;
	size_t soap_flag_bitRate1 = 1;
	size_t soap_flag_bitRateMode1 = 1;
	size_t soap_flag_lines1 = 1;
	size_t soap_flag_scanningFormat1 = 1;
	size_t soap_flag_scanningOrder1 = 1;
	size_t soap_flag_noiseFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID4--;
					continue;
				}
			if (soap_flag_revisionID4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID4--;
					continue;
				}
			if (soap_flag_location4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location4--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate3--;
					continue;
				}
			if (soap_flag_resourceModifiedDate3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate3--;
					continue;
				}
			if (soap_flag_notifyAt3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt3--;
					continue;
				}
			if (soap_flag_ExtensionGroup3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup3--;
					continue;
				}
			if (soap_flag_ExtensionAttributes3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap_flag_displayWidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__LengthType(soap, "fims:displayWidth", &(a->fims__VideoFormatType::displayWidth), "fims:LengthType"))
				{	soap_flag_displayWidth1--;
					continue;
				}
			if (soap_flag_displayHeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__LengthType(soap, "fims:displayHeight", &(a->fims__VideoFormatType::displayHeight), "fims:LengthType"))
				{	soap_flag_displayHeight1--;
					continue;
				}
			if (soap_flag_frameRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__RationalType(soap, "fims:frameRate", &(a->fims__VideoFormatType::frameRate), "fims:RationalType"))
				{	soap_flag_frameRate1--;
					continue;
				}
			if (soap_flag_aspectRatio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__RationalType(soap, "fims:aspectRatio", &(a->fims__VideoFormatType::aspectRatio), "fims:RationalType"))
				{	soap_flag_aspectRatio1--;
					continue;
				}
			if (soap_flag_videoEncoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__CodecType(soap, "fims:videoEncoding", &(a->fims__VideoFormatType::videoEncoding), "fims:CodecType"))
				{	soap_flag_videoEncoding1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__BMTrackType(soap, "fims:videoTrack", &(a->fims__VideoFormatType::videoTrack), "fims:BMTrackType"))
					continue;
			if (soap_flag_bitRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:bitRate", &(a->fims__VideoFormatType::bitRate), "xsd:nonNegativeInteger"))
				{	soap_flag_bitRate1--;
					continue;
				}
			if (soap_flag_bitRateMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BitRateModeType(soap, "fims:bitRateMode", &(a->fims__VideoFormatType::bitRateMode), "fims:BitRateModeType"))
				{	soap_flag_bitRateMode1--;
					continue;
				}
			if (soap_flag_lines1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:lines", &(a->fims__VideoFormatType::lines), "xsd:nonNegativeInteger"))
				{	soap_flag_lines1--;
					continue;
				}
			if (soap_flag_scanningFormat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ScanningFormatType(soap, "fims:scanningFormat", &(a->fims__VideoFormatType::scanningFormat), "fims:ScanningFormatType"))
				{	soap_flag_scanningFormat1--;
					continue;
				}
			if (soap_flag_scanningOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ScanningOrderType(soap, "fims:scanningOrder", &(a->fims__VideoFormatType::scanningOrder), "fims:ScanningOrderType"))
				{	soap_flag_scanningOrder1--;
					continue;
				}
			if (soap_flag_noiseFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:noiseFilter", &(a->fims__VideoFormatType::noiseFilter), "xsd:boolean"))
				{	soap_flag_noiseFilter1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__VideoFormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__VideoFormatType, 0, sizeof(fims__VideoFormatType), 0, soap_copy_fims__VideoFormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID4 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__VideoFormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__VideoFormatType);
	if (this->soap_out(soap, tag?tag:"fims:VideoFormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__VideoFormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__VideoFormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__VideoFormatType * SOAP_FMAC4 soap_get_fims__VideoFormatType(struct soap *soap, fims__VideoFormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__VideoFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__VideoFormatType * SOAP_FMAC2 soap_instantiate_fims__VideoFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__VideoFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__VideoFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
		if (size)
			*size = sizeof(fims__VideoFormatType);
		((fims__VideoFormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
		if (size)
			*size = n * sizeof(fims__VideoFormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__VideoFormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__VideoFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__VideoFormatType %p -> %p\n", q, p));
	*(fims__VideoFormatType*)p = *(fims__VideoFormatType*)q;
}

void fims__FormatType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, &this->fims__FormatType::technicalAttribute);
}

void fims__FormatType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, &this->fims__FormatType::technicalAttribute);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__FormatType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__FormatType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__FormatType(struct soap *soap, const char *tag, int id, const fims__FormatType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__FormatType), "fims:FormatType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", -1, &(a->fims__FormatType::technicalAttribute), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__FormatType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__FormatType(soap, tag, this, type);
}

SOAP_FMAC3 fims__FormatType * SOAP_FMAC4 soap_in_fims__FormatType(struct soap *soap, const char *tag, fims__FormatType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__FormatType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__FormatType, sizeof(fims__FormatType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__FormatType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__FormatType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, "fims:technicalAttribute", &(a->fims__FormatType::technicalAttribute), "fims:TechnicalAttributeType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__FormatType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__FormatType, 0, sizeof(fims__FormatType), 0, soap_copy_fims__FormatType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__FormatType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__FormatType);
	if (this->soap_out(soap, tag?tag:"fims:FormatType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__FormatType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__FormatType(soap, this, tag, type);
}

SOAP_FMAC3 fims__FormatType * SOAP_FMAC4 soap_get_fims__FormatType(struct soap *soap, fims__FormatType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__FormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__FormatType * SOAP_FMAC2 soap_instantiate_fims__FormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__FormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__FormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:VideoFormatType"))
	{	cp->type = SOAP_TYPE_fims__VideoFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
			if (size)
				*size = sizeof(fims__VideoFormatType);
			((fims__VideoFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
			if (size)
				*size = n * sizeof(fims__VideoFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__VideoFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:AudioFormatType"))
	{	cp->type = SOAP_TYPE_fims__AudioFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
			if (size)
				*size = sizeof(fims__AudioFormatType);
			((fims__AudioFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
			if (size)
				*size = n * sizeof(fims__AudioFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__AudioFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DataFormatType"))
	{	cp->type = SOAP_TYPE_fims__DataFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
			if (size)
				*size = sizeof(fims__DataFormatType);
			((fims__DataFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
			if (size)
				*size = n * sizeof(fims__DataFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DataFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DataFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContainerFormatType"))
	{	cp->type = SOAP_TYPE_fims__ContainerFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
			if (size)
				*size = sizeof(fims__ContainerFormatType);
			((fims__ContainerFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
			if (size)
				*size = n * sizeof(fims__ContainerFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContainerFormatType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__FormatType);
		if (size)
			*size = sizeof(fims__FormatType);
		((fims__FormatType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FormatType, n);
		if (size)
			*size = n * sizeof(fims__FormatType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__FormatType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__FormatType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__FormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__FormatType %p -> %p\n", q, p));
	*(fims__FormatType*)p = *(fims__FormatType*)q;
}

void fims__JobType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__JobType::status = NULL;
	this->fims__JobType::statusDescription = NULL;
	this->fims__JobType::serviceProviderJobID = NULL;
	this->fims__JobType::queueReference = NULL;
	this->fims__JobType::tasks = NULL;
	this->fims__JobType::operationName = NULL;
	this->fims__JobType::bmObjects = NULL;
	this->fims__JobType::priority = NULL;
	this->fims__JobType::startJob = NULL;
	this->fims__JobType::finishBefore = NULL;
	this->fims__JobType::estimatedCompletionDuration = NULL;
	this->fims__JobType::currentQueuePosition = NULL;
	this->fims__JobType::jobStartedTime = NULL;
	this->fims__JobType::jobElapsedTime = NULL;
	this->fims__JobType::jobCompletedTime = NULL;
	this->fims__JobType::processed = NULL;
}

void fims__JobType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__JobStatusType(soap, &this->fims__JobType::status);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__JobType::statusDescription);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__JobType::serviceProviderJobID);
	soap_serialize_PointerTofims__QueueType(soap, &this->fims__JobType::queueReference);
	soap_serialize_PointerTofims__JobsType(soap, &this->fims__JobType::tasks);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__JobType::operationName);
	soap_serialize_PointerTofims__BMObjectsType(soap, &this->fims__JobType::bmObjects);
	soap_serialize_PointerTofims__PriorityType(soap, &this->fims__JobType::priority);
	soap_serialize_PointerTofims__StartJobType(soap, &this->fims__JobType::startJob);
	soap_serialize_PointerTotime(soap, &this->fims__JobType::finishBefore);
	soap_serialize_PointerToxsd__duration(soap, &this->fims__JobType::estimatedCompletionDuration);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__JobType::currentQueuePosition);
	soap_serialize_PointerTotime(soap, &this->fims__JobType::jobStartedTime);
	soap_serialize_PointerToxsd__duration(soap, &this->fims__JobType::jobElapsedTime);
	soap_serialize_PointerTotime(soap, &this->fims__JobType::jobCompletedTime);
	soap_serialize_PointerTofims__ProcessedInfoType(soap, &this->fims__JobType::processed);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__JobType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__JobType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__JobType(struct soap *soap, const char *tag, int id, const fims__JobType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__JobType), "fims:JobType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__JobStatusType(soap, "fims:status", -1, &(a->fims__JobType::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:statusDescription", -1, &(a->fims__JobType::statusDescription), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:serviceProviderJobID", -1, &(a->fims__JobType::serviceProviderJobID), ""))
		return soap->error;
	if (soap_out_PointerTofims__QueueType(soap, "fims:queueReference", -1, &(a->fims__JobType::queueReference), ""))
		return soap->error;
	if (soap_out_PointerTofims__JobsType(soap, "fims:tasks", -1, &(a->fims__JobType::tasks), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:operationName", -1, &(a->fims__JobType::operationName), ""))
		return soap->error;
	if (soap_out_PointerTofims__BMObjectsType(soap, "fims:bmObjects", -1, &(a->fims__JobType::bmObjects), ""))
		return soap->error;
	if (soap_out_PointerTofims__PriorityType(soap, "fims:priority", -1, &(a->fims__JobType::priority), ""))
		return soap->error;
	if (soap_out_PointerTofims__StartJobType(soap, "fims:startJob", -1, &(a->fims__JobType::startJob), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:finishBefore", -1, &(a->fims__JobType::finishBefore), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "fims:estimatedCompletionDuration", -1, &(a->fims__JobType::estimatedCompletionDuration), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:currentQueuePosition", -1, &(a->fims__JobType::currentQueuePosition), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:jobStartedTime", -1, &(a->fims__JobType::jobStartedTime), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "fims:jobElapsedTime", -1, &(a->fims__JobType::jobElapsedTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:jobCompletedTime", -1, &(a->fims__JobType::jobCompletedTime), ""))
		return soap->error;
	if (soap_out_PointerTofims__ProcessedInfoType(soap, "fims:processed", -1, &(a->fims__JobType::processed), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__JobType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__JobType(soap, tag, this, type);
}

SOAP_FMAC3 fims__JobType * SOAP_FMAC4 soap_in_fims__JobType(struct soap *soap, const char *tag, fims__JobType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__JobType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__JobType, sizeof(fims__JobType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__JobType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__JobType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_statusDescription1 = 1;
	size_t soap_flag_serviceProviderJobID1 = 1;
	size_t soap_flag_queueReference1 = 1;
	size_t soap_flag_tasks1 = 1;
	size_t soap_flag_operationName1 = 1;
	size_t soap_flag_bmObjects1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_startJob1 = 1;
	size_t soap_flag_finishBefore1 = 1;
	size_t soap_flag_estimatedCompletionDuration1 = 1;
	size_t soap_flag_currentQueuePosition1 = 1;
	size_t soap_flag_jobStartedTime1 = 1;
	size_t soap_flag_jobElapsedTime1 = 1;
	size_t soap_flag_jobCompletedTime1 = 1;
	size_t soap_flag_processed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobStatusType(soap, "fims:status", &(a->fims__JobType::status), "fims:JobStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_statusDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:statusDescription", &(a->fims__JobType::statusDescription), "xsd:string"))
				{	soap_flag_statusDescription1--;
					continue;
				}
			if (soap_flag_serviceProviderJobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:serviceProviderJobID", &(a->fims__JobType::serviceProviderJobID), "xsd:string"))
				{	soap_flag_serviceProviderJobID1--;
					continue;
				}
			if (soap_flag_queueReference1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueueType(soap, "fims:queueReference", &(a->fims__JobType::queueReference), "fims:QueueType"))
				{	soap_flag_queueReference1--;
					continue;
				}
			if (soap_flag_tasks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobsType(soap, "fims:tasks", &(a->fims__JobType::tasks), "fims:JobsType"))
				{	soap_flag_tasks1--;
					continue;
				}
			if (soap_flag_operationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:operationName", &(a->fims__JobType::operationName), "xsd:string"))
				{	soap_flag_operationName1--;
					continue;
				}
			if (soap_flag_bmObjects1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__BMObjectsType(soap, "fims:bmObjects", &(a->fims__JobType::bmObjects), "fims:BMObjectsType"))
				{	soap_flag_bmObjects1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__PriorityType(soap, "fims:priority", &(a->fims__JobType::priority), "fims:PriorityType"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_startJob1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__StartJobType(soap, "fims:startJob", &(a->fims__JobType::startJob), "fims:StartJobType"))
				{	soap_flag_startJob1--;
					continue;
				}
			if (soap_flag_finishBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:finishBefore", &(a->fims__JobType::finishBefore), "xsd:dateTime"))
				{	soap_flag_finishBefore1--;
					continue;
				}
			if (soap_flag_estimatedCompletionDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "fims:estimatedCompletionDuration", &(a->fims__JobType::estimatedCompletionDuration), "xsd:duration"))
				{	soap_flag_estimatedCompletionDuration1--;
					continue;
				}
			if (soap_flag_currentQueuePosition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:currentQueuePosition", &(a->fims__JobType::currentQueuePosition), "xsd:nonNegativeInteger"))
				{	soap_flag_currentQueuePosition1--;
					continue;
				}
			if (soap_flag_jobStartedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:jobStartedTime", &(a->fims__JobType::jobStartedTime), "xsd:dateTime"))
				{	soap_flag_jobStartedTime1--;
					continue;
				}
			if (soap_flag_jobElapsedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "fims:jobElapsedTime", &(a->fims__JobType::jobElapsedTime), "xsd:duration"))
				{	soap_flag_jobElapsedTime1--;
					continue;
				}
			if (soap_flag_jobCompletedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:jobCompletedTime", &(a->fims__JobType::jobCompletedTime), "xsd:dateTime"))
				{	soap_flag_jobCompletedTime1--;
					continue;
				}
			if (soap_flag_processed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ProcessedInfoType(soap, "fims:processed", &(a->fims__JobType::processed), "fims:ProcessedInfoType"))
				{	soap_flag_processed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__JobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__JobType, 0, sizeof(fims__JobType), 0, soap_copy_fims__JobType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__JobType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__JobType);
	if (this->soap_out(soap, tag?tag:"fims:JobType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__JobType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__JobType(soap, this, tag, type);
}

SOAP_FMAC3 fims__JobType * SOAP_FMAC4 soap_get_fims__JobType(struct soap *soap, fims__JobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__JobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__JobType * SOAP_FMAC2 soap_instantiate_fims__JobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__JobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__JobType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__JobType);
		if (size)
			*size = sizeof(fims__JobType);
		((fims__JobType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobType, n);
		if (size)
			*size = n * sizeof(fims__JobType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__JobType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__JobType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__JobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__JobType %p -> %p\n", q, p));
	*(fims__JobType*)p = *(fims__JobType*)q;
}

void fims__QueueType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__QueueType::status = NULL;
	this->fims__QueueType::statusDescription = NULL;
	this->fims__QueueType::length = NULL;
	this->fims__QueueType::availability = NULL;
	this->fims__QueueType::estimatedTotalCompletionDuration = NULL;
	this->fims__QueueType::jobs = NULL;
}

void fims__QueueType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__QueueStatusType(soap, &this->fims__QueueType::status);
	soap_serialize_PointerTostd__wstring(soap, &this->fims__QueueType::statusDescription);
	soap_serialize_PointerToxsd__nonNegativeInteger(soap, &this->fims__QueueType::length);
	soap_serialize_PointerTobool(soap, &this->fims__QueueType::availability);
	soap_serialize_PointerToxsd__duration(soap, &this->fims__QueueType::estimatedTotalCompletionDuration);
	soap_serialize_PointerTofims__JobsType(soap, &this->fims__QueueType::jobs);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__QueueType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__QueueType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__QueueType(struct soap *soap, const char *tag, int id, const fims__QueueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__QueueType), "fims:QueueType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__QueueStatusType(soap, "fims:status", -1, &(a->fims__QueueType::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:statusDescription", -1, &(a->fims__QueueType::statusDescription), ""))
		return soap->error;
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, "fims:length", -1, &(a->fims__QueueType::length), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fims:availability", -1, &(a->fims__QueueType::availability), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "fims:estimatedTotalCompletionDuration", -1, &(a->fims__QueueType::estimatedTotalCompletionDuration), ""))
		return soap->error;
	if (soap_out_PointerTofims__JobsType(soap, "fims:jobs", -1, &(a->fims__QueueType::jobs), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__QueueType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__QueueType(soap, tag, this, type);
}

SOAP_FMAC3 fims__QueueType * SOAP_FMAC4 soap_in_fims__QueueType(struct soap *soap, const char *tag, fims__QueueType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__QueueType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__QueueType, sizeof(fims__QueueType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__QueueType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__QueueType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_statusDescription1 = 1;
	size_t soap_flag_length1 = 1;
	size_t soap_flag_availability1 = 1;
	size_t soap_flag_estimatedTotalCompletionDuration1 = 1;
	size_t soap_flag_jobs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__QueueStatusType(soap, "fims:status", &(a->fims__QueueType::status), "fims:QueueStatusType"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_statusDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:statusDescription", &(a->fims__QueueType::statusDescription), "xsd:string"))
				{	soap_flag_statusDescription1--;
					continue;
				}
			if (soap_flag_length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__nonNegativeInteger(soap, "fims:length", &(a->fims__QueueType::length), "xsd:nonNegativeInteger"))
				{	soap_flag_length1--;
					continue;
				}
			if (soap_flag_availability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fims:availability", &(a->fims__QueueType::availability), "xsd:boolean"))
				{	soap_flag_availability1--;
					continue;
				}
			if (soap_flag_estimatedTotalCompletionDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "fims:estimatedTotalCompletionDuration", &(a->fims__QueueType::estimatedTotalCompletionDuration), "xsd:duration"))
				{	soap_flag_estimatedTotalCompletionDuration1--;
					continue;
				}
			if (soap_flag_jobs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__JobsType(soap, "fims:jobs", &(a->fims__QueueType::jobs), "fims:JobsType"))
				{	soap_flag_jobs1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__QueueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__QueueType, 0, sizeof(fims__QueueType), 0, soap_copy_fims__QueueType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__QueueType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__QueueType);
	if (this->soap_out(soap, tag?tag:"fims:QueueType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__QueueType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__QueueType(soap, this, tag, type);
}

SOAP_FMAC3 fims__QueueType * SOAP_FMAC4 soap_get_fims__QueueType(struct soap *soap, fims__QueueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__QueueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__QueueType * SOAP_FMAC2 soap_instantiate_fims__QueueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__QueueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__QueueType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__QueueType);
		if (size)
			*size = sizeof(fims__QueueType);
		((fims__QueueType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueueType, n);
		if (size)
			*size = n * sizeof(fims__QueueType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__QueueType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__QueueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__QueueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__QueueType %p -> %p\n", q, p));
	*(fims__QueueType*)p = *(fims__QueueType*)q;
}

void fims__ProfileType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__ProfileType::service = NULL;
	this->fims__ProfileType::name = NULL;
	this->fims__ProfileType::description = NULL;
}

void fims__ProfileType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTofims__ServiceType(soap, &this->fims__ProfileType::service);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__ProfileType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ProfileType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ProfileType(struct soap *soap, const char *tag, int id, const fims__ProfileType *a, const char *type)
{
	if (((fims__ProfileType*)a)->name)
		soap_set_attr(soap, "name", soap_wchar2s(soap, ((fims__ProfileType*)a)->name->c_str()), 2);
	if (((fims__ProfileType*)a)->description)
		soap_set_attr(soap, "description", soap_wchar2s(soap, ((fims__ProfileType*)a)->description->c_str()), 2);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ProfileType), "fims:ProfileType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTofims__ServiceType(soap, "fims:service", -1, &(a->fims__ProfileType::service), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ProfileType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ProfileType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ProfileType * SOAP_FMAC4 soap_in_fims__ProfileType(struct soap *soap, const char *tag, fims__ProfileType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ProfileType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ProfileType, sizeof(fims__ProfileType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ProfileType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ProfileType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			if (!(((fims__ProfileType*)a)->name = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__ProfileType*)a)->name = soap_new_std__wstring(soap, -1);
				((fims__ProfileType*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "description", 0);
		if (t)
		{
			if (!(((fims__ProfileType*)a)->description = (std::wstring *)soap_malloc(soap, sizeof(std::wstring))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			wchar_t *s = NULL;
			if (soap_s2wchar(soap, t, &s, 0, -1))
				return NULL;
			if (s)
			{	((fims__ProfileType*)a)->description = soap_new_std__wstring(soap, -1);
				((fims__ProfileType*)a)->description->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_service1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_service1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ServiceType(soap, "fims:service", &(a->fims__ProfileType::service), "fims:ServiceType"))
				{	soap_flag_service1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ProfileType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ProfileType, 0, sizeof(fims__ProfileType), 0, soap_copy_fims__ProfileType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ProfileType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ProfileType);
	if (this->soap_out(soap, tag?tag:"fims:ProfileType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ProfileType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ProfileType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ProfileType * SOAP_FMAC4 soap_get_fims__ProfileType(struct soap *soap, fims__ProfileType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ProfileType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ProfileType * SOAP_FMAC2 soap_instantiate_fims__ProfileType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ProfileType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ProfileType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ProfileType);
		if (size)
			*size = sizeof(fims__ProfileType);
		((fims__ProfileType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfileType, n);
		if (size)
			*size = n * sizeof(fims__ProfileType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ProfileType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ProfileType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ProfileType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ProfileType %p -> %p\n", q, p));
	*(fims__ProfileType*)p = *(fims__ProfileType*)q;
}

void fims__ServiceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceType::soap_default(soap);
	this->fims__ServiceType::providerName = NULL;
	this->fims__ServiceType::providerEndPoint = NULL;
	this->fims__ServiceType::serviceDescription = NULL;
}

void fims__ServiceType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__wstring(soap, &this->fims__ServiceType::providerName);
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__ServiceType::providerEndPoint);
	soap_serialize_PointerTo_fims__ServiceType_serviceDescription(soap, &this->fims__ServiceType::serviceDescription);
	this->fims__ResourceType::soap_serialize(soap);
#endif
}

int fims__ServiceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ServiceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ServiceType(struct soap *soap, const char *tag, int id, const fims__ServiceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ServiceType), "fims:ServiceType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:providerName", -1, &(a->fims__ServiceType::providerName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:providerEndPoint", -1, &(a->fims__ServiceType::providerEndPoint), ""))
		return soap->error;
	if (soap_out_PointerTo_fims__ServiceType_serviceDescription(soap, "fims:serviceDescription", -1, &(a->fims__ServiceType::serviceDescription), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ServiceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ServiceType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ServiceType * SOAP_FMAC4 soap_in_fims__ServiceType(struct soap *soap, const char *tag, fims__ServiceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ServiceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ServiceType, sizeof(fims__ServiceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ServiceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ServiceType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID3 = 1;
	size_t soap_flag_revisionID3 = 1;
	size_t soap_flag_location3 = 1;
	size_t soap_flag_resourceCreationDate2 = 1;
	size_t soap_flag_resourceModifiedDate2 = 1;
	size_t soap_flag_notifyAt2 = 1;
	size_t soap_flag_ExtensionGroup2 = 1;
	size_t soap_flag_ExtensionAttributes2 = 1;
	size_t soap_flag_providerName1 = 1;
	size_t soap_flag_providerEndPoint1 = 1;
	size_t soap_flag_serviceDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID3--;
					continue;
				}
			if (soap_flag_revisionID3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID3--;
					continue;
				}
			if (soap_flag_location3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate2--;
					continue;
				}
			if (soap_flag_resourceModifiedDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate2--;
					continue;
				}
			if (soap_flag_notifyAt2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt2--;
					continue;
				}
			if (soap_flag_ExtensionGroup2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup2--;
					continue;
				}
			if (soap_flag_ExtensionAttributes2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes2--;
					continue;
				}
			if (soap_flag_providerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:providerName", &(a->fims__ServiceType::providerName), "xsd:string"))
				{	soap_flag_providerName1--;
					continue;
				}
			if (soap_flag_providerEndPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:providerEndPoint", &(a->fims__ServiceType::providerEndPoint), "xsd:anyURI"))
				{	soap_flag_providerEndPoint1--;
					continue;
				}
			if (soap_flag_serviceDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_fims__ServiceType_serviceDescription(soap, "fims:serviceDescription", &(a->fims__ServiceType::serviceDescription), ""))
				{	soap_flag_serviceDescription1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ServiceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ServiceType, 0, sizeof(fims__ServiceType), 0, soap_copy_fims__ServiceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ServiceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ServiceType);
	if (this->soap_out(soap, tag?tag:"fims:ServiceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ServiceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ServiceType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ServiceType * SOAP_FMAC4 soap_get_fims__ServiceType(struct soap *soap, fims__ServiceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ServiceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ServiceType * SOAP_FMAC2 soap_instantiate_fims__ServiceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ServiceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ServiceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ServiceType);
		if (size)
			*size = sizeof(fims__ServiceType);
		((fims__ServiceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServiceType, n);
		if (size)
			*size = n * sizeof(fims__ServiceType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ServiceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ServiceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ServiceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ServiceType %p -> %p\n", q, p));
	*(fims__ServiceType*)p = *(fims__ServiceType*)q;
}

void fims__AsyncEndpointType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->fims__AsyncEndpointType::replyTo);
	soap_default_xsd__anyURI(soap, &this->fims__AsyncEndpointType::faultTo);
	/* transient soap skipped */
}

void fims__AsyncEndpointType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->fims__AsyncEndpointType::replyTo, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->fims__AsyncEndpointType::replyTo);
	soap_embedded(soap, &this->fims__AsyncEndpointType::faultTo, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->fims__AsyncEndpointType::faultTo);
	/* transient soap skipped */
#endif
}

int fims__AsyncEndpointType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__AsyncEndpointType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__AsyncEndpointType(struct soap *soap, const char *tag, int id, const fims__AsyncEndpointType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__AsyncEndpointType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fims:replyTo", -1, &(a->fims__AsyncEndpointType::replyTo), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "fims:faultTo", -1, &(a->fims__AsyncEndpointType::faultTo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__AsyncEndpointType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__AsyncEndpointType(soap, tag, this, type);
}

SOAP_FMAC3 fims__AsyncEndpointType * SOAP_FMAC4 soap_in_fims__AsyncEndpointType(struct soap *soap, const char *tag, fims__AsyncEndpointType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__AsyncEndpointType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__AsyncEndpointType, sizeof(fims__AsyncEndpointType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__AsyncEndpointType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__AsyncEndpointType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_replyTo1 = 1;
	size_t soap_flag_faultTo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_replyTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fims:replyTo", &(a->fims__AsyncEndpointType::replyTo), "xsd:anyURI"))
				{	soap_flag_replyTo1--;
					continue;
				}
			if (soap_flag_faultTo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "fims:faultTo", &(a->fims__AsyncEndpointType::faultTo), "xsd:anyURI"))
				{	soap_flag_faultTo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__AsyncEndpointType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__AsyncEndpointType, 0, sizeof(fims__AsyncEndpointType), 0, soap_copy_fims__AsyncEndpointType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_replyTo1 > 0 || soap_flag_faultTo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__AsyncEndpointType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__AsyncEndpointType);
	if (this->soap_out(soap, tag?tag:"fims:AsyncEndpointType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__AsyncEndpointType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__AsyncEndpointType(soap, this, tag, type);
}

SOAP_FMAC3 fims__AsyncEndpointType * SOAP_FMAC4 soap_get_fims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__AsyncEndpointType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__AsyncEndpointType * SOAP_FMAC2 soap_instantiate_fims__AsyncEndpointType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__AsyncEndpointType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__AsyncEndpointType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__AsyncEndpointType);
		if (size)
			*size = sizeof(fims__AsyncEndpointType);
		((fims__AsyncEndpointType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AsyncEndpointType, n);
		if (size)
			*size = n * sizeof(fims__AsyncEndpointType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__AsyncEndpointType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__AsyncEndpointType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__AsyncEndpointType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__AsyncEndpointType %p -> %p\n", q, p));
	*(fims__AsyncEndpointType*)p = *(fims__AsyncEndpointType*)q;
}

void fims__ResourceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ResourceReferenceType::soap_default(soap);
	this->fims__ResourceType::resourceCreationDate = NULL;
	this->fims__ResourceType::resourceModifiedDate = NULL;
	this->fims__ResourceType::notifyAt = NULL;
	this->fims__ResourceType::ExtensionGroup = NULL;
	this->fims__ResourceType::ExtensionAttributes = NULL;
}

void fims__ResourceType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->fims__ResourceType::resourceCreationDate);
	soap_serialize_PointerTotime(soap, &this->fims__ResourceType::resourceModifiedDate);
	soap_serialize_PointerTofims__AsyncEndpointType(soap, &this->fims__ResourceType::notifyAt);
	soap_serialize_PointerTofims__ExtensionGroup(soap, &this->fims__ResourceType::ExtensionGroup);
	soap_serialize_PointerTofims__ExtensionAttributes(soap, &this->fims__ResourceType::ExtensionAttributes);
	this->fims__ResourceReferenceType::soap_serialize(soap);
#endif
}

int fims__ResourceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ResourceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourceType(struct soap *soap, const char *tag, int id, const fims__ResourceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ResourceType), "fims:ResourceType"))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "fims:resourceCreationDate", -1, &(a->fims__ResourceType::resourceCreationDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "fims:resourceModifiedDate", -1, &(a->fims__ResourceType::resourceModifiedDate), ""))
		return soap->error;
	if (soap_out_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", -1, &(a->fims__ResourceType::notifyAt), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", -1, &(a->fims__ResourceType::ExtensionGroup), ""))
		return soap->error;
	if (soap_out_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", -1, &(a->fims__ResourceType::ExtensionAttributes), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *fims__ResourceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ResourceType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ResourceType * SOAP_FMAC4 soap_in_fims__ResourceType(struct soap *soap, const char *tag, fims__ResourceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ResourceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ResourceType, sizeof(fims__ResourceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ResourceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ResourceType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID2 = 1;
	size_t soap_flag_revisionID2 = 1;
	size_t soap_flag_location2 = 1;
	size_t soap_flag_resourceCreationDate1 = 1;
	size_t soap_flag_resourceModifiedDate1 = 1;
	size_t soap_flag_notifyAt1 = 1;
	size_t soap_flag_ExtensionGroup1 = 1;
	size_t soap_flag_ExtensionAttributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID2--;
					continue;
				}
			if (soap_flag_revisionID2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID2--;
					continue;
				}
			if (soap_flag_location2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_resourceCreationDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceCreationDate", &(a->fims__ResourceType::resourceCreationDate), "xsd:dateTime"))
				{	soap_flag_resourceCreationDate1--;
					continue;
				}
			if (soap_flag_resourceModifiedDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fims:resourceModifiedDate", &(a->fims__ResourceType::resourceModifiedDate), "xsd:dateTime"))
				{	soap_flag_resourceModifiedDate1--;
					continue;
				}
			if (soap_flag_notifyAt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__AsyncEndpointType(soap, "fims:notifyAt", &(a->fims__ResourceType::notifyAt), "fims:AsyncEndpointType"))
				{	soap_flag_notifyAt1--;
					continue;
				}
			if (soap_flag_ExtensionGroup1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionGroup(soap, "fims:ExtensionGroup", &(a->fims__ResourceType::ExtensionGroup), "fims:ExtensionGroup"))
				{	soap_flag_ExtensionGroup1--;
					continue;
				}
			if (soap_flag_ExtensionAttributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofims__ExtensionAttributes(soap, "fims:ExtensionAttributes", &(a->fims__ResourceType::ExtensionAttributes), "fims:ExtensionAttributes"))
				{	soap_flag_ExtensionAttributes1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ResourceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ResourceType, 0, sizeof(fims__ResourceType), 0, soap_copy_fims__ResourceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ResourceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ResourceType);
	if (this->soap_out(soap, tag?tag:"fims:ResourceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ResourceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ResourceType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ResourceType * SOAP_FMAC4 soap_get_fims__ResourceType(struct soap *soap, fims__ResourceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ResourceType * SOAP_FMAC2 soap_instantiate_fims__ResourceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ResourceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ResourceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ServiceType"))
	{	cp->type = SOAP_TYPE_fims__ServiceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ServiceType);
			if (size)
				*size = sizeof(fims__ServiceType);
			((fims__ServiceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServiceType, n);
			if (size)
				*size = n * sizeof(fims__ServiceType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ServiceType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ServiceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ProfileType"))
	{	cp->type = SOAP_TYPE_fims__ProfileType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProfileType);
			if (size)
				*size = sizeof(fims__ProfileType);
			((fims__ProfileType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfileType, n);
			if (size)
				*size = n * sizeof(fims__ProfileType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProfileType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProfileType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:QueueType"))
	{	cp->type = SOAP_TYPE_fims__QueueType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueueType);
			if (size)
				*size = sizeof(fims__QueueType);
			((fims__QueueType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueueType, n);
			if (size)
				*size = n * sizeof(fims__QueueType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueueType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueueType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:JobType"))
	{	cp->type = SOAP_TYPE_fims__JobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__JobType);
			if (size)
				*size = sizeof(fims__JobType);
			((fims__JobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobType, n);
			if (size)
				*size = n * sizeof(fims__JobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__JobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__JobType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FormatType"))
	{	cp->type = SOAP_TYPE_fims__FormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FormatType);
			if (size)
				*size = sizeof(fims__FormatType);
			((fims__FormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FormatType, n);
			if (size)
				*size = n * sizeof(fims__FormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMObjectType"))
	{	cp->type = SOAP_TYPE_fims__BMObjectType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectType);
			if (size)
				*size = sizeof(fims__BMObjectType);
			((fims__BMObjectType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectType, n);
			if (size)
				*size = n * sizeof(fims__BMObjectType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMObjectType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMObjectType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentType"))
	{	cp->type = SOAP_TYPE_fims__BMContentType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentType);
			if (size)
				*size = sizeof(fims__BMContentType);
			((fims__BMContentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentType, n);
			if (size)
				*size = n * sizeof(fims__BMContentType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DescriptionType"))
	{	cp->type = SOAP_TYPE_fims__DescriptionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionType);
			if (size)
				*size = sizeof(fims__DescriptionType);
			((fims__DescriptionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionType, n);
			if (size)
				*size = n * sizeof(fims__DescriptionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DescriptionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DescriptionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentFormatType"))
	{	cp->type = SOAP_TYPE_fims__BMContentFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatType);
			if (size)
				*size = sizeof(fims__BMContentFormatType);
			((fims__BMContentFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatType, n);
			if (size)
				*size = n * sizeof(fims__BMContentFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMEssenceLocatorType"))
	{	cp->type = SOAP_TYPE_fims__BMEssenceLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorType);
			if (size)
				*size = sizeof(fims__BMEssenceLocatorType);
			((fims__BMEssenceLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorType, n);
			if (size)
				*size = n * sizeof(fims__BMEssenceLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMEssenceLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMEssenceLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:VideoFormatType"))
	{	cp->type = SOAP_TYPE_fims__VideoFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
			if (size)
				*size = sizeof(fims__VideoFormatType);
			((fims__VideoFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
			if (size)
				*size = n * sizeof(fims__VideoFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__VideoFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:AudioFormatType"))
	{	cp->type = SOAP_TYPE_fims__AudioFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
			if (size)
				*size = sizeof(fims__AudioFormatType);
			((fims__AudioFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
			if (size)
				*size = n * sizeof(fims__AudioFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__AudioFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DataFormatType"))
	{	cp->type = SOAP_TYPE_fims__DataFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
			if (size)
				*size = sizeof(fims__DataFormatType);
			((fims__DataFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
			if (size)
				*size = n * sizeof(fims__DataFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DataFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DataFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContainerFormatType"))
	{	cp->type = SOAP_TYPE_fims__ContainerFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
			if (size)
				*size = sizeof(fims__ContainerFormatType);
			((fims__ContainerFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
			if (size)
				*size = n * sizeof(fims__ContainerFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContainerFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SimpleFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__SimpleFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
			if (size)
				*size = sizeof(fims__SimpleFileLocatorType);
			((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__SimpleFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SimpleFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ListFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__ListFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
			if (size)
				*size = sizeof(fims__ListFileLocatorType);
			((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__ListFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ListFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FolderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__FolderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
			if (size)
				*size = sizeof(fims__FolderLocatorType);
			((fims__FolderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__FolderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FolderLocatorType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ResourceType);
		if (size)
			*size = sizeof(fims__ResourceType);
		((fims__ResourceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourceType, n);
		if (size)
			*size = n * sizeof(fims__ResourceType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ResourceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ResourceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ResourceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ResourceType %p -> %p\n", q, p));
	*(fims__ResourceType*)p = *(fims__ResourceType*)q;
}

void fims__ResourceReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_fims__ResourceIDType(soap, &this->fims__ResourceReferenceType::resourceID);
	this->fims__ResourceReferenceType::revisionID = NULL;
	this->fims__ResourceReferenceType::location = NULL;
	/* transient soap skipped */
}

void fims__ResourceReferenceType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_fims__ResourceIDType(soap, &this->fims__ResourceReferenceType::resourceID);
	soap_serialize_PointerTofims__RevisionIDType(soap, &this->fims__ResourceReferenceType::revisionID);
	soap_serialize_PointerToxsd__anyURI(soap, &this->fims__ResourceReferenceType::location);
	/* transient soap skipped */
#endif
}

int fims__ResourceReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ResourceReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ResourceReferenceType(struct soap *soap, const char *tag, int id, const fims__ResourceReferenceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ResourceReferenceType), type))
		return soap->error;
	if (soap_out_fims__ResourceIDType(soap, "fims:resourceID", -1, &(a->fims__ResourceReferenceType::resourceID), ""))
		return soap->error;
	if (soap_out_PointerTofims__RevisionIDType(soap, "fims:revisionID", -1, &(a->fims__ResourceReferenceType::revisionID), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "fims:location", -1, &(a->fims__ResourceReferenceType::location), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ResourceReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ResourceReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 fims__ResourceReferenceType * SOAP_FMAC4 soap_in_fims__ResourceReferenceType(struct soap *soap, const char *tag, fims__ResourceReferenceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ResourceReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ResourceReferenceType, sizeof(fims__ResourceReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ResourceReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ResourceReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resourceID1 = 1;
	size_t soap_flag_revisionID1 = 1;
	size_t soap_flag_location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_resourceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_fims__ResourceIDType(soap, "fims:resourceID", &(a->fims__ResourceReferenceType::resourceID), "fims:ResourceIDType"))
				{	soap_flag_resourceID1--;
					continue;
				}
			if (soap_flag_revisionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTofims__RevisionIDType(soap, "fims:revisionID", &(a->fims__ResourceReferenceType::revisionID), "fims:RevisionIDType"))
				{	soap_flag_revisionID1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "fims:location", &(a->fims__ResourceReferenceType::location), "xsd:anyURI"))
				{	soap_flag_location1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ResourceReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ResourceReferenceType, 0, sizeof(fims__ResourceReferenceType), 0, soap_copy_fims__ResourceReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resourceID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int fims__ResourceReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ResourceReferenceType);
	if (this->soap_out(soap, tag?tag:"fims:ResourceReferenceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ResourceReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ResourceReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 fims__ResourceReferenceType * SOAP_FMAC4 soap_get_fims__ResourceReferenceType(struct soap *soap, fims__ResourceReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ResourceReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ResourceReferenceType * SOAP_FMAC2 soap_instantiate_fims__ResourceReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ResourceReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ResourceReferenceType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "fims:ResourceType"))
	{	cp->type = SOAP_TYPE_fims__ResourceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ResourceType);
			if (size)
				*size = sizeof(fims__ResourceType);
			((fims__ResourceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourceType, n);
			if (size)
				*size = n * sizeof(fims__ResourceType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ResourceType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ResourceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ServiceType"))
	{	cp->type = SOAP_TYPE_fims__ServiceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ServiceType);
			if (size)
				*size = sizeof(fims__ServiceType);
			((fims__ServiceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ServiceType, n);
			if (size)
				*size = n * sizeof(fims__ServiceType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ServiceType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ServiceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ProfileType"))
	{	cp->type = SOAP_TYPE_fims__ProfileType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ProfileType);
			if (size)
				*size = sizeof(fims__ProfileType);
			((fims__ProfileType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ProfileType, n);
			if (size)
				*size = n * sizeof(fims__ProfileType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ProfileType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ProfileType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:QueueType"))
	{	cp->type = SOAP_TYPE_fims__QueueType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__QueueType);
			if (size)
				*size = sizeof(fims__QueueType);
			((fims__QueueType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__QueueType, n);
			if (size)
				*size = n * sizeof(fims__QueueType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__QueueType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__QueueType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:JobType"))
	{	cp->type = SOAP_TYPE_fims__JobType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__JobType);
			if (size)
				*size = sizeof(fims__JobType);
			((fims__JobType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__JobType, n);
			if (size)
				*size = n * sizeof(fims__JobType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__JobType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__JobType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FormatType"))
	{	cp->type = SOAP_TYPE_fims__FormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FormatType);
			if (size)
				*size = sizeof(fims__FormatType);
			((fims__FormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FormatType, n);
			if (size)
				*size = n * sizeof(fims__FormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMObjectType"))
	{	cp->type = SOAP_TYPE_fims__BMObjectType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMObjectType);
			if (size)
				*size = sizeof(fims__BMObjectType);
			((fims__BMObjectType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMObjectType, n);
			if (size)
				*size = n * sizeof(fims__BMObjectType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMObjectType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMObjectType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentType"))
	{	cp->type = SOAP_TYPE_fims__BMContentType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentType);
			if (size)
				*size = sizeof(fims__BMContentType);
			((fims__BMContentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentType, n);
			if (size)
				*size = n * sizeof(fims__BMContentType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DescriptionType"))
	{	cp->type = SOAP_TYPE_fims__DescriptionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DescriptionType);
			if (size)
				*size = sizeof(fims__DescriptionType);
			((fims__DescriptionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DescriptionType, n);
			if (size)
				*size = n * sizeof(fims__DescriptionType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DescriptionType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DescriptionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMContentFormatType"))
	{	cp->type = SOAP_TYPE_fims__BMContentFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMContentFormatType);
			if (size)
				*size = sizeof(fims__BMContentFormatType);
			((fims__BMContentFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMContentFormatType, n);
			if (size)
				*size = n * sizeof(fims__BMContentFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMContentFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMContentFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:BMEssenceLocatorType"))
	{	cp->type = SOAP_TYPE_fims__BMEssenceLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__BMEssenceLocatorType);
			if (size)
				*size = sizeof(fims__BMEssenceLocatorType);
			((fims__BMEssenceLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__BMEssenceLocatorType, n);
			if (size)
				*size = n * sizeof(fims__BMEssenceLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__BMEssenceLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__BMEssenceLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:VideoFormatType"))
	{	cp->type = SOAP_TYPE_fims__VideoFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__VideoFormatType);
			if (size)
				*size = sizeof(fims__VideoFormatType);
			((fims__VideoFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__VideoFormatType, n);
			if (size)
				*size = n * sizeof(fims__VideoFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__VideoFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__VideoFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:AudioFormatType"))
	{	cp->type = SOAP_TYPE_fims__AudioFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__AudioFormatType);
			if (size)
				*size = sizeof(fims__AudioFormatType);
			((fims__AudioFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__AudioFormatType, n);
			if (size)
				*size = n * sizeof(fims__AudioFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__AudioFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__AudioFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:DataFormatType"))
	{	cp->type = SOAP_TYPE_fims__DataFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__DataFormatType);
			if (size)
				*size = sizeof(fims__DataFormatType);
			((fims__DataFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__DataFormatType, n);
			if (size)
				*size = n * sizeof(fims__DataFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__DataFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__DataFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ContainerFormatType"))
	{	cp->type = SOAP_TYPE_fims__ContainerFormatType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ContainerFormatType);
			if (size)
				*size = sizeof(fims__ContainerFormatType);
			((fims__ContainerFormatType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ContainerFormatType, n);
			if (size)
				*size = n * sizeof(fims__ContainerFormatType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ContainerFormatType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ContainerFormatType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:SimpleFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__SimpleFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__SimpleFileLocatorType);
			if (size)
				*size = sizeof(fims__SimpleFileLocatorType);
			((fims__SimpleFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__SimpleFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__SimpleFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__SimpleFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__SimpleFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:ListFileLocatorType"))
	{	cp->type = SOAP_TYPE_fims__ListFileLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__ListFileLocatorType);
			if (size)
				*size = sizeof(fims__ListFileLocatorType);
			((fims__ListFileLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ListFileLocatorType, n);
			if (size)
				*size = n * sizeof(fims__ListFileLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__ListFileLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__ListFileLocatorType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "fims:FolderLocatorType"))
	{	cp->type = SOAP_TYPE_fims__FolderLocatorType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(fims__FolderLocatorType);
			if (size)
				*size = sizeof(fims__FolderLocatorType);
			((fims__FolderLocatorType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__FolderLocatorType, n);
			if (size)
				*size = n * sizeof(fims__FolderLocatorType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((fims__FolderLocatorType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (fims__FolderLocatorType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ResourceReferenceType);
		if (size)
			*size = sizeof(fims__ResourceReferenceType);
		((fims__ResourceReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ResourceReferenceType, n);
		if (size)
			*size = n * sizeof(fims__ResourceReferenceType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ResourceReferenceType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ResourceReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ResourceReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ResourceReferenceType %p -> %p\n", q, p));
	*(fims__ResourceReferenceType*)p = *(fims__ResourceReferenceType*)q;
}

void fims__ExtensionAttributes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__ExtensionAttributes::__anyAttribute = NULL;
	/* transient soap skipped */
}

void fims__ExtensionAttributes::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int fims__ExtensionAttributes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ExtensionAttributes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ExtensionAttributes(struct soap *soap, const char *tag, int id, const fims__ExtensionAttributes *a, const char *type)
{
	if (((fims__ExtensionAttributes*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((fims__ExtensionAttributes*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ExtensionAttributes), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ExtensionAttributes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ExtensionAttributes(soap, tag, this, type);
}

SOAP_FMAC3 fims__ExtensionAttributes * SOAP_FMAC4 soap_in_fims__ExtensionAttributes(struct soap *soap, const char *tag, fims__ExtensionAttributes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ExtensionAttributes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ExtensionAttributes, sizeof(fims__ExtensionAttributes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ExtensionAttributes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ExtensionAttributes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((fims__ExtensionAttributes*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ExtensionAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ExtensionAttributes, 0, sizeof(fims__ExtensionAttributes), 0, soap_copy_fims__ExtensionAttributes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ExtensionAttributes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ExtensionAttributes);
	if (this->soap_out(soap, tag?tag:"fims:ExtensionAttributes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ExtensionAttributes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ExtensionAttributes(soap, this, tag, type);
}

SOAP_FMAC3 fims__ExtensionAttributes * SOAP_FMAC4 soap_get_fims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ExtensionAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ExtensionAttributes * SOAP_FMAC2 soap_instantiate_fims__ExtensionAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ExtensionAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ExtensionAttributes, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ExtensionAttributes);
		if (size)
			*size = sizeof(fims__ExtensionAttributes);
		((fims__ExtensionAttributes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ExtensionAttributes, n);
		if (size)
			*size = n * sizeof(fims__ExtensionAttributes);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ExtensionAttributes*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ExtensionAttributes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ExtensionAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ExtensionAttributes %p -> %p\n", q, p));
	*(fims__ExtensionAttributes*)p = *(fims__ExtensionAttributes*)q;
}

void fims__ExtensionGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->fims__ExtensionGroup::__any);
	/* transient soap skipped */
}

void fims__ExtensionGroup::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->fims__ExtensionGroup::__any);
	/* transient soap skipped */
#endif
}

int fims__ExtensionGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fims__ExtensionGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fims__ExtensionGroup(struct soap *soap, const char *tag, int id, const fims__ExtensionGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fims__ExtensionGroup), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->fims__ExtensionGroup::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *fims__ExtensionGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fims__ExtensionGroup(soap, tag, this, type);
}

SOAP_FMAC3 fims__ExtensionGroup * SOAP_FMAC4 soap_in_fims__ExtensionGroup(struct soap *soap, const char *tag, fims__ExtensionGroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (fims__ExtensionGroup *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fims__ExtensionGroup, sizeof(fims__ExtensionGroup), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_fims__ExtensionGroup)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (fims__ExtensionGroup *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->fims__ExtensionGroup::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fims__ExtensionGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fims__ExtensionGroup, 0, sizeof(fims__ExtensionGroup), 0, soap_copy_fims__ExtensionGroup);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int fims__ExtensionGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_fims__ExtensionGroup);
	if (this->soap_out(soap, tag?tag:"fims:ExtensionGroup", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fims__ExtensionGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fims__ExtensionGroup(soap, this, tag, type);
}

SOAP_FMAC3 fims__ExtensionGroup * SOAP_FMAC4 soap_get_fims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_fims__ExtensionGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 fims__ExtensionGroup * SOAP_FMAC2 soap_instantiate_fims__ExtensionGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fims__ExtensionGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fims__ExtensionGroup, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(fims__ExtensionGroup);
		if (size)
			*size = sizeof(fims__ExtensionGroup);
		((fims__ExtensionGroup*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(fims__ExtensionGroup, n);
		if (size)
			*size = n * sizeof(fims__ExtensionGroup);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((fims__ExtensionGroup*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (fims__ExtensionGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_fims__ExtensionGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying fims__ExtensionGroup %p -> %p\n", q, p));
	*(fims__ExtensionGroup*)p = *(fims__ExtensionGroup*)q;
}

void edlprovider__EdlProviderFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->fims__FaultType::soap_default(soap);
	this->edlprovider__EdlProviderFaultType::extendedCode = NULL;
}

void edlprovider__EdlProviderFaultType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EDLProviderErrorCodeType(soap, &this->edlprovider__EdlProviderFaultType::extendedCode);
	this->fims__FaultType::soap_serialize(soap);
#endif
}

int edlprovider__EdlProviderFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlProviderFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, int id, const edlprovider__EdlProviderFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlProviderFaultType), "edlprovider:EdlProviderFaultType"))
		return soap->error;
	if (soap_out_fims__ErrorCodeType(soap, "fims:code", -1, &(a->fims__FaultType::code), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:description", -1, &(a->fims__FaultType::description), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "fims:detail", -1, &(a->fims__FaultType::detail), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", -1, &(a->fims__FaultType::innerFault), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToedlprovider__EDLProviderErrorCodeType(soap, "extendedCode", -1, &(a->edlprovider__EdlProviderFaultType::extendedCode), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlProviderFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlProviderFaultType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType * SOAP_FMAC4 soap_in_edlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, edlprovider__EdlProviderFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlProviderFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlProviderFaultType, sizeof(edlprovider__EdlProviderFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlProviderFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlProviderFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_detail2 = 1;
	size_t soap_flag_extendedCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_fims__ErrorCodeType(soap, "fims:code", &(a->fims__FaultType::code), "fims:ErrorCodeType"))
				{	soap_flag_code2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:description", &(a->fims__FaultType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_detail2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "fims:detail", &(a->fims__FaultType::detail), "xsd:string"))
				{	soap_flag_detail2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, "fims:innerFault", &(a->fims__FaultType::innerFault), "fims:InnerFaultType"))
					continue;
			/* transient soap skipped */
			if (soap_flag_extendedCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EDLProviderErrorCodeType(soap, "extendedCode", &(a->edlprovider__EdlProviderFaultType::extendedCode), "edlprovider:EDLProviderErrorCodeType"))
				{	soap_flag_extendedCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlProviderFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlProviderFaultType, 0, sizeof(edlprovider__EdlProviderFaultType), 0, soap_copy_edlprovider__EdlProviderFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlProviderFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlProviderFaultType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlProviderFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlProviderFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlProviderFaultType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType * SOAP_FMAC4 soap_get_edlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlProviderFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlProviderFaultType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlProviderFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlProviderFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlProviderFaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlProviderFaultType);
		if (size)
			*size = sizeof(edlprovider__EdlProviderFaultType);
		((edlprovider__EdlProviderFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlProviderFaultType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlProviderFaultType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlProviderFaultType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlProviderFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlProviderFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlProviderFaultType %p -> %p\n", q, p));
	*(edlprovider__EdlProviderFaultType*)p = *(edlprovider__EdlProviderFaultType*)q;
}

void edlprovider__EdlCreateResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__EdlCreateResponseType::getEdlResult = NULL;
	/* transient soap skipped */
}

void edlprovider__EdlCreateResponseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->edlprovider__EdlCreateResponseType::getEdlResult);
	/* transient soap skipped */
#endif
}

int edlprovider__EdlCreateResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateResponseType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateResponseType), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "getEdlResult", -1, &(a->edlprovider__EdlCreateResponseType::getEdlResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateResponseType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateResponseType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateResponseType(struct soap *soap, const char *tag, edlprovider__EdlCreateResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateResponseType, sizeof(edlprovider__EdlCreateResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_getEdlResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getEdlResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "getEdlResult", &(a->edlprovider__EdlCreateResponseType::getEdlResult), "xsd:base64Binary"))
				{	soap_flag_getEdlResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateResponseType, 0, sizeof(edlprovider__EdlCreateResponseType), 0, soap_copy_edlprovider__EdlCreateResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int edlprovider__EdlCreateResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateResponseType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateResponseType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateResponseType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateResponseType(struct soap *soap, edlprovider__EdlCreateResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateResponseType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateResponseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateResponseType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateResponseType);
		((edlprovider__EdlCreateResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateResponseType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateResponseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateResponseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateResponseType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateResponseType*)p = *(edlprovider__EdlCreateResponseType*)q;
}

void edlprovider__EdlCreateRequestDoubleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__EdlCreateRequestBaseType::soap_default(soap);
	soap_default_double(soap, &this->edlprovider__EdlCreateRequestDoubleType::edlFramesPerSecond);
}

void edlprovider__EdlCreateRequestDoubleType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->edlprovider__EdlCreateRequestBaseType::soap_serialize(soap);
#endif
}

int edlprovider__EdlCreateRequestDoubleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateRequestDoubleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateRequestDoubleType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType), "edlprovider:EdlCreateRequestDoubleType"))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlType", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlType), ""))
		return soap->error;
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, "clips", -1, &(a->edlprovider__EdlCreateRequestBaseType::clips), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "edlSequenceName", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_double(soap, "edlFramesPerSecond", -1, &(a->edlprovider__EdlCreateRequestDoubleType::edlFramesPerSecond), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateRequestDoubleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateRequestDoubleType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestDoubleType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateRequestDoubleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, sizeof(edlprovider__EdlCreateRequestDoubleType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateRequestDoubleType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlType2 = 1;
	size_t soap_flag_clips2 = 1;
	size_t soap_flag_edlSequenceName2 = 1;
	size_t soap_flag_edlFramesPerSecond1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlType", &(a->edlprovider__EdlCreateRequestBaseType::edlType), "xsd:string"))
				{	soap_flag_edlType2--;
					continue;
				}
			if (soap_flag_clips2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__ArrayOfClips(soap, "clips", &(a->edlprovider__EdlCreateRequestBaseType::clips), "edlprovider:ArrayOfClips"))
				{	soap_flag_clips2--;
					continue;
				}
			if (soap_flag_edlSequenceName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "edlSequenceName", &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), "xsd:string"))
				{	soap_flag_edlSequenceName2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_edlFramesPerSecond1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "edlFramesPerSecond", &(a->edlprovider__EdlCreateRequestDoubleType::edlFramesPerSecond), "xsd:double"))
				{	soap_flag_edlFramesPerSecond1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateRequestDoubleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, 0, sizeof(edlprovider__EdlCreateRequestDoubleType), 0, soap_copy_edlprovider__EdlCreateRequestDoubleType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlType2 > 0 || soap_flag_edlFramesPerSecond1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlCreateRequestDoubleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateRequestDoubleType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateRequestDoubleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateRequestDoubleType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateRequestDoubleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateRequestDoubleType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateRequestDoubleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestDoubleType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateRequestDoubleType);
		((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestDoubleType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateRequestDoubleType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateRequestDoubleType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateRequestDoubleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateRequestDoubleType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateRequestDoubleType*)p = *(edlprovider__EdlCreateRequestDoubleType*)q;
}

void edlprovider__EdlCreateRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->edlprovider__EdlCreateRequestBaseType::soap_default(soap);
	soap_default_int(soap, &this->edlprovider__EdlCreateRequestType::edlFramesPerSecondNumerator);
	soap_default_int(soap, &this->edlprovider__EdlCreateRequestType::edlFramesPerSecondDenominator);
}

void edlprovider__EdlCreateRequestType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->edlprovider__EdlCreateRequestBaseType::soap_serialize(soap);
#endif
}

int edlprovider__EdlCreateRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateRequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateRequestType), "edlprovider:EdlCreateRequestType"))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlType", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlType), ""))
		return soap->error;
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, "clips", -1, &(a->edlprovider__EdlCreateRequestBaseType::clips), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "edlSequenceName", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "edlFramesPerSecondNumerator", -1, &(a->edlprovider__EdlCreateRequestType::edlFramesPerSecondNumerator), ""))
		return soap->error;
	if (soap_out_int(soap, "edlFramesPerSecondDenominator", -1, &(a->edlprovider__EdlCreateRequestType::edlFramesPerSecondDenominator), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateRequestType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateRequestType, sizeof(edlprovider__EdlCreateRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateRequestType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlType2 = 1;
	size_t soap_flag_clips2 = 1;
	size_t soap_flag_edlSequenceName2 = 1;
	size_t soap_flag_edlFramesPerSecondNumerator1 = 1;
	size_t soap_flag_edlFramesPerSecondDenominator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlType2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlType", &(a->edlprovider__EdlCreateRequestBaseType::edlType), "xsd:string"))
				{	soap_flag_edlType2--;
					continue;
				}
			if (soap_flag_clips2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__ArrayOfClips(soap, "clips", &(a->edlprovider__EdlCreateRequestBaseType::clips), "edlprovider:ArrayOfClips"))
				{	soap_flag_clips2--;
					continue;
				}
			if (soap_flag_edlSequenceName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "edlSequenceName", &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), "xsd:string"))
				{	soap_flag_edlSequenceName2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_edlFramesPerSecondNumerator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "edlFramesPerSecondNumerator", &(a->edlprovider__EdlCreateRequestType::edlFramesPerSecondNumerator), "xsd:int"))
				{	soap_flag_edlFramesPerSecondNumerator1--;
					continue;
				}
			if (soap_flag_edlFramesPerSecondDenominator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "edlFramesPerSecondDenominator", &(a->edlprovider__EdlCreateRequestType::edlFramesPerSecondDenominator), "xsd:int"))
				{	soap_flag_edlFramesPerSecondDenominator1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateRequestType, 0, sizeof(edlprovider__EdlCreateRequestType), 0, soap_copy_edlprovider__EdlCreateRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlType2 > 0 || soap_flag_edlFramesPerSecondNumerator1 > 0 || soap_flag_edlFramesPerSecondDenominator1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlCreateRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateRequestType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateRequestType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateRequestType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateRequestType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateRequestType);
		((edlprovider__EdlCreateRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateRequestType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateRequestType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateRequestType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateRequestType*)p = *(edlprovider__EdlCreateRequestType*)q;
}

void edlprovider__EdlCreateRequestBaseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__wstring(soap, &this->edlprovider__EdlCreateRequestBaseType::edlType);
	this->edlprovider__EdlCreateRequestBaseType::clips = NULL;
	this->edlprovider__EdlCreateRequestBaseType::edlSequenceName = NULL;
	/* transient soap skipped */
}

void edlprovider__EdlCreateRequestBaseType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->edlprovider__EdlCreateRequestBaseType::edlType, SOAP_TYPE_std__wstring);
	soap_serialize_std__wstring(soap, &this->edlprovider__EdlCreateRequestBaseType::edlType);
	soap_serialize_PointerToedlprovider__ArrayOfClips(soap, &this->edlprovider__EdlCreateRequestBaseType::clips);
	soap_serialize_PointerTostd__wstring(soap, &this->edlprovider__EdlCreateRequestBaseType::edlSequenceName);
	/* transient soap skipped */
#endif
}

int edlprovider__EdlCreateRequestBaseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__EdlCreateRequestBaseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__EdlCreateRequestBaseType(struct soap *soap, const char *tag, int id, const edlprovider__EdlCreateRequestBaseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType), type))
		return soap->error;
	if (soap_out_std__wstring(soap, "edlType", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlType), ""))
		return soap->error;
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, "clips", -1, &(a->edlprovider__EdlCreateRequestBaseType::clips), ""))
		return soap->error;
	if (soap_out_PointerTostd__wstring(soap, "edlSequenceName", -1, &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__EdlCreateRequestBaseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__EdlCreateRequestBaseType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestBaseType * SOAP_FMAC4 soap_in_edlprovider__EdlCreateRequestBaseType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestBaseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__EdlCreateRequestBaseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType, sizeof(edlprovider__EdlCreateRequestBaseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__EdlCreateRequestBaseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__EdlCreateRequestBaseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_edlType1 = 1;
	size_t soap_flag_clips1 = 1;
	size_t soap_flag_edlSequenceName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__wstring(soap, "edlType", &(a->edlprovider__EdlCreateRequestBaseType::edlType), "xsd:string"))
				{	soap_flag_edlType1--;
					continue;
				}
			if (soap_flag_clips1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__ArrayOfClips(soap, "clips", &(a->edlprovider__EdlCreateRequestBaseType::clips), "edlprovider:ArrayOfClips"))
				{	soap_flag_clips1--;
					continue;
				}
			if (soap_flag_edlSequenceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__wstring(soap, "edlSequenceName", &(a->edlprovider__EdlCreateRequestBaseType::edlSequenceName), "xsd:string"))
				{	soap_flag_edlSequenceName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__EdlCreateRequestBaseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType, 0, sizeof(edlprovider__EdlCreateRequestBaseType), 0, soap_copy_edlprovider__EdlCreateRequestBaseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_edlType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int edlprovider__EdlCreateRequestBaseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType);
	if (this->soap_out(soap, tag?tag:"edlprovider:EdlCreateRequestBaseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__EdlCreateRequestBaseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__EdlCreateRequestBaseType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestBaseType * SOAP_FMAC4 soap_get_edlprovider__EdlCreateRequestBaseType(struct soap *soap, edlprovider__EdlCreateRequestBaseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__EdlCreateRequestBaseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__EdlCreateRequestBaseType * SOAP_FMAC2 soap_instantiate_edlprovider__EdlCreateRequestBaseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__EdlCreateRequestBaseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__EdlCreateRequestBaseType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "edlprovider:EdlCreateRequestType"))
	{	cp->type = SOAP_TYPE_edlprovider__EdlCreateRequestType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestType);
			if (size)
				*size = sizeof(edlprovider__EdlCreateRequestType);
			((edlprovider__EdlCreateRequestType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestType, n);
			if (size)
				*size = n * sizeof(edlprovider__EdlCreateRequestType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((edlprovider__EdlCreateRequestType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (edlprovider__EdlCreateRequestType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "edlprovider:EdlCreateRequestDoubleType"))
	{	cp->type = SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestDoubleType);
			if (size)
				*size = sizeof(edlprovider__EdlCreateRequestDoubleType);
			((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestDoubleType, n);
			if (size)
				*size = n * sizeof(edlprovider__EdlCreateRequestDoubleType);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((edlprovider__EdlCreateRequestDoubleType*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (edlprovider__EdlCreateRequestDoubleType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__EdlCreateRequestBaseType);
		if (size)
			*size = sizeof(edlprovider__EdlCreateRequestBaseType);
		((edlprovider__EdlCreateRequestBaseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__EdlCreateRequestBaseType, n);
		if (size)
			*size = n * sizeof(edlprovider__EdlCreateRequestBaseType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__EdlCreateRequestBaseType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__EdlCreateRequestBaseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__EdlCreateRequestBaseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__EdlCreateRequestBaseType %p -> %p\n", q, p));
	*(edlprovider__EdlCreateRequestBaseType*)p = *(edlprovider__EdlCreateRequestBaseType*)q;
}

void edlprovider__ClipType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void edlprovider__ClipType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int edlprovider__ClipType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__ClipType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__ClipType(struct soap *soap, const char *tag, int id, const edlprovider__ClipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__ClipType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__ClipType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__ClipType(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__ClipType * SOAP_FMAC4 soap_in_edlprovider__ClipType(struct soap *soap, const char *tag, edlprovider__ClipType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__ClipType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__ClipType, sizeof(edlprovider__ClipType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__ClipType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__ClipType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__ClipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__ClipType, 0, sizeof(edlprovider__ClipType), 0, soap_copy_edlprovider__ClipType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int edlprovider__ClipType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__ClipType);
	if (this->soap_out(soap, tag?tag:"edlprovider:ClipType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__ClipType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__ClipType(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__ClipType * SOAP_FMAC4 soap_get_edlprovider__ClipType(struct soap *soap, edlprovider__ClipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__ClipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__ClipType * SOAP_FMAC2 soap_instantiate_edlprovider__ClipType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__ClipType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__ClipType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__ClipType);
		if (size)
			*size = sizeof(edlprovider__ClipType);
		((edlprovider__ClipType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__ClipType, n);
		if (size)
			*size = n * sizeof(edlprovider__ClipType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__ClipType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__ClipType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__ClipType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__ClipType %p -> %p\n", q, p));
	*(edlprovider__ClipType*)p = *(edlprovider__ClipType*)q;
}

void edlprovider__ArrayOfClips::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, &this->edlprovider__ArrayOfClips::clip);
	/* transient soap skipped */
}

void edlprovider__ArrayOfClips::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, &this->edlprovider__ArrayOfClips::clip);
	/* transient soap skipped */
#endif
}

int edlprovider__ArrayOfClips::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__ArrayOfClips(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__ArrayOfClips(struct soap *soap, const char *tag, int id, const edlprovider__ArrayOfClips *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__ArrayOfClips), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, "clip", -1, &(a->edlprovider__ArrayOfClips::clip), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__ArrayOfClips::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__ArrayOfClips(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__ArrayOfClips * SOAP_FMAC4 soap_in_edlprovider__ArrayOfClips(struct soap *soap, const char *tag, edlprovider__ArrayOfClips *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__ArrayOfClips *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__ArrayOfClips, sizeof(edlprovider__ArrayOfClips), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__ArrayOfClips)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__ArrayOfClips *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, "clip", &(a->edlprovider__ArrayOfClips::clip), "edlprovider:ClipType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__ArrayOfClips *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__ArrayOfClips, 0, sizeof(edlprovider__ArrayOfClips), 0, soap_copy_edlprovider__ArrayOfClips);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int edlprovider__ArrayOfClips::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__ArrayOfClips);
	if (this->soap_out(soap, tag?tag:"edlprovider:ArrayOfClips", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__ArrayOfClips::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__ArrayOfClips(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__ArrayOfClips * SOAP_FMAC4 soap_get_edlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__ArrayOfClips(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__ArrayOfClips * SOAP_FMAC2 soap_instantiate_edlprovider__ArrayOfClips(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__ArrayOfClips(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__ArrayOfClips, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__ArrayOfClips);
		if (size)
			*size = sizeof(edlprovider__ArrayOfClips);
		((edlprovider__ArrayOfClips*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__ArrayOfClips, n);
		if (size)
			*size = n * sizeof(edlprovider__ArrayOfClips);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__ArrayOfClips*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__ArrayOfClips*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__ArrayOfClips(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__ArrayOfClips %p -> %p\n", q, p));
	*(edlprovider__ArrayOfClips*)p = *(edlprovider__ArrayOfClips*)q;
}

void edlprovider__ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__wstring(soap, &this->edlprovider__ArrayOfstring::string);
	/* transient soap skipped */
}

void edlprovider__ArrayOfstring::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__wstring(soap, &this->edlprovider__ArrayOfstring::string);
	/* transient soap skipped */
#endif
}

int edlprovider__ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_edlprovider__ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_edlprovider__ArrayOfstring(struct soap *soap, const char *tag, int id, const edlprovider__ArrayOfstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_edlprovider__ArrayOfstring), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__wstring(soap, "string", -1, &(a->edlprovider__ArrayOfstring::string), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *edlprovider__ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_edlprovider__ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 edlprovider__ArrayOfstring * SOAP_FMAC4 soap_in_edlprovider__ArrayOfstring(struct soap *soap, const char *tag, edlprovider__ArrayOfstring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (edlprovider__ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_edlprovider__ArrayOfstring, sizeof(edlprovider__ArrayOfstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_edlprovider__ArrayOfstring)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (edlprovider__ArrayOfstring *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__wstring(soap, "string", &(a->edlprovider__ArrayOfstring::string), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (edlprovider__ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_edlprovider__ArrayOfstring, 0, sizeof(edlprovider__ArrayOfstring), 0, soap_copy_edlprovider__ArrayOfstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int edlprovider__ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_edlprovider__ArrayOfstring);
	if (this->soap_out(soap, tag?tag:"edlprovider:ArrayOfstring", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *edlprovider__ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_edlprovider__ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 edlprovider__ArrayOfstring * SOAP_FMAC4 soap_get_edlprovider__ArrayOfstring(struct soap *soap, edlprovider__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_edlprovider__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 edlprovider__ArrayOfstring * SOAP_FMAC2 soap_instantiate_edlprovider__ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_edlprovider__ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_edlprovider__ArrayOfstring, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(edlprovider__ArrayOfstring);
		if (size)
			*size = sizeof(edlprovider__ArrayOfstring);
		((edlprovider__ArrayOfstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(edlprovider__ArrayOfstring, n);
		if (size)
			*size = n * sizeof(edlprovider__ArrayOfstring);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((edlprovider__ArrayOfstring*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (edlprovider__ArrayOfstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_edlprovider__ArrayOfstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying edlprovider__ArrayOfstring %p -> %p\n", q, p));
	*(edlprovider__ArrayOfstring*)p = *(edlprovider__ArrayOfstring*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__time(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__time(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__time), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__time(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__time, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__time, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__time, 0, sizeof(std::wstring), 0, soap_copy_xsd__time);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__time(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__time);
	if (soap_out_xsd__time(soap, tag?tag:"xsd:time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__time(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__positiveInteger(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__positiveInteger), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__positiveInteger, 0, sizeof(std::wstring), 0, soap_copy_xsd__positiveInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag?tag:"xsd:positiveInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::wstring), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__language(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__language(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__language), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__language(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__language, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__language, 0, sizeof(std::wstring), 0, soap_copy_xsd__language);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__language(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__language);
	if (soap_out_xsd__language(soap, tag?tag:"xsd:language", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__language(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::wstring), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__gYear(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__gYear(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__gYear), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__gYear(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__gYear, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__gYear, 0, sizeof(std::wstring), 0, soap_copy_xsd__gYear);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__gYear(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__gYear);
	if (soap_out_xsd__gYear(soap, tag?tag:"xsd:gYear", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__gYear(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__gYear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::wstring), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__date), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__date, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__date, 0, sizeof(std::wstring), 0, soap_copy_xsd__date);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::wstring), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NMTOKEN(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NMTOKEN), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NMTOKEN, 0, sizeof(std::wstring), 0, soap_copy_xsd__NMTOKEN);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NMTOKEN);
	if (soap_out_xsd__NMTOKEN(soap, tag?tag:"xsd:NMTOKEN", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__wstring(struct soap *soap, std::wstring *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__wstring(struct soap *soap, const std::wstring *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__wstring(struct soap *soap, const char *tag, int id, const std::wstring *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__wstring), type) || soap_wstring_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_in_std__wstring(struct soap *soap, const char *tag, std::wstring *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__wstring(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	wchar_t *t;
		s = (std::wstring*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_wstring_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::wstring*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__wstring, sizeof(std::wstring), soap->type, soap->arrayType), 0, SOAP_TYPE_std__wstring, 0, sizeof(std::wstring), 0, soap_copy_std__wstring);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__wstring(struct soap *soap, const std::wstring *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__wstring);
	if (soap_out_std__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring * SOAP_FMAC4 soap_get_std__wstring(struct soap *soap, std::wstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::wstring * SOAP_FMAC2 soap_instantiate_std__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__wstring, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::wstring);
		if (size)
			*size = sizeof(std::wstring);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::wstring, n);
		if (size)
			*size = n * sizeof(std::wstring);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::wstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::wstring %p -> %p\n", q, p));
	*(std::wstring*)p = *(std::wstring*)q;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__size = 0;
	this->__ptr = NULL;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr)
		soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__hexBinary);
#endif
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__hexBinary);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, 0, sizeof(xsd__hexBinary), 0, soap_copy_xsd__hexBinary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__hexBinary);
	if (this->soap_out(soap, tag?tag:"xsd:hexBinary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__hexBinary, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__hexBinary);
		if (size)
			*size = sizeof(xsd__hexBinary);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__hexBinary, n);
		if (size)
			*size = n * sizeof(xsd__hexBinary);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__hexBinary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__hexBinary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__hexBinary %p -> %p\n", q, p));
	*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___edlprovider__getEdlDouble(struct soap *soap, struct __edlprovider__getEdlDouble *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->edlprovider__getEdlDoubleRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___edlprovider__getEdlDouble(struct soap *soap, const struct __edlprovider__getEdlDouble *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EdlCreateRequestDoubleType(soap, &a->edlprovider__getEdlDoubleRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___edlprovider__getEdlDouble(struct soap *soap, const char *tag, int id, const struct __edlprovider__getEdlDouble *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(soap, "edlprovider:getEdlDoubleRequest", -1, &a->edlprovider__getEdlDoubleRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdlDouble * SOAP_FMAC4 soap_in___edlprovider__getEdlDouble(struct soap *soap, const char *tag, struct __edlprovider__getEdlDouble *a, const char *type)
{
	size_t soap_flag_edlprovider__getEdlDoubleRequest = 1;
	short soap_flag;
	a = (struct __edlprovider__getEdlDouble *)soap_id_enter(soap, "", a, SOAP_TYPE___edlprovider__getEdlDouble, sizeof(struct __edlprovider__getEdlDouble), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___edlprovider__getEdlDouble(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlprovider__getEdlDoubleRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(soap, "edlprovider:getEdlDoubleRequest", &a->edlprovider__getEdlDoubleRequest, "edlprovider:EdlCreateRequestDoubleType"))
				{	soap_flag_edlprovider__getEdlDoubleRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___edlprovider__getEdlDouble(struct soap *soap, const struct __edlprovider__getEdlDouble *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___edlprovider__getEdlDouble(soap, tag?tag:"-edlprovider:getEdlDouble", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdlDouble * SOAP_FMAC4 soap_get___edlprovider__getEdlDouble(struct soap *soap, struct __edlprovider__getEdlDouble *p, const char *tag, const char *type)
{
	if ((p = soap_in___edlprovider__getEdlDouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __edlprovider__getEdlDouble * SOAP_FMAC2 soap_instantiate___edlprovider__getEdlDouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___edlprovider__getEdlDouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___edlprovider__getEdlDouble, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __edlprovider__getEdlDouble);
		if (size)
			*size = sizeof(struct __edlprovider__getEdlDouble);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __edlprovider__getEdlDouble, n);
		if (size)
			*size = n * sizeof(struct __edlprovider__getEdlDouble);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __edlprovider__getEdlDouble*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___edlprovider__getEdlDouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __edlprovider__getEdlDouble %p -> %p\n", q, p));
	*(struct __edlprovider__getEdlDouble*)p = *(struct __edlprovider__getEdlDouble*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___edlprovider__getEdl(struct soap *soap, struct __edlprovider__getEdl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->edlprovider__getEdlRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___edlprovider__getEdl(struct soap *soap, const struct __edlprovider__getEdl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EdlCreateRequestType(soap, &a->edlprovider__getEdlRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___edlprovider__getEdl(struct soap *soap, const char *tag, int id, const struct __edlprovider__getEdl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerToedlprovider__EdlCreateRequestType(soap, "edlprovider:getEdlRequest", -1, &a->edlprovider__getEdlRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdl * SOAP_FMAC4 soap_in___edlprovider__getEdl(struct soap *soap, const char *tag, struct __edlprovider__getEdl *a, const char *type)
{
	size_t soap_flag_edlprovider__getEdlRequest = 1;
	short soap_flag;
	a = (struct __edlprovider__getEdl *)soap_id_enter(soap, "", a, SOAP_TYPE___edlprovider__getEdl, sizeof(struct __edlprovider__getEdl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___edlprovider__getEdl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlprovider__getEdlRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EdlCreateRequestType(soap, "edlprovider:getEdlRequest", &a->edlprovider__getEdlRequest, "edlprovider:EdlCreateRequestType"))
				{	soap_flag_edlprovider__getEdlRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___edlprovider__getEdl(struct soap *soap, const struct __edlprovider__getEdl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___edlprovider__getEdl(soap, tag?tag:"-edlprovider:getEdl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getEdl * SOAP_FMAC4 soap_get___edlprovider__getEdl(struct soap *soap, struct __edlprovider__getEdl *p, const char *tag, const char *type)
{
	if ((p = soap_in___edlprovider__getEdl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __edlprovider__getEdl * SOAP_FMAC2 soap_instantiate___edlprovider__getEdl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___edlprovider__getEdl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___edlprovider__getEdl, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __edlprovider__getEdl);
		if (size)
			*size = sizeof(struct __edlprovider__getEdl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __edlprovider__getEdl, n);
		if (size)
			*size = n * sizeof(struct __edlprovider__getEdl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __edlprovider__getEdl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___edlprovider__getEdl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __edlprovider__getEdl %p -> %p\n", q, p));
	*(struct __edlprovider__getEdl*)p = *(struct __edlprovider__getEdl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___edlprovider__getInstalledEdls(struct soap *soap, struct __edlprovider__getInstalledEdls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___edlprovider__getInstalledEdls(struct soap *soap, const struct __edlprovider__getInstalledEdls *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___edlprovider__getInstalledEdls(struct soap *soap, const char *tag, int id, const struct __edlprovider__getInstalledEdls *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getInstalledEdls * SOAP_FMAC4 soap_in___edlprovider__getInstalledEdls(struct soap *soap, const char *tag, struct __edlprovider__getInstalledEdls *a, const char *type)
{
	a = (struct __edlprovider__getInstalledEdls *)soap_id_enter(soap, "", a, SOAP_TYPE___edlprovider__getInstalledEdls, sizeof(struct __edlprovider__getInstalledEdls), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___edlprovider__getInstalledEdls(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___edlprovider__getInstalledEdls(struct soap *soap, const struct __edlprovider__getInstalledEdls *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___edlprovider__getInstalledEdls(soap, tag?tag:"-edlprovider:getInstalledEdls", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __edlprovider__getInstalledEdls * SOAP_FMAC4 soap_get___edlprovider__getInstalledEdls(struct soap *soap, struct __edlprovider__getInstalledEdls *p, const char *tag, const char *type)
{
	if ((p = soap_in___edlprovider__getInstalledEdls(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __edlprovider__getInstalledEdls * SOAP_FMAC2 soap_instantiate___edlprovider__getInstalledEdls(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___edlprovider__getInstalledEdls(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___edlprovider__getInstalledEdls, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __edlprovider__getInstalledEdls);
		if (size)
			*size = sizeof(struct __edlprovider__getInstalledEdls);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __edlprovider__getInstalledEdls, n);
		if (size)
			*size = n * sizeof(struct __edlprovider__getInstalledEdls);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __edlprovider__getInstalledEdls*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___edlprovider__getInstalledEdls(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __edlprovider__getInstalledEdls %p -> %p\n", q, p));
	*(struct __edlprovider__getInstalledEdls*)p = *(struct __edlprovider__getInstalledEdls*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->edlprovider__edlProviderFault = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToedlprovider__EdlProviderFaultType(soap, &a->edlprovider__edlProviderFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerToedlprovider__EdlProviderFaultType(soap, "edlprovider:edlProviderFault", -1, &a->edlprovider__edlProviderFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_edlprovider__edlProviderFault = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_edlprovider__edlProviderFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToedlprovider__EdlProviderFaultType(soap, "edlprovider:edlProviderFault", &a->edlprovider__edlProviderFault, "edlprovider:EdlProviderFaultType"))
				{	soap_flag_edlprovider__edlProviderFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fims__union_TimeType(struct soap *soap, int choice, const union _fims__union_TimeType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fims__union_TimeType_timecode:
		soap_serialize_PointerTofims__Timecode(soap, &a->timecode);
		break;
	case SOAP_UNION__fims__union_TimeType_normalPlayTime:
		soap_serialize_PointerToxsd__time(soap, &a->normalPlayTime);
		break;
	case SOAP_UNION__fims__union_TimeType_editUnitNumber:
		soap_serialize_PointerTofims__EditUnitNumberType(soap, &a->editUnitNumber);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__union_TimeType(struct soap *soap, int choice, const union _fims__union_TimeType *a)
{
	switch (choice)
	{
	case SOAP_UNION__fims__union_TimeType_timecode:
		return soap_out_PointerTofims__Timecode(soap, "fims:timecode", -1, &a->timecode, "");
	case SOAP_UNION__fims__union_TimeType_normalPlayTime:
		return soap_out_PointerToxsd__time(soap, "fims:normalPlayTime", -1, &a->normalPlayTime, "");
	case SOAP_UNION__fims__union_TimeType_editUnitNumber:
		return soap_out_PointerTofims__EditUnitNumberType(soap, "fims:editUnitNumber", -1, &a->editUnitNumber, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fims__union_TimeType * SOAP_FMAC4 soap_in__fims__union_TimeType(struct soap *soap, int *choice, union _fims__union_TimeType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->timecode = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__Timecode(soap, "fims:timecode", &a->timecode, "fims:Timecode"))
	{	*choice = SOAP_UNION__fims__union_TimeType_timecode;
		return a;
	}
	a->normalPlayTime = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxsd__time(soap, "fims:normalPlayTime", &a->normalPlayTime, "xsd:time"))
	{	*choice = SOAP_UNION__fims__union_TimeType_normalPlayTime;
		return a;
	}
	a->editUnitNumber = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__EditUnitNumberType(soap, "fims:editUnitNumber", &a->editUnitNumber, "fims:EditUnitNumberType"))
	{	*choice = SOAP_UNION__fims__union_TimeType_editUnitNumber;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__fims__union_DurationType(struct soap *soap, int choice, const union _fims__union_DurationType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__fims__union_DurationType_timecode:
		soap_serialize_PointerTofims__TimecodeDuration(soap, &a->timecode);
		break;
	case SOAP_UNION__fims__union_DurationType_normalPlayTime:
		soap_serialize_PointerToxsd__duration(soap, &a->normalPlayTime);
		break;
	case SOAP_UNION__fims__union_DurationType_editUnitNumber:
		soap_serialize_PointerTofims__EditUnitNumberType(soap, &a->editUnitNumber);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__fims__union_DurationType(struct soap *soap, int choice, const union _fims__union_DurationType *a)
{
	switch (choice)
	{
	case SOAP_UNION__fims__union_DurationType_timecode:
		return soap_out_PointerTofims__TimecodeDuration(soap, "fims:timecode", -1, &a->timecode, "");
	case SOAP_UNION__fims__union_DurationType_normalPlayTime:
		return soap_out_PointerToxsd__duration(soap, "fims:normalPlayTime", -1, &a->normalPlayTime, "");
	case SOAP_UNION__fims__union_DurationType_editUnitNumber:
		return soap_out_PointerTofims__EditUnitNumberType(soap, "fims:editUnitNumber", -1, &a->editUnitNumber, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _fims__union_DurationType * SOAP_FMAC4 soap_in__fims__union_DurationType(struct soap *soap, int *choice, union _fims__union_DurationType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->timecode = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__TimecodeDuration(soap, "fims:timecode", &a->timecode, "fims:TimecodeDuration"))
	{	*choice = SOAP_UNION__fims__union_DurationType_timecode;
		return a;
	}
	a->normalPlayTime = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerToxsd__duration(soap, "fims:normalPlayTime", &a->normalPlayTime, "xsd:duration"))
	{	*choice = SOAP_UNION__fims__union_DurationType_normalPlayTime;
		return a;
	}
	a->editUnitNumber = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTofims__EditUnitNumberType(soap, "fims:editUnitNumber", &a->editUnitNumber, "fims:EditUnitNumberType"))
	{	*choice = SOAP_UNION__fims__union_DurationType_editUnitNumber;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, int id, edlprovider__EdlCreateRequestDoubleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestDoubleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__EdlCreateRequestDoubleType **)soap_malloc(soap, sizeof(edlprovider__EdlCreateRequestDoubleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__EdlCreateRequestDoubleType *)soap_instantiate_edlprovider__EdlCreateRequestDoubleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__EdlCreateRequestDoubleType ** p = (edlprovider__EdlCreateRequestDoubleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType, sizeof(edlprovider__EdlCreateRequestDoubleType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlCreateRequestDoubleType);
	if (soap_out_PointerToedlprovider__EdlCreateRequestDoubleType(soap, tag?tag:"edlprovider:EdlCreateRequestDoubleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestDoubleType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlCreateRequestDoubleType(struct soap *soap, edlprovider__EdlCreateRequestDoubleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlCreateRequestDoubleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlCreateResponseType(struct soap *soap, edlprovider__EdlCreateResponseType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlCreateResponseType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlCreateResponseType(struct soap *soap, const char *tag, int id, edlprovider__EdlCreateResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlCreateResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__EdlCreateResponseType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlCreateResponseType(struct soap *soap, const char *tag, edlprovider__EdlCreateResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__EdlCreateResponseType **)soap_malloc(soap, sizeof(edlprovider__EdlCreateResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__EdlCreateResponseType *)soap_instantiate_edlprovider__EdlCreateResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__EdlCreateResponseType ** p = (edlprovider__EdlCreateResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlCreateResponseType, sizeof(edlprovider__EdlCreateResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlCreateResponseType(struct soap *soap, edlprovider__EdlCreateResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlCreateResponseType);
	if (soap_out_PointerToedlprovider__EdlCreateResponseType(soap, tag?tag:"edlprovider:EdlCreateResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__EdlCreateResponseType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlCreateResponseType(struct soap *soap, edlprovider__EdlCreateResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlCreateResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlCreateRequestType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, int id, edlprovider__EdlCreateRequestType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlCreateRequestType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, const char *tag, edlprovider__EdlCreateRequestType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__EdlCreateRequestType **)soap_malloc(soap, sizeof(edlprovider__EdlCreateRequestType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__EdlCreateRequestType *)soap_instantiate_edlprovider__EdlCreateRequestType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__EdlCreateRequestType ** p = (edlprovider__EdlCreateRequestType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlCreateRequestType, sizeof(edlprovider__EdlCreateRequestType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlCreateRequestType);
	if (soap_out_PointerToedlprovider__EdlCreateRequestType(soap, tag?tag:"edlprovider:EdlCreateRequestType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__EdlCreateRequestType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlCreateRequestType(struct soap *soap, edlprovider__EdlCreateRequestType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlCreateRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__ArrayOfstring(struct soap *soap, edlprovider__ArrayOfstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__ArrayOfstring))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__ArrayOfstring(struct soap *soap, const char *tag, int id, edlprovider__ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__ArrayOfstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__ArrayOfstring ** SOAP_FMAC4 soap_in_PointerToedlprovider__ArrayOfstring(struct soap *soap, const char *tag, edlprovider__ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__ArrayOfstring **)soap_malloc(soap, sizeof(edlprovider__ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__ArrayOfstring *)soap_instantiate_edlprovider__ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__ArrayOfstring ** p = (edlprovider__ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__ArrayOfstring, sizeof(edlprovider__ArrayOfstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__ArrayOfstring(struct soap *soap, edlprovider__ArrayOfstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__ArrayOfstring);
	if (soap_out_PointerToedlprovider__ArrayOfstring(soap, tag?tag:"edlprovider:ArrayOfstring", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__ArrayOfstring ** SOAP_FMAC4 soap_get_PointerToedlprovider__ArrayOfstring(struct soap *soap, edlprovider__ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__EdlProviderFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, int id, edlprovider__EdlProviderFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EdlProviderFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, const char *tag, edlprovider__EdlProviderFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__EdlProviderFaultType **)soap_malloc(soap, sizeof(edlprovider__EdlProviderFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__EdlProviderFaultType *)soap_instantiate_edlprovider__EdlProviderFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__EdlProviderFaultType ** p = (edlprovider__EdlProviderFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EdlProviderFaultType, sizeof(edlprovider__EdlProviderFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EdlProviderFaultType);
	if (soap_out_PointerToedlprovider__EdlProviderFaultType(soap, tag?tag:"edlprovider:EdlProviderFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__EdlProviderFaultType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EdlProviderFaultType(struct soap *soap, edlprovider__EdlProviderFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EdlProviderFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__ContainerFormatType_containerFormat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, int id, _fims__ContainerFormatType_containerFormat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__ContainerFormatType_containerFormat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat ** SOAP_FMAC4 soap_in_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, const char *tag, _fims__ContainerFormatType_containerFormat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__ContainerFormatType_containerFormat **)soap_malloc(soap, sizeof(_fims__ContainerFormatType_containerFormat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__ContainerFormatType_containerFormat *)soap_instantiate__fims__ContainerFormatType_containerFormat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__ContainerFormatType_containerFormat ** p = (_fims__ContainerFormatType_containerFormat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__ContainerFormatType_containerFormat, sizeof(_fims__ContainerFormatType_containerFormat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__ContainerFormatType_containerFormat);
	if (soap_out_PointerTo_fims__ContainerFormatType_containerFormat(soap, tag?tag:"fims:ContainerFormatType-containerFormat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__ContainerFormatType_containerFormat ** SOAP_FMAC4 soap_get_PointerTo_fims__ContainerFormatType_containerFormat(struct soap *soap, _fims__ContainerFormatType_containerFormat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__ContainerFormatType_containerFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__AncillaryDataFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, int id, fims__AncillaryDataFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AncillaryDataFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__AncillaryDataFormatType ** SOAP_FMAC4 soap_in_PointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, fims__AncillaryDataFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__AncillaryDataFormatType **)soap_malloc(soap, sizeof(fims__AncillaryDataFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__AncillaryDataFormatType *)soap_instantiate_fims__AncillaryDataFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__AncillaryDataFormatType ** p = (fims__AncillaryDataFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AncillaryDataFormatType, sizeof(fims__AncillaryDataFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AncillaryDataFormatType);
	if (soap_out_PointerTofims__AncillaryDataFormatType(soap, tag?tag:"fims:AncillaryDataFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__AncillaryDataFormatType ** SOAP_FMAC4 soap_get_PointerTofims__AncillaryDataFormatType(struct soap *soap, fims__AncillaryDataFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AncillaryDataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CaptioningFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, int id, fims__CaptioningFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CaptioningFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CaptioningFormatType ** SOAP_FMAC4 soap_in_PointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, fims__CaptioningFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CaptioningFormatType **)soap_malloc(soap, sizeof(fims__CaptioningFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CaptioningFormatType *)soap_instantiate_fims__CaptioningFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CaptioningFormatType ** p = (fims__CaptioningFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CaptioningFormatType, sizeof(fims__CaptioningFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CaptioningFormatType);
	if (soap_out_PointerTofims__CaptioningFormatType(soap, tag?tag:"fims:CaptioningFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CaptioningFormatType ** SOAP_FMAC4 soap_get_PointerTofims__CaptioningFormatType(struct soap *soap, fims__CaptioningFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CaptioningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__AudioSampleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AudioSampleType(struct soap *soap, const char *tag, int id, enum fims__AudioSampleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AudioSampleType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__AudioSampleType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__AudioSampleType ** SOAP_FMAC4 soap_in_PointerTofims__AudioSampleType(struct soap *soap, const char *tag, enum fims__AudioSampleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__AudioSampleType **)soap_malloc(soap, sizeof(enum fims__AudioSampleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__AudioSampleType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__AudioSampleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AudioSampleType, sizeof(enum fims__AudioSampleType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AudioSampleType);
	if (soap_out_PointerTofims__AudioSampleType(soap, tag?tag:"fims:AudioSampleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__AudioSampleType ** SOAP_FMAC4 soap_get_PointerTofims__AudioSampleType(struct soap *soap, enum fims__AudioSampleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AudioSampleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, int id, _fims__AudioFormatType_trackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__AudioFormatType_trackConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration ** SOAP_FMAC4 soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, const char *tag, _fims__AudioFormatType_trackConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__AudioFormatType_trackConfiguration **)soap_malloc(soap, sizeof(_fims__AudioFormatType_trackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__AudioFormatType_trackConfiguration *)soap_instantiate__fims__AudioFormatType_trackConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__AudioFormatType_trackConfiguration ** p = (_fims__AudioFormatType_trackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__AudioFormatType_trackConfiguration, sizeof(_fims__AudioFormatType_trackConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__AudioFormatType_trackConfiguration);
	if (soap_out_PointerTo_fims__AudioFormatType_trackConfiguration(soap, tag?tag:"fims:AudioFormatType-trackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__AudioFormatType_trackConfiguration ** SOAP_FMAC4 soap_get_PointerTo_fims__AudioFormatType_trackConfiguration(struct soap *soap, _fims__AudioFormatType_trackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__AudioFormatType_trackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__decimal))
		soap_serialize_xsd__decimal(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__decimal(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__decimal);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__decimal(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__decimal(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__decimal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__decimal, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__decimal(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__decimal);
	if (soap_out_PointerToxsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__decimal(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__ScanningOrderType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ScanningOrderType(struct soap *soap, const char *tag, int id, enum fims__ScanningOrderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ScanningOrderType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__ScanningOrderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__ScanningOrderType ** SOAP_FMAC4 soap_in_PointerTofims__ScanningOrderType(struct soap *soap, const char *tag, enum fims__ScanningOrderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__ScanningOrderType **)soap_malloc(soap, sizeof(enum fims__ScanningOrderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__ScanningOrderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningOrderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ScanningOrderType, sizeof(enum fims__ScanningOrderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ScanningOrderType);
	if (soap_out_PointerTofims__ScanningOrderType(soap, tag?tag:"fims:ScanningOrderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningOrderType ** SOAP_FMAC4 soap_get_PointerTofims__ScanningOrderType(struct soap *soap, enum fims__ScanningOrderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ScanningOrderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__ScanningFormatType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ScanningFormatType(struct soap *soap, const char *tag, int id, enum fims__ScanningFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ScanningFormatType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__ScanningFormatType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__ScanningFormatType ** SOAP_FMAC4 soap_in_PointerTofims__ScanningFormatType(struct soap *soap, const char *tag, enum fims__ScanningFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__ScanningFormatType **)soap_malloc(soap, sizeof(enum fims__ScanningFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__ScanningFormatType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__ScanningFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ScanningFormatType, sizeof(enum fims__ScanningFormatType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ScanningFormatType);
	if (soap_out_PointerTofims__ScanningFormatType(soap, tag?tag:"fims:ScanningFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__ScanningFormatType ** SOAP_FMAC4 soap_get_PointerTofims__ScanningFormatType(struct soap *soap, enum fims__ScanningFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ScanningFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__BitRateModeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BitRateModeType(struct soap *soap, const char *tag, int id, enum fims__BitRateModeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BitRateModeType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__BitRateModeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__BitRateModeType ** SOAP_FMAC4 soap_in_PointerTofims__BitRateModeType(struct soap *soap, const char *tag, enum fims__BitRateModeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__BitRateModeType **)soap_malloc(soap, sizeof(enum fims__BitRateModeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__BitRateModeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__BitRateModeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BitRateModeType, sizeof(enum fims__BitRateModeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BitRateModeType);
	if (soap_out_PointerTofims__BitRateModeType(soap, tag?tag:"fims:BitRateModeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__BitRateModeType ** SOAP_FMAC4 soap_get_PointerTofims__BitRateModeType(struct soap *soap, enum fims__BitRateModeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BitRateModeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMTrackType(struct soap *soap, fims__BMTrackType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMTrackType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMTrackType(struct soap *soap, const char *tag, int id, fims__BMTrackType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMTrackType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMTrackType ** SOAP_FMAC4 soap_in_PointerTofims__BMTrackType(struct soap *soap, const char *tag, fims__BMTrackType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMTrackType **)soap_malloc(soap, sizeof(fims__BMTrackType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMTrackType *)soap_instantiate_fims__BMTrackType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMTrackType ** p = (fims__BMTrackType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMTrackType, sizeof(fims__BMTrackType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMTrackType(struct soap *soap, fims__BMTrackType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMTrackType);
	if (soap_out_PointerTofims__BMTrackType(soap, tag?tag:"fims:BMTrackType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMTrackType ** SOAP_FMAC4 soap_get_PointerTofims__BMTrackType(struct soap *soap, fims__BMTrackType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMTrackType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__CodecType(struct soap *soap, fims__CodecType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__CodecType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__CodecType(struct soap *soap, const char *tag, int id, fims__CodecType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__CodecType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__CodecType ** SOAP_FMAC4 soap_in_PointerTofims__CodecType(struct soap *soap, const char *tag, fims__CodecType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__CodecType **)soap_malloc(soap, sizeof(fims__CodecType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__CodecType *)soap_instantiate_fims__CodecType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__CodecType ** p = (fims__CodecType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__CodecType, sizeof(fims__CodecType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__CodecType(struct soap *soap, fims__CodecType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__CodecType);
	if (soap_out_PointerTofims__CodecType(soap, tag?tag:"fims:CodecType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__CodecType ** SOAP_FMAC4 soap_get_PointerTofims__CodecType(struct soap *soap, fims__CodecType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__CodecType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__RationalType(struct soap *soap, fims__RationalType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__RationalType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__RationalType(struct soap *soap, const char *tag, int id, fims__RationalType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__RationalType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__RationalType ** SOAP_FMAC4 soap_in_PointerTofims__RationalType(struct soap *soap, const char *tag, fims__RationalType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__RationalType **)soap_malloc(soap, sizeof(fims__RationalType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__RationalType *)soap_instantiate_fims__RationalType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__RationalType ** p = (fims__RationalType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__RationalType, sizeof(fims__RationalType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__RationalType(struct soap *soap, fims__RationalType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__RationalType);
	if (soap_out_PointerTofims__RationalType(soap, tag?tag:"fims:RationalType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__RationalType ** SOAP_FMAC4 soap_get_PointerTofims__RationalType(struct soap *soap, fims__RationalType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__RationalType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__LengthType(struct soap *soap, fims__LengthType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__LengthType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__LengthType(struct soap *soap, const char *tag, int id, fims__LengthType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__LengthType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__LengthType ** SOAP_FMAC4 soap_in_PointerTofims__LengthType(struct soap *soap, const char *tag, fims__LengthType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__LengthType **)soap_malloc(soap, sizeof(fims__LengthType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__LengthType *)soap_instantiate_fims__LengthType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__LengthType ** p = (fims__LengthType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__LengthType, sizeof(fims__LengthType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__LengthType(struct soap *soap, fims__LengthType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__LengthType);
	if (soap_out_PointerTofims__LengthType(soap, tag?tag:"fims:LengthType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__LengthType ** SOAP_FMAC4 soap_get_PointerTofims__LengthType(struct soap *soap, fims__LengthType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__LengthType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, int id, _fims__BMEssenceLocatorType_containerMimeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType ** SOAP_FMAC4 soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, const char *tag, _fims__BMEssenceLocatorType_containerMimeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__BMEssenceLocatorType_containerMimeType **)soap_malloc(soap, sizeof(_fims__BMEssenceLocatorType_containerMimeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__BMEssenceLocatorType_containerMimeType *)soap_instantiate__fims__BMEssenceLocatorType_containerMimeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__BMEssenceLocatorType_containerMimeType ** p = (_fims__BMEssenceLocatorType_containerMimeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType, sizeof(_fims__BMEssenceLocatorType_containerMimeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__BMEssenceLocatorType_containerMimeType);
	if (soap_out_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, tag?tag:"fims:BMEssenceLocatorType-containerMimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__BMEssenceLocatorType_containerMimeType ** SOAP_FMAC4 soap_get_PointerTo_fims__BMEssenceLocatorType_containerMimeType(struct soap *soap, _fims__BMEssenceLocatorType_containerMimeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__BMEssenceLocatorType_containerMimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__StorageType(struct soap *soap, fims__StorageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__StorageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__StorageType(struct soap *soap, const char *tag, int id, fims__StorageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__StorageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__StorageType ** SOAP_FMAC4 soap_in_PointerTofims__StorageType(struct soap *soap, const char *tag, fims__StorageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__StorageType **)soap_malloc(soap, sizeof(fims__StorageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__StorageType *)soap_instantiate_fims__StorageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__StorageType ** p = (fims__StorageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StorageType, sizeof(fims__StorageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__StorageType(struct soap *soap, fims__StorageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__StorageType);
	if (soap_out_PointerTofims__StorageType(soap, tag?tag:"fims:StorageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__StorageType ** SOAP_FMAC4 soap_get_PointerTofims__StorageType(struct soap *soap, fims__StorageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__StorageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__BMContentFormatType_mimeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, int id, _fims__BMContentFormatType_mimeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__BMContentFormatType_mimeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType ** SOAP_FMAC4 soap_in_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, const char *tag, _fims__BMContentFormatType_mimeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__BMContentFormatType_mimeType **)soap_malloc(soap, sizeof(_fims__BMContentFormatType_mimeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__BMContentFormatType_mimeType *)soap_instantiate__fims__BMContentFormatType_mimeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__BMContentFormatType_mimeType ** p = (_fims__BMContentFormatType_mimeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__BMContentFormatType_mimeType, sizeof(_fims__BMContentFormatType_mimeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__BMContentFormatType_mimeType);
	if (soap_out_PointerTo_fims__BMContentFormatType_mimeType(soap, tag?tag:"fims:BMContentFormatType-mimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__BMContentFormatType_mimeType ** SOAP_FMAC4 soap_get_PointerTo_fims__BMContentFormatType_mimeType(struct soap *soap, _fims__BMContentFormatType_mimeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__BMContentFormatType_mimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedLONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__HashType(struct soap *soap, fims__HashType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__HashType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__HashType(struct soap *soap, const char *tag, int id, fims__HashType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__HashType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__HashType ** SOAP_FMAC4 soap_in_PointerTofims__HashType(struct soap *soap, const char *tag, fims__HashType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__HashType **)soap_malloc(soap, sizeof(fims__HashType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__HashType *)soap_instantiate_fims__HashType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__HashType ** p = (fims__HashType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__HashType, sizeof(fims__HashType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__HashType(struct soap *soap, fims__HashType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__HashType);
	if (soap_out_PointerTofims__HashType(soap, tag?tag:"fims:HashType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__HashType ** SOAP_FMAC4 soap_get_PointerTofims__HashType(struct soap *soap, fims__HashType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__HashType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__formatCollection(struct soap *soap, _fims__formatCollection *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__formatCollection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__formatCollection(struct soap *soap, const char *tag, int id, _fims__formatCollection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__formatCollection);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__formatCollection ** SOAP_FMAC4 soap_in_PointerTo_fims__formatCollection(struct soap *soap, const char *tag, _fims__formatCollection **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__formatCollection **)soap_malloc(soap, sizeof(_fims__formatCollection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__formatCollection *)soap_instantiate__fims__formatCollection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__formatCollection ** p = (_fims__formatCollection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__formatCollection, sizeof(_fims__formatCollection), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__formatCollection(struct soap *soap, _fims__formatCollection *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__formatCollection);
	if (soap_out_PointerTo_fims__formatCollection(soap, tag?tag:"fims:formatCollection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__formatCollection ** SOAP_FMAC4 soap_get_PointerTo_fims__formatCollection(struct soap *soap, _fims__formatCollection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__formatCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMEssenceLocatorsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMEssenceLocatorsType(struct soap *soap, const char *tag, int id, fims__BMEssenceLocatorsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMEssenceLocatorsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType ** SOAP_FMAC4 soap_in_PointerTofims__BMEssenceLocatorsType(struct soap *soap, const char *tag, fims__BMEssenceLocatorsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMEssenceLocatorsType **)soap_malloc(soap, sizeof(fims__BMEssenceLocatorsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMEssenceLocatorsType *)soap_instantiate_fims__BMEssenceLocatorsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMEssenceLocatorsType ** p = (fims__BMEssenceLocatorsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorsType, sizeof(fims__BMEssenceLocatorsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMEssenceLocatorsType);
	if (soap_out_PointerTofims__BMEssenceLocatorsType(soap, tag?tag:"fims:BMEssenceLocatorsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMEssenceLocatorsType ** SOAP_FMAC4 soap_get_PointerTofims__BMEssenceLocatorsType(struct soap *soap, fims__BMEssenceLocatorsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMEssenceLocatorsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__bmContentDescriptionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, int id, fimsdescription__bmContentDescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__bmContentDescriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, const char *tag, fimsdescription__bmContentDescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__bmContentDescriptionType **)soap_malloc(soap, sizeof(fimsdescription__bmContentDescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__bmContentDescriptionType *)soap_instantiate_fimsdescription__bmContentDescriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__bmContentDescriptionType ** p = (fimsdescription__bmContentDescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__bmContentDescriptionType, sizeof(fimsdescription__bmContentDescriptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__bmContentDescriptionType);
	if (soap_out_PointerTofimsdescription__bmContentDescriptionType(soap, tag?tag:"fimsdescription:bmContentDescriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__bmContentDescriptionType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__bmContentDescriptionType(struct soap *soap, fimsdescription__bmContentDescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__bmContentDescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__DescriptionsType(struct soap *soap, fims__DescriptionsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__DescriptionsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__DescriptionsType(struct soap *soap, const char *tag, int id, fims__DescriptionsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__DescriptionsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__DescriptionsType ** SOAP_FMAC4 soap_in_PointerTofims__DescriptionsType(struct soap *soap, const char *tag, fims__DescriptionsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__DescriptionsType **)soap_malloc(soap, sizeof(fims__DescriptionsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__DescriptionsType *)soap_instantiate_fims__DescriptionsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__DescriptionsType ** p = (fims__DescriptionsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DescriptionsType, sizeof(fims__DescriptionsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__DescriptionsType(struct soap *soap, fims__DescriptionsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__DescriptionsType);
	if (soap_out_PointerTofims__DescriptionsType(soap, tag?tag:"fims:DescriptionsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__DescriptionsType ** SOAP_FMAC4 soap_get_PointerTofims__DescriptionsType(struct soap *soap, fims__DescriptionsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__DescriptionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentFormatsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentFormatsType(struct soap *soap, const char *tag, int id, fims__BMContentFormatsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentFormatsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentFormatsType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentFormatsType(struct soap *soap, const char *tag, fims__BMContentFormatsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentFormatsType **)soap_malloc(soap, sizeof(fims__BMContentFormatsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentFormatsType *)soap_instantiate_fims__BMContentFormatsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentFormatsType ** p = (fims__BMContentFormatsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentFormatsType, sizeof(fims__BMContentFormatsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentFormatsType);
	if (soap_out_PointerTofims__BMContentFormatsType(soap, tag?tag:"fims:BMContentFormatsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentFormatsType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentFormatsType(struct soap *soap, fims__BMContentFormatsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentFormatsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentsType(struct soap *soap, fims__BMContentsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentsType(struct soap *soap, const char *tag, int id, fims__BMContentsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentsType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentsType(struct soap *soap, const char *tag, fims__BMContentsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentsType **)soap_malloc(soap, sizeof(fims__BMContentsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentsType *)soap_instantiate_fims__BMContentsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentsType ** p = (fims__BMContentsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentsType, sizeof(fims__BMContentsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentsType(struct soap *soap, fims__BMContentsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentsType);
	if (soap_out_PointerTofims__BMContentsType(soap, tag?tag:"fims:BMContentsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentsType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentsType(struct soap *soap, fims__BMContentsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__TechnicalAttributeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, int id, fims__TechnicalAttributeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__TechnicalAttributeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__TechnicalAttributeType ** SOAP_FMAC4 soap_in_PointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, fims__TechnicalAttributeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__TechnicalAttributeType **)soap_malloc(soap, sizeof(fims__TechnicalAttributeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__TechnicalAttributeType *)soap_instantiate_fims__TechnicalAttributeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__TechnicalAttributeType ** p = (fims__TechnicalAttributeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__TechnicalAttributeType, sizeof(fims__TechnicalAttributeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__TechnicalAttributeType);
	if (soap_out_PointerTofims__TechnicalAttributeType(soap, tag?tag:"fims:TechnicalAttributeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__TechnicalAttributeType ** SOAP_FMAC4 soap_get_PointerTofims__TechnicalAttributeType(struct soap *soap, fims__TechnicalAttributeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__TechnicalAttributeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ProcessedInfoType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ProcessedInfoType(struct soap *soap, const char *tag, int id, fims__ProcessedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ProcessedInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ProcessedInfoType ** SOAP_FMAC4 soap_in_PointerTofims__ProcessedInfoType(struct soap *soap, const char *tag, fims__ProcessedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ProcessedInfoType **)soap_malloc(soap, sizeof(fims__ProcessedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ProcessedInfoType *)soap_instantiate_fims__ProcessedInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ProcessedInfoType ** p = (fims__ProcessedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProcessedInfoType, sizeof(fims__ProcessedInfoType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ProcessedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProcessedInfoByBytesType, sizeof(fims__ProcessedInfoByBytesType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ProcessedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProcessedInfoByFramesType, sizeof(fims__ProcessedInfoByFramesType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ProcessedInfoType);
	if (soap_out_PointerTofims__ProcessedInfoType(soap, tag?tag:"fims:ProcessedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ProcessedInfoType ** SOAP_FMAC4 soap_get_PointerTofims__ProcessedInfoType(struct soap *soap, fims__ProcessedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ProcessedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__StartJobType(struct soap *soap, fims__StartJobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__StartJobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__StartJobType(struct soap *soap, const char *tag, int id, fims__StartJobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__StartJobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__StartJobType ** SOAP_FMAC4 soap_in_PointerTofims__StartJobType(struct soap *soap, const char *tag, fims__StartJobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__StartJobType **)soap_malloc(soap, sizeof(fims__StartJobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__StartJobType *)soap_instantiate_fims__StartJobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__StartJobType ** p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobType, sizeof(fims__StartJobType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobByNoWaitType, sizeof(fims__StartJobByNoWaitType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobByTimeType, sizeof(fims__StartJobByTimeType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__StartJobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__StartJobByLatestType, sizeof(fims__StartJobByLatestType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__StartJobType(struct soap *soap, fims__StartJobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__StartJobType);
	if (soap_out_PointerTofims__StartJobType(soap, tag?tag:"fims:StartJobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__StartJobType ** SOAP_FMAC4 soap_get_PointerTofims__StartJobType(struct soap *soap, fims__StartJobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__StartJobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMObjectsType(struct soap *soap, fims__BMObjectsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMObjectsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMObjectsType(struct soap *soap, const char *tag, int id, fims__BMObjectsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMObjectsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMObjectsType ** SOAP_FMAC4 soap_in_PointerTofims__BMObjectsType(struct soap *soap, const char *tag, fims__BMObjectsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMObjectsType **)soap_malloc(soap, sizeof(fims__BMObjectsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMObjectsType *)soap_instantiate_fims__BMObjectsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMObjectsType ** p = (fims__BMObjectsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMObjectsType, sizeof(fims__BMObjectsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMObjectsType(struct soap *soap, fims__BMObjectsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMObjectsType);
	if (soap_out_PointerTofims__BMObjectsType(soap, tag?tag:"fims:BMObjectsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMObjectsType ** SOAP_FMAC4 soap_get_PointerTofims__BMObjectsType(struct soap *soap, fims__BMObjectsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMObjectsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__JobStatusType(struct soap *soap, enum fims__JobStatusType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__JobStatusType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__JobStatusType(struct soap *soap, const char *tag, int id, enum fims__JobStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__JobStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__JobStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__JobStatusType ** SOAP_FMAC4 soap_in_PointerTofims__JobStatusType(struct soap *soap, const char *tag, enum fims__JobStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__JobStatusType **)soap_malloc(soap, sizeof(enum fims__JobStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__JobStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__JobStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobStatusType, sizeof(enum fims__JobStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__JobStatusType(struct soap *soap, enum fims__JobStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__JobStatusType);
	if (soap_out_PointerTofims__JobStatusType(soap, tag?tag:"fims:JobStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__JobStatusType ** SOAP_FMAC4 soap_get_PointerTofims__JobStatusType(struct soap *soap, enum fims__JobStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__JobStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__QueueStatusType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueueStatusType(struct soap *soap, const char *tag, int id, enum fims__QueueStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueueStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__QueueStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__QueueStatusType ** SOAP_FMAC4 soap_in_PointerTofims__QueueStatusType(struct soap *soap, const char *tag, enum fims__QueueStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__QueueStatusType **)soap_malloc(soap, sizeof(enum fims__QueueStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__QueueStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__QueueStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueueStatusType, sizeof(enum fims__QueueStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueueStatusType);
	if (soap_out_PointerTofims__QueueStatusType(soap, tag?tag:"fims:QueueStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__QueueStatusType ** SOAP_FMAC4 soap_get_PointerTofims__QueueStatusType(struct soap *soap, enum fims__QueueStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueueStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fims__ServiceType_serviceDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, int id, _fims__ServiceType_serviceDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fims__ServiceType_serviceDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription ** SOAP_FMAC4 soap_in_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, const char *tag, _fims__ServiceType_serviceDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fims__ServiceType_serviceDescription **)soap_malloc(soap, sizeof(_fims__ServiceType_serviceDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fims__ServiceType_serviceDescription *)soap_instantiate__fims__ServiceType_serviceDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fims__ServiceType_serviceDescription ** p = (_fims__ServiceType_serviceDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fims__ServiceType_serviceDescription, sizeof(_fims__ServiceType_serviceDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fims__ServiceType_serviceDescription);
	if (soap_out_PointerTo_fims__ServiceType_serviceDescription(soap, tag?tag:"fims:ServiceType-serviceDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fims__ServiceType_serviceDescription ** SOAP_FMAC4 soap_get_PointerTo_fims__ServiceType_serviceDescription(struct soap *soap, _fims__ServiceType_serviceDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fims__ServiceType_serviceDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ListFilterType(struct soap *soap, fims__ListFilterType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ListFilterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ListFilterType(struct soap *soap, const char *tag, int id, fims__ListFilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ListFilterType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ListFilterType ** SOAP_FMAC4 soap_in_PointerTofims__ListFilterType(struct soap *soap, const char *tag, fims__ListFilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ListFilterType **)soap_malloc(soap, sizeof(fims__ListFilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ListFilterType *)soap_instantiate_fims__ListFilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ListFilterType ** p = (fims__ListFilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ListFilterType, sizeof(fims__ListFilterType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ListFilterType(struct soap *soap, fims__ListFilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ListFilterType);
	if (soap_out_PointerTofims__ListFilterType(soap, tag?tag:"fims:ListFilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ListFilterType ** SOAP_FMAC4 soap_get_PointerTofims__ListFilterType(struct soap *soap, fims__ListFilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ListFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__DurationType(struct soap *soap, fims__DurationType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__DurationType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__DurationType(struct soap *soap, const char *tag, int id, fims__DurationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__DurationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__DurationType ** SOAP_FMAC4 soap_in_PointerTofims__DurationType(struct soap *soap, const char *tag, fims__DurationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__DurationType **)soap_malloc(soap, sizeof(fims__DurationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__DurationType *)soap_instantiate_fims__DurationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__DurationType ** p = (fims__DurationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DurationType, sizeof(fims__DurationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__DurationType(struct soap *soap, fims__DurationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__DurationType);
	if (soap_out_PointerTofims__DurationType(soap, tag?tag:"fims:DurationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__DurationType ** SOAP_FMAC4 soap_get_PointerTofims__DurationType(struct soap *soap, fims__DurationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__DurationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__TimeType(struct soap *soap, fims__TimeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__TimeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__TimeType(struct soap *soap, const char *tag, int id, fims__TimeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__TimeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__TimeType ** SOAP_FMAC4 soap_in_PointerTofims__TimeType(struct soap *soap, const char *tag, fims__TimeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__TimeType **)soap_malloc(soap, sizeof(fims__TimeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__TimeType *)soap_instantiate_fims__TimeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__TimeType ** p = (fims__TimeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__TimeType, sizeof(fims__TimeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__TimeType(struct soap *soap, fims__TimeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__TimeType);
	if (soap_out_PointerTofims__TimeType(soap, tag?tag:"fims:TimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__TimeType ** SOAP_FMAC4 soap_get_PointerTofims__TimeType(struct soap *soap, fims__TimeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__TimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__AsyncEndpointType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AsyncEndpointType(struct soap *soap, const char *tag, int id, fims__AsyncEndpointType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AsyncEndpointType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__AsyncEndpointType ** SOAP_FMAC4 soap_in_PointerTofims__AsyncEndpointType(struct soap *soap, const char *tag, fims__AsyncEndpointType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__AsyncEndpointType **)soap_malloc(soap, sizeof(fims__AsyncEndpointType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__AsyncEndpointType *)soap_instantiate_fims__AsyncEndpointType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__AsyncEndpointType ** p = (fims__AsyncEndpointType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AsyncEndpointType, sizeof(fims__AsyncEndpointType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AsyncEndpointType);
	if (soap_out_PointerTofims__AsyncEndpointType(soap, tag?tag:"fims:AsyncEndpointType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__AsyncEndpointType ** SOAP_FMAC4 soap_get_PointerTofims__AsyncEndpointType(struct soap *soap, fims__AsyncEndpointType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AsyncEndpointType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__EDLProviderErrorCodeType(struct soap *soap, enum edlprovider__EDLProviderErrorCodeType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_edlprovider__EDLProviderErrorCodeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__EDLProviderErrorCodeType(struct soap *soap, const char *tag, int id, enum edlprovider__EDLProviderErrorCodeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__EDLProviderErrorCodeType);
	if (id < 0)
		return soap->error;
	return soap_out_edlprovider__EDLProviderErrorCodeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum edlprovider__EDLProviderErrorCodeType ** SOAP_FMAC4 soap_in_PointerToedlprovider__EDLProviderErrorCodeType(struct soap *soap, const char *tag, enum edlprovider__EDLProviderErrorCodeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum edlprovider__EDLProviderErrorCodeType **)soap_malloc(soap, sizeof(enum edlprovider__EDLProviderErrorCodeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_edlprovider__EDLProviderErrorCodeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum edlprovider__EDLProviderErrorCodeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__EDLProviderErrorCodeType, sizeof(enum edlprovider__EDLProviderErrorCodeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__EDLProviderErrorCodeType(struct soap *soap, enum edlprovider__EDLProviderErrorCodeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__EDLProviderErrorCodeType);
	if (soap_out_PointerToedlprovider__EDLProviderErrorCodeType(soap, tag?tag:"edlprovider:EDLProviderErrorCodeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum edlprovider__EDLProviderErrorCodeType ** SOAP_FMAC4 soap_get_PointerToedlprovider__EDLProviderErrorCodeType(struct soap *soap, enum edlprovider__EDLProviderErrorCodeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__EDLProviderErrorCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__addressType_country))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__addressType_country(struct soap *soap, const char *tag, int id, _fimsdescription__addressType_country *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__addressType_country);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__addressType_country ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__addressType_country(struct soap *soap, const char *tag, _fimsdescription__addressType_country **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__addressType_country **)soap_malloc(soap, sizeof(_fimsdescription__addressType_country *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__addressType_country *)soap_instantiate__fimsdescription__addressType_country(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__addressType_country ** p = (_fimsdescription__addressType_country **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__addressType_country, sizeof(_fimsdescription__addressType_country), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__addressType_country);
	if (soap_out_PointerTo_fimsdescription__addressType_country(soap, tag?tag:"fimsdescription:addressType-country", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__addressType_country ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__addressType_country(struct soap *soap, _fimsdescription__addressType_country **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__addressType_country(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__addressType(struct soap *soap, fimsdescription__addressType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__addressType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__addressType(struct soap *soap, const char *tag, int id, fimsdescription__addressType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__addressType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__addressType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__addressType(struct soap *soap, const char *tag, fimsdescription__addressType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__addressType **)soap_malloc(soap, sizeof(fimsdescription__addressType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__addressType *)soap_instantiate_fimsdescription__addressType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__addressType ** p = (fimsdescription__addressType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__addressType, sizeof(fimsdescription__addressType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__addressType(struct soap *soap, fimsdescription__addressType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__addressType);
	if (soap_out_PointerTofimsdescription__addressType(soap, tag?tag:"fimsdescription:addressType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__addressType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__addressType(struct soap *soap, fimsdescription__addressType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__addressType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, int id, _fimsdescription__organisationDetailsType_organisationDepartment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, const char *tag, _fimsdescription__organisationDetailsType_organisationDepartment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__organisationDetailsType_organisationDepartment **)soap_malloc(soap, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__organisationDetailsType_organisationDepartment *)soap_instantiate__fimsdescription__organisationDetailsType_organisationDepartment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__organisationDetailsType_organisationDepartment ** p = (_fimsdescription__organisationDetailsType_organisationDepartment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment, sizeof(_fimsdescription__organisationDetailsType_organisationDepartment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment);
	if (soap_out_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, tag?tag:"fimsdescription:organisationDetailsType-organisationDepartment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__organisationDetailsType_organisationDepartment ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(struct soap *soap, _fimsdescription__organisationDetailsType_organisationDepartment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__organisationDetailsType_organisationDepartment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__detailsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__detailsType(struct soap *soap, const char *tag, int id, fimsdescription__detailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__detailsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__detailsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__detailsType(struct soap *soap, const char *tag, fimsdescription__detailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__detailsType **)soap_malloc(soap, sizeof(fimsdescription__detailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__detailsType *)soap_instantiate_fimsdescription__detailsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__detailsType ** p = (fimsdescription__detailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__detailsType, sizeof(fimsdescription__detailsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__detailsType);
	if (soap_out_PointerTofimsdescription__detailsType(soap, tag?tag:"fimsdescription:detailsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__detailsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__detailsType(struct soap *soap, fimsdescription__detailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__detailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role))
		soap_serialize_std__vectorTemplateOf_fimsdescription__entityType_role(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__entityType_role >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__entityType_role(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__entityType_role >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, std::vector<_fimsdescription__entityType_role >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__entityType_role >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__entityType_role >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__entityType_role(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__entityType_role >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__entityType_role(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__organisationDetailsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, int id, fimsdescription__organisationDetailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__organisationDetailsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, fimsdescription__organisationDetailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__organisationDetailsType **)soap_malloc(soap, sizeof(fimsdescription__organisationDetailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__organisationDetailsType *)soap_instantiate_fimsdescription__organisationDetailsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__organisationDetailsType ** p = (fimsdescription__organisationDetailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__organisationDetailsType, sizeof(fimsdescription__organisationDetailsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__organisationDetailsType);
	if (soap_out_PointerTofimsdescription__organisationDetailsType(soap, tag?tag:"fimsdescription:organisationDetailsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__organisationDetailsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__organisationDetailsType(struct soap *soap, fimsdescription__organisationDetailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__organisationDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_alternative))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_alternative *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_alternative);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, const char *tag, _fimsdescription__dateType_alternative **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_alternative **)soap_malloc(soap, sizeof(_fimsdescription__dateType_alternative *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_alternative *)soap_instantiate__fimsdescription__dateType_alternative(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_alternative ** p = (_fimsdescription__dateType_alternative **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_alternative, sizeof(_fimsdescription__dateType_alternative), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_alternative);
	if (soap_out_PointerTo_fimsdescription__dateType_alternative(soap, tag?tag:"fimsdescription:dateType-alternative", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_alternative ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_alternative(struct soap *soap, _fimsdescription__dateType_alternative **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_alternative(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_issued))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_issued(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_issued *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_issued);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_issued ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_issued(struct soap *soap, const char *tag, _fimsdescription__dateType_issued **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_issued **)soap_malloc(soap, sizeof(_fimsdescription__dateType_issued *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_issued *)soap_instantiate__fimsdescription__dateType_issued(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_issued ** p = (_fimsdescription__dateType_issued **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_issued, sizeof(_fimsdescription__dateType_issued), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_issued);
	if (soap_out_PointerTo_fimsdescription__dateType_issued(soap, tag?tag:"fimsdescription:dateType-issued", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_issued ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_issued(struct soap *soap, _fimsdescription__dateType_issued **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_issued(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_modified))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_modified(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_modified *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_modified);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_modified ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_modified(struct soap *soap, const char *tag, _fimsdescription__dateType_modified **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_modified **)soap_malloc(soap, sizeof(_fimsdescription__dateType_modified *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_modified *)soap_instantiate__fimsdescription__dateType_modified(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_modified ** p = (_fimsdescription__dateType_modified **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_modified, sizeof(_fimsdescription__dateType_modified), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_modified);
	if (soap_out_PointerTo_fimsdescription__dateType_modified(soap, tag?tag:"fimsdescription:dateType-modified", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_modified ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_modified(struct soap *soap, _fimsdescription__dateType_modified **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_modified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__dateType_created))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__dateType_created(struct soap *soap, const char *tag, int id, _fimsdescription__dateType_created *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__dateType_created);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__dateType_created ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__dateType_created(struct soap *soap, const char *tag, _fimsdescription__dateType_created **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__dateType_created **)soap_malloc(soap, sizeof(_fimsdescription__dateType_created *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__dateType_created *)soap_instantiate__fimsdescription__dateType_created(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__dateType_created ** p = (_fimsdescription__dateType_created **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__dateType_created, sizeof(_fimsdescription__dateType_created), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__dateType_created);
	if (soap_out_PointerTo_fimsdescription__dateType_created(soap, tag?tag:"fimsdescription:dateType-created", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__dateType_created ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__dateType_created(struct soap *soap, _fimsdescription__dateType_created **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__dateType_created(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__date(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__date))
		soap_serialize_xsd__date(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__date(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__date);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__date(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__date(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__date, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__date(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__date);
	if (soap_out_PointerToxsd__date(soap, tag?tag:"xsd:date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__date(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__gYear(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__gYear))
		soap_serialize_xsd__gYear(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__gYear(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__gYear);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__gYear(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__gYear(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__gYear(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__gYear, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__gYear(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__gYear);
	if (soap_out_PointerToxsd__gYear(soap, tag?tag:"xsd:gYear", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__gYear(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__gYear(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__contactDetailsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, int id, fimsdescription__contactDetailsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__contactDetailsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__contactDetailsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, fimsdescription__contactDetailsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__contactDetailsType **)soap_malloc(soap, sizeof(fimsdescription__contactDetailsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__contactDetailsType *)soap_instantiate_fimsdescription__contactDetailsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__contactDetailsType ** p = (fimsdescription__contactDetailsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__contactDetailsType, sizeof(fimsdescription__contactDetailsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__contactDetailsType);
	if (soap_out_PointerTofimsdescription__contactDetailsType(soap, tag?tag:"fimsdescription:contactDetailsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__contactDetailsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__contactDetailsType(struct soap *soap, fimsdescription__contactDetailsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__contactDetailsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__coverageType_spatial))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, int id, _fimsdescription__coverageType_spatial *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__coverageType_spatial);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__coverageType_spatial **)soap_malloc(soap, sizeof(_fimsdescription__coverageType_spatial *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__coverageType_spatial *)soap_instantiate__fimsdescription__coverageType_spatial(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__coverageType_spatial ** p = (_fimsdescription__coverageType_spatial **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__coverageType_spatial, sizeof(_fimsdescription__coverageType_spatial), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial);
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial(soap, tag?tag:"fimsdescription:coverageType-spatial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__coverageType_spatial(struct soap *soap, _fimsdescription__coverageType_spatial **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__coverageType_spatial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, int id, _fimsdescription__coverageType_spatial_coordinates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, const char *tag, _fimsdescription__coverageType_spatial_coordinates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__coverageType_spatial_coordinates **)soap_malloc(soap, sizeof(_fimsdescription__coverageType_spatial_coordinates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__coverageType_spatial_coordinates *)soap_instantiate__fimsdescription__coverageType_spatial_coordinates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__coverageType_spatial_coordinates ** p = (_fimsdescription__coverageType_spatial_coordinates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates, sizeof(_fimsdescription__coverageType_spatial_coordinates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__coverageType_spatial_coordinates);
	if (soap_out_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, tag?tag:"fimsdescription:coverageType-spatial-coordinates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__coverageType_spatial_coordinates ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__coverageType_spatial_coordinates(struct soap *soap, _fimsdescription__coverageType_spatial_coordinates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__coverageType_spatial_coordinates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__fimsdescription__coverageType_temporal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, int id, _fimsdescription__coverageType_temporal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__fimsdescription__coverageType_temporal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal ** SOAP_FMAC4 soap_in_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, const char *tag, _fimsdescription__coverageType_temporal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_fimsdescription__coverageType_temporal **)soap_malloc(soap, sizeof(_fimsdescription__coverageType_temporal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_fimsdescription__coverageType_temporal *)soap_instantiate__fimsdescription__coverageType_temporal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_fimsdescription__coverageType_temporal ** p = (_fimsdescription__coverageType_temporal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__fimsdescription__coverageType_temporal, sizeof(_fimsdescription__coverageType_temporal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_fimsdescription__coverageType_temporal);
	if (soap_out_PointerTo_fimsdescription__coverageType_temporal(soap, tag?tag:"fimsdescription:coverageType-temporal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _fimsdescription__coverageType_temporal ** SOAP_FMAC4 soap_get_PointerTo_fimsdescription__coverageType_temporal(struct soap *soap, _fimsdescription__coverageType_temporal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_fimsdescription__coverageType_temporal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience))
		soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__typeType_targetAudience >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_targetAudience >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_targetAudience >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__typeType_targetAudience >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__typeType_targetAudience >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_targetAudience >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType))
		soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__typeType_objectType >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_objectType >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_objectType >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__typeType_objectType >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__typeType_objectType >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_objectType >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_objectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >*const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre))
		soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, int id, std::vector<_fimsdescription__typeType_genre >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_genre >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_genre >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<_fimsdescription__typeType_genre >**)soap_malloc(soap, sizeof(std::vector<_fimsdescription__typeType_genre >*))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre);
	if (soap_out_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_genre >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOf_fimsdescription__typeType_genre(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xml__lang);
	if (soap_out_PointerTo_xml__lang(soap, tag?tag:"xml:lang", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__rightsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__rightsType(struct soap *soap, const char *tag, int id, fimsdescription__rightsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__rightsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__rightsType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__rightsType(struct soap *soap, const char *tag, fimsdescription__rightsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__rightsType **)soap_malloc(soap, sizeof(fimsdescription__rightsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__rightsType *)soap_instantiate_fimsdescription__rightsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__rightsType ** p = (fimsdescription__rightsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__rightsType, sizeof(fimsdescription__rightsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__rightsType);
	if (soap_out_PointerTofimsdescription__rightsType(soap, tag?tag:"fimsdescription:rightsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__rightsType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__rightsType(struct soap *soap, fimsdescription__rightsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__rightsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__coverageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__coverageType(struct soap *soap, const char *tag, int id, fimsdescription__coverageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__coverageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__coverageType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__coverageType(struct soap *soap, const char *tag, fimsdescription__coverageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__coverageType **)soap_malloc(soap, sizeof(fimsdescription__coverageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__coverageType *)soap_instantiate_fimsdescription__coverageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__coverageType ** p = (fimsdescription__coverageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__coverageType, sizeof(fimsdescription__coverageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__coverageType);
	if (soap_out_PointerTofimsdescription__coverageType(soap, tag?tag:"fimsdescription:coverageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__coverageType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__coverageType(struct soap *soap, fimsdescription__coverageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__coverageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__languageType(struct soap *soap, fimsdescription__languageType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__languageType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__languageType(struct soap *soap, const char *tag, int id, fimsdescription__languageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__languageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__languageType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__languageType(struct soap *soap, const char *tag, fimsdescription__languageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__languageType **)soap_malloc(soap, sizeof(fimsdescription__languageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__languageType *)soap_instantiate_fimsdescription__languageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__languageType ** p = (fimsdescription__languageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__languageType, sizeof(fimsdescription__languageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__languageType(struct soap *soap, fimsdescription__languageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__languageType);
	if (soap_out_PointerTofimsdescription__languageType(soap, tag?tag:"fimsdescription:languageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__languageType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__languageType(struct soap *soap, fimsdescription__languageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__languageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__identifierType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__identifierType(struct soap *soap, const char *tag, int id, fimsdescription__identifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__identifierType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__identifierType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__identifierType(struct soap *soap, const char *tag, fimsdescription__identifierType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__identifierType **)soap_malloc(soap, sizeof(fimsdescription__identifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__identifierType *)soap_instantiate_fimsdescription__identifierType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__identifierType ** p = (fimsdescription__identifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__identifierType, sizeof(fimsdescription__identifierType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__identifierType);
	if (soap_out_PointerTofimsdescription__identifierType(soap, tag?tag:"fimsdescription:identifierType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__identifierType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__identifierType(struct soap *soap, fimsdescription__identifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__identifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__typeType(struct soap *soap, fimsdescription__typeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__typeType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__typeType(struct soap *soap, const char *tag, int id, fimsdescription__typeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__typeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__typeType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__typeType(struct soap *soap, const char *tag, fimsdescription__typeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__typeType **)soap_malloc(soap, sizeof(fimsdescription__typeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__typeType *)soap_instantiate_fimsdescription__typeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__typeType ** p = (fimsdescription__typeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__typeType, sizeof(fimsdescription__typeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__typeType(struct soap *soap, fimsdescription__typeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__typeType);
	if (soap_out_PointerTofimsdescription__typeType(soap, tag?tag:"fimsdescription:typeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__typeType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__typeType(struct soap *soap, fimsdescription__typeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__typeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__dateType(struct soap *soap, fimsdescription__dateType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__dateType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__dateType(struct soap *soap, const char *tag, int id, fimsdescription__dateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__dateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__dateType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__dateType(struct soap *soap, const char *tag, fimsdescription__dateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__dateType **)soap_malloc(soap, sizeof(fimsdescription__dateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__dateType *)soap_instantiate_fimsdescription__dateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__dateType ** p = (fimsdescription__dateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__dateType, sizeof(fimsdescription__dateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__dateType(struct soap *soap, fimsdescription__dateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__dateType);
	if (soap_out_PointerTofimsdescription__dateType(soap, tag?tag:"fimsdescription:dateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__dateType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__dateType(struct soap *soap, fimsdescription__dateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__dateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__descriptionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, int id, fimsdescription__descriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__descriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__descriptionType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, fimsdescription__descriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__descriptionType **)soap_malloc(soap, sizeof(fimsdescription__descriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__descriptionType *)soap_instantiate_fimsdescription__descriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__descriptionType ** p = (fimsdescription__descriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__descriptionType);
	if (soap_out_PointerTofimsdescription__descriptionType(soap, tag?tag:"fimsdescription:descriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__descriptionType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__descriptionType(struct soap *soap, fimsdescription__descriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__descriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__subjectType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__subjectType(struct soap *soap, const char *tag, int id, fimsdescription__subjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__subjectType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__subjectType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__subjectType(struct soap *soap, const char *tag, fimsdescription__subjectType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__subjectType **)soap_malloc(soap, sizeof(fimsdescription__subjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__subjectType *)soap_instantiate_fimsdescription__subjectType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__subjectType ** p = (fimsdescription__subjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__subjectType, sizeof(fimsdescription__subjectType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__subjectType);
	if (soap_out_PointerTofimsdescription__subjectType(soap, tag?tag:"fimsdescription:subjectType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__subjectType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__subjectType(struct soap *soap, fimsdescription__subjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__subjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__entityType(struct soap *soap, fimsdescription__entityType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__entityType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__entityType(struct soap *soap, const char *tag, int id, fimsdescription__entityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__entityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__entityType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__entityType(struct soap *soap, const char *tag, fimsdescription__entityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__entityType **)soap_malloc(soap, sizeof(fimsdescription__entityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__entityType *)soap_instantiate_fimsdescription__entityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__entityType ** p = (fimsdescription__entityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__entityType, sizeof(fimsdescription__entityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__entityType(struct soap *soap, fimsdescription__entityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__entityType);
	if (soap_out_PointerTofimsdescription__entityType(soap, tag?tag:"fimsdescription:entityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__entityType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__entityType(struct soap *soap, fimsdescription__entityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__entityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__titleType(struct soap *soap, fimsdescription__titleType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__titleType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__titleType(struct soap *soap, const char *tag, int id, fimsdescription__titleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__titleType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__titleType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__titleType(struct soap *soap, const char *tag, fimsdescription__titleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__titleType **)soap_malloc(soap, sizeof(fimsdescription__titleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__titleType *)soap_instantiate_fimsdescription__titleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__titleType ** p = (fimsdescription__titleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__titleType, sizeof(fimsdescription__titleType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__titleType(struct soap *soap, fimsdescription__titleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__titleType);
	if (soap_out_PointerTofimsdescription__titleType(soap, tag?tag:"fimsdescription:titleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__titleType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__titleType(struct soap *soap, fimsdescription__titleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__titleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fimsdescription__textElementType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofimsdescription__textElementType(struct soap *soap, const char *tag, int id, fimsdescription__textElementType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fimsdescription__textElementType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fimsdescription__textElementType ** SOAP_FMAC4 soap_in_PointerTofimsdescription__textElementType(struct soap *soap, const char *tag, fimsdescription__textElementType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fimsdescription__textElementType **)soap_malloc(soap, sizeof(fimsdescription__textElementType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fimsdescription__textElementType *)soap_instantiate_fimsdescription__textElementType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fimsdescription__textElementType ** p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__textElementType, sizeof(fimsdescription__textElementType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__titleType, sizeof(fimsdescription__titleType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__subjectType, sizeof(fimsdescription__subjectType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fimsdescription__textElementType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofimsdescription__textElementType);
	if (soap_out_PointerTofimsdescription__textElementType(soap, tag?tag:"fimsdescription:textElementType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fimsdescription__textElementType ** SOAP_FMAC4 soap_get_PointerTofimsdescription__textElementType(struct soap *soap, fimsdescription__textElementType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofimsdescription__textElementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__DescriptionType(struct soap *soap, fims__DescriptionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__DescriptionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__DescriptionType(struct soap *soap, const char *tag, int id, fims__DescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__DescriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__DescriptionType ** SOAP_FMAC4 soap_in_PointerTofims__DescriptionType(struct soap *soap, const char *tag, fims__DescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__DescriptionType **)soap_malloc(soap, sizeof(fims__DescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__DescriptionType *)soap_instantiate_fims__DescriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__DescriptionType ** p = (fims__DescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DescriptionType, sizeof(fims__DescriptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__DescriptionType(struct soap *soap, fims__DescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__DescriptionType);
	if (soap_out_PointerTofims__DescriptionType(soap, tag?tag:"fims:DescriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__DescriptionType ** SOAP_FMAC4 soap_get_PointerTofims__DescriptionType(struct soap *soap, fims__DescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMEssenceLocatorType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, int id, fims__BMEssenceLocatorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMEssenceLocatorType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMEssenceLocatorType ** SOAP_FMAC4 soap_in_PointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, fims__BMEssenceLocatorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMEssenceLocatorType **)soap_malloc(soap, sizeof(fims__BMEssenceLocatorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMEssenceLocatorType *)soap_instantiate_fims__BMEssenceLocatorType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMEssenceLocatorType ** p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SimpleFileLocatorType, sizeof(fims__SimpleFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ListFileLocatorType, sizeof(fims__ListFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__BMEssenceLocatorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FolderLocatorType, sizeof(fims__FolderLocatorType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMEssenceLocatorType);
	if (soap_out_PointerTofims__BMEssenceLocatorType(soap, tag?tag:"fims:BMEssenceLocatorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMEssenceLocatorType ** SOAP_FMAC4 soap_get_PointerTofims__BMEssenceLocatorType(struct soap *soap, fims__BMEssenceLocatorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMEssenceLocatorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentFormatType(struct soap *soap, const char *tag, int id, fims__BMContentFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentFormatType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentFormatType(struct soap *soap, const char *tag, fims__BMContentFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentFormatType **)soap_malloc(soap, sizeof(fims__BMContentFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentFormatType *)soap_instantiate_fims__BMContentFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentFormatType ** p = (fims__BMContentFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentFormatType, sizeof(fims__BMContentFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentFormatType);
	if (soap_out_PointerTofims__BMContentFormatType(soap, tag?tag:"fims:BMContentFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentFormatType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentFormatType(struct soap *soap, fims__BMContentFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMContentType(struct soap *soap, fims__BMContentType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMContentType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMContentType(struct soap *soap, const char *tag, int id, fims__BMContentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMContentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMContentType ** SOAP_FMAC4 soap_in_PointerTofims__BMContentType(struct soap *soap, const char *tag, fims__BMContentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMContentType **)soap_malloc(soap, sizeof(fims__BMContentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMContentType *)soap_instantiate_fims__BMContentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMContentType ** p = (fims__BMContentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentType, sizeof(fims__BMContentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMContentType(struct soap *soap, fims__BMContentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMContentType);
	if (soap_out_PointerTofims__BMContentType(soap, tag?tag:"fims:BMContentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMContentType ** SOAP_FMAC4 soap_get_PointerTofims__BMContentType(struct soap *soap, fims__BMContentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMContentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__BMObjectType(struct soap *soap, fims__BMObjectType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__BMObjectType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__BMObjectType(struct soap *soap, const char *tag, int id, fims__BMObjectType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__BMObjectType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__BMObjectType ** SOAP_FMAC4 soap_in_PointerTofims__BMObjectType(struct soap *soap, const char *tag, fims__BMObjectType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__BMObjectType **)soap_malloc(soap, sizeof(fims__BMObjectType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__BMObjectType *)soap_instantiate_fims__BMObjectType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__BMObjectType ** p = (fims__BMObjectType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMObjectType, sizeof(fims__BMObjectType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__BMObjectType(struct soap *soap, fims__BMObjectType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__BMObjectType);
	if (soap_out_PointerTofims__BMObjectType(soap, tag?tag:"fims:BMObjectType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__BMObjectType ** SOAP_FMAC4 soap_get_PointerTofims__BMObjectType(struct soap *soap, fims__BMObjectType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__BMObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__DataFormatType(struct soap *soap, fims__DataFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__DataFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__DataFormatType(struct soap *soap, const char *tag, int id, fims__DataFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__DataFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__DataFormatType ** SOAP_FMAC4 soap_in_PointerTofims__DataFormatType(struct soap *soap, const char *tag, fims__DataFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__DataFormatType **)soap_malloc(soap, sizeof(fims__DataFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__DataFormatType *)soap_instantiate_fims__DataFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__DataFormatType ** p = (fims__DataFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DataFormatType, sizeof(fims__DataFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__DataFormatType(struct soap *soap, fims__DataFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__DataFormatType);
	if (soap_out_PointerTofims__DataFormatType(soap, tag?tag:"fims:DataFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__DataFormatType ** SOAP_FMAC4 soap_get_PointerTofims__DataFormatType(struct soap *soap, fims__DataFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__DataFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ProfileType(struct soap *soap, fims__ProfileType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ProfileType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ProfileType(struct soap *soap, const char *tag, int id, fims__ProfileType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ProfileType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ProfileType ** SOAP_FMAC4 soap_in_PointerTofims__ProfileType(struct soap *soap, const char *tag, fims__ProfileType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ProfileType **)soap_malloc(soap, sizeof(fims__ProfileType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ProfileType *)soap_instantiate_fims__ProfileType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ProfileType ** p = (fims__ProfileType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProfileType, sizeof(fims__ProfileType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ProfileType(struct soap *soap, fims__ProfileType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ProfileType);
	if (soap_out_PointerTofims__ProfileType(soap, tag?tag:"fims:ProfileType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ProfileType ** SOAP_FMAC4 soap_get_PointerTofims__ProfileType(struct soap *soap, fims__ProfileType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ProfileType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ResourceType(struct soap *soap, fims__ResourceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ResourceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ResourceType(struct soap *soap, const char *tag, int id, fims__ResourceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ResourceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ResourceType ** SOAP_FMAC4 soap_in_PointerTofims__ResourceType(struct soap *soap, const char *tag, fims__ResourceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ResourceType **)soap_malloc(soap, sizeof(fims__ResourceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ResourceType *)soap_instantiate_fims__ResourceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ResourceType ** p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ResourceType, sizeof(fims__ResourceType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ServiceType, sizeof(fims__ServiceType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ProfileType, sizeof(fims__ProfileType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueueType, sizeof(fims__QueueType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobType, sizeof(fims__JobType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FormatType, sizeof(fims__FormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMObjectType, sizeof(fims__BMObjectType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentType, sizeof(fims__BMContentType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DescriptionType, sizeof(fims__DescriptionType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMContentFormatType, sizeof(fims__BMContentFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__VideoFormatType, sizeof(fims__VideoFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AudioFormatType, sizeof(fims__AudioFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__DataFormatType, sizeof(fims__DataFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContainerFormatType, sizeof(fims__ContainerFormatType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__SimpleFileLocatorType, sizeof(fims__SimpleFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ListFileLocatorType, sizeof(fims__ListFileLocatorType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (fims__ResourceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__FolderLocatorType, sizeof(fims__FolderLocatorType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ResourceType(struct soap *soap, fims__ResourceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ResourceType);
	if (soap_out_PointerTofims__ResourceType(soap, tag?tag:"fims:ResourceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ResourceType ** SOAP_FMAC4 soap_get_PointerTofims__ResourceType(struct soap *soap, fims__ResourceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ResourceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__InnerFaultType(struct soap *soap, fims__InnerFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__InnerFaultType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__InnerFaultType(struct soap *soap, const char *tag, int id, fims__InnerFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__InnerFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__InnerFaultType ** SOAP_FMAC4 soap_in_PointerTofims__InnerFaultType(struct soap *soap, const char *tag, fims__InnerFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__InnerFaultType **)soap_malloc(soap, sizeof(fims__InnerFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__InnerFaultType *)soap_instantiate_fims__InnerFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__InnerFaultType ** p = (fims__InnerFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__InnerFaultType, sizeof(fims__InnerFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__InnerFaultType(struct soap *soap, fims__InnerFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__InnerFaultType);
	if (soap_out_PointerTofims__InnerFaultType(soap, tag?tag:"fims:InnerFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__InnerFaultType ** SOAP_FMAC4 soap_get_PointerTofims__InnerFaultType(struct soap *soap, fims__InnerFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__InnerFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ServiceType(struct soap *soap, fims__ServiceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ServiceType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ServiceType(struct soap *soap, const char *tag, int id, fims__ServiceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ServiceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ServiceType ** SOAP_FMAC4 soap_in_PointerTofims__ServiceType(struct soap *soap, const char *tag, fims__ServiceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ServiceType **)soap_malloc(soap, sizeof(fims__ServiceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ServiceType *)soap_instantiate_fims__ServiceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ServiceType ** p = (fims__ServiceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ServiceType, sizeof(fims__ServiceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ServiceType(struct soap *soap, fims__ServiceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ServiceType);
	if (soap_out_PointerTofims__ServiceType(soap, tag?tag:"fims:ServiceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ServiceType ** SOAP_FMAC4 soap_get_PointerTofims__ServiceType(struct soap *soap, fims__ServiceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ServiceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__nonNegativeInteger);
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__JobsType(struct soap *soap, fims__JobsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__JobsType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__JobsType(struct soap *soap, const char *tag, int id, fims__JobsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__JobsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__JobsType ** SOAP_FMAC4 soap_in_PointerTofims__JobsType(struct soap *soap, const char *tag, fims__JobsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__JobsType **)soap_malloc(soap, sizeof(fims__JobsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__JobsType *)soap_instantiate_fims__JobsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__JobsType ** p = (fims__JobsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobsType, sizeof(fims__JobsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__JobsType(struct soap *soap, fims__JobsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__JobsType);
	if (soap_out_PointerTofims__JobsType(soap, tag?tag:"fims:JobsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__JobsType ** SOAP_FMAC4 soap_get_PointerTofims__JobsType(struct soap *soap, fims__JobsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__JobsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__QueueType(struct soap *soap, fims__QueueType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__QueueType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__QueueType(struct soap *soap, const char *tag, int id, fims__QueueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__QueueType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__QueueType ** SOAP_FMAC4 soap_in_PointerTofims__QueueType(struct soap *soap, const char *tag, fims__QueueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__QueueType **)soap_malloc(soap, sizeof(fims__QueueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__QueueType *)soap_instantiate_fims__QueueType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__QueueType ** p = (fims__QueueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__QueueType, sizeof(fims__QueueType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__QueueType(struct soap *soap, fims__QueueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__QueueType);
	if (soap_out_PointerTofims__QueueType(soap, tag?tag:"fims:QueueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__QueueType ** SOAP_FMAC4 soap_get_PointerTofims__QueueType(struct soap *soap, fims__QueueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__QueueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__JobType(struct soap *soap, fims__JobType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__JobType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__JobType(struct soap *soap, const char *tag, int id, fims__JobType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__JobType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__JobType ** SOAP_FMAC4 soap_in_PointerTofims__JobType(struct soap *soap, const char *tag, fims__JobType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__JobType **)soap_malloc(soap, sizeof(fims__JobType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__JobType *)soap_instantiate_fims__JobType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__JobType ** p = (fims__JobType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__JobType, sizeof(fims__JobType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__JobType(struct soap *soap, fims__JobType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__JobType);
	if (soap_out_PointerTofims__JobType(soap, tag?tag:"fims:JobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__JobType ** SOAP_FMAC4 soap_get_PointerTofims__JobType(struct soap *soap, fims__JobType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__JobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__PriorityType(struct soap *soap, enum fims__PriorityType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_fims__PriorityType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__PriorityType(struct soap *soap, const char *tag, int id, enum fims__PriorityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__PriorityType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__PriorityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum fims__PriorityType ** SOAP_FMAC4 soap_in_PointerTofims__PriorityType(struct soap *soap, const char *tag, enum fims__PriorityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum fims__PriorityType **)soap_malloc(soap, sizeof(enum fims__PriorityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__PriorityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum fims__PriorityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__PriorityType, sizeof(enum fims__PriorityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__PriorityType(struct soap *soap, enum fims__PriorityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__PriorityType);
	if (soap_out_PointerTofims__PriorityType(soap, tag?tag:"fims:PriorityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum fims__PriorityType ** SOAP_FMAC4 soap_get_PointerTofims__PriorityType(struct soap *soap, enum fims__PriorityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__PriorityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__time(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__time))
		soap_serialize_xsd__time(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__time(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__time);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__time(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__time(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__time, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__time(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__time);
	if (soap_out_PointerToxsd__time(soap, tag?tag:"xsd:time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__time(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__Timecode(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__Timecode))
		soap_serialize_fims__Timecode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__Timecode(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__Timecode);
	if (id < 0)
		return soap->error;
	return soap_out_fims__Timecode(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofims__Timecode(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__Timecode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__Timecode, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__Timecode(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__Timecode);
	if (soap_out_PointerTofims__Timecode(soap, tag?tag:"fims:Timecode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofims__Timecode(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__Timecode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__EditUnitNumberType(struct soap *soap, fims__EditUnitNumberType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__EditUnitNumberType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__EditUnitNumberType(struct soap *soap, const char *tag, int id, fims__EditUnitNumberType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__EditUnitNumberType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__EditUnitNumberType ** SOAP_FMAC4 soap_in_PointerTofims__EditUnitNumberType(struct soap *soap, const char *tag, fims__EditUnitNumberType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__EditUnitNumberType **)soap_malloc(soap, sizeof(fims__EditUnitNumberType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__EditUnitNumberType *)soap_instantiate_fims__EditUnitNumberType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__EditUnitNumberType ** p = (fims__EditUnitNumberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__EditUnitNumberType, sizeof(fims__EditUnitNumberType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__EditUnitNumberType(struct soap *soap, fims__EditUnitNumberType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__EditUnitNumberType);
	if (soap_out_PointerTofims__EditUnitNumberType(soap, tag?tag:"fims:EditUnitNumberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__EditUnitNumberType ** SOAP_FMAC4 soap_get_PointerTofims__EditUnitNumberType(struct soap *soap, fims__EditUnitNumberType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__EditUnitNumberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__duration);
	if (soap_out_PointerToxsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__TimecodeDuration(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__TimecodeDuration))
		soap_serialize_fims__TimecodeDuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__TimecodeDuration(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__TimecodeDuration);
	if (id < 0)
		return soap->error;
	return soap_out_fims__TimecodeDuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofims__TimecodeDuration(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__TimecodeDuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__TimecodeDuration, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__TimecodeDuration(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__TimecodeDuration);
	if (soap_out_PointerTofims__TimecodeDuration(soap, tag?tag:"fims:TimecodeDuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofims__TimecodeDuration(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__TimecodeDuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__HashFunctionType(struct soap *soap, fims__HashFunctionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__HashFunctionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__HashFunctionType(struct soap *soap, const char *tag, int id, fims__HashFunctionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__HashFunctionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__HashFunctionType ** SOAP_FMAC4 soap_in_PointerTofims__HashFunctionType(struct soap *soap, const char *tag, fims__HashFunctionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__HashFunctionType **)soap_malloc(soap, sizeof(fims__HashFunctionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__HashFunctionType *)soap_instantiate_fims__HashFunctionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__HashFunctionType ** p = (fims__HashFunctionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__HashFunctionType, sizeof(fims__HashFunctionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__HashFunctionType(struct soap *soap, fims__HashFunctionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__HashFunctionType);
	if (soap_out_PointerTofims__HashFunctionType(soap, tag?tag:"fims:HashFunctionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__HashFunctionType ** SOAP_FMAC4 soap_get_PointerTofims__HashFunctionType(struct soap *soap, fims__HashFunctionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__HashFunctionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ContainerFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ContainerFormatType(struct soap *soap, const char *tag, int id, fims__ContainerFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ContainerFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ContainerFormatType ** SOAP_FMAC4 soap_in_PointerTofims__ContainerFormatType(struct soap *soap, const char *tag, fims__ContainerFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ContainerFormatType **)soap_malloc(soap, sizeof(fims__ContainerFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ContainerFormatType *)soap_instantiate_fims__ContainerFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ContainerFormatType ** p = (fims__ContainerFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ContainerFormatType, sizeof(fims__ContainerFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ContainerFormatType);
	if (soap_out_PointerTofims__ContainerFormatType(soap, tag?tag:"fims:ContainerFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ContainerFormatType ** SOAP_FMAC4 soap_get_PointerTofims__ContainerFormatType(struct soap *soap, fims__ContainerFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ContainerFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__AudioFormatType(struct soap *soap, fims__AudioFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__AudioFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__AudioFormatType(struct soap *soap, const char *tag, int id, fims__AudioFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__AudioFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__AudioFormatType ** SOAP_FMAC4 soap_in_PointerTofims__AudioFormatType(struct soap *soap, const char *tag, fims__AudioFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__AudioFormatType **)soap_malloc(soap, sizeof(fims__AudioFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__AudioFormatType *)soap_instantiate_fims__AudioFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__AudioFormatType ** p = (fims__AudioFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__AudioFormatType, sizeof(fims__AudioFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__AudioFormatType(struct soap *soap, fims__AudioFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__AudioFormatType);
	if (soap_out_PointerTofims__AudioFormatType(soap, tag?tag:"fims:AudioFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__AudioFormatType ** SOAP_FMAC4 soap_get_PointerTofims__AudioFormatType(struct soap *soap, fims__AudioFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__AudioFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__VideoFormatType(struct soap *soap, fims__VideoFormatType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__VideoFormatType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__VideoFormatType(struct soap *soap, const char *tag, int id, fims__VideoFormatType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__VideoFormatType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__VideoFormatType ** SOAP_FMAC4 soap_in_PointerTofims__VideoFormatType(struct soap *soap, const char *tag, fims__VideoFormatType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__VideoFormatType **)soap_malloc(soap, sizeof(fims__VideoFormatType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__VideoFormatType *)soap_instantiate_fims__VideoFormatType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__VideoFormatType ** p = (fims__VideoFormatType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__VideoFormatType, sizeof(fims__VideoFormatType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__VideoFormatType(struct soap *soap, fims__VideoFormatType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__VideoFormatType);
	if (soap_out_PointerTofims__VideoFormatType(soap, tag?tag:"fims:VideoFormatType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__VideoFormatType ** SOAP_FMAC4 soap_get_PointerTofims__VideoFormatType(struct soap *soap, fims__VideoFormatType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__VideoFormatType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__language(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__language))
		soap_serialize_xsd__language(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__language(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__language);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__language(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__language(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__language(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__language, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__language(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__language);
	if (soap_out_PointerToxsd__language(soap, tag?tag:"xsd:language", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__language(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__language(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__UID(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__UID))
		soap_serialize_fims__UID(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__UID(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__UID);
	if (id < 0)
		return soap->error;
	return soap_out_fims__UID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofims__UID(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__UID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__UID, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__UID(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__UID);
	if (soap_out_PointerTofims__UID(soap, tag?tag:"fims:UID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofims__UID(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__UID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ExtensionAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ExtensionAttributes(struct soap *soap, const char *tag, int id, fims__ExtensionAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ExtensionAttributes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ExtensionAttributes ** SOAP_FMAC4 soap_in_PointerTofims__ExtensionAttributes(struct soap *soap, const char *tag, fims__ExtensionAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ExtensionAttributes **)soap_malloc(soap, sizeof(fims__ExtensionAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ExtensionAttributes *)soap_instantiate_fims__ExtensionAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ExtensionAttributes ** p = (fims__ExtensionAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ExtensionAttributes, sizeof(fims__ExtensionAttributes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ExtensionAttributes);
	if (soap_out_PointerTofims__ExtensionAttributes(soap, tag?tag:"fims:ExtensionAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ExtensionAttributes ** SOAP_FMAC4 soap_get_PointerTofims__ExtensionAttributes(struct soap *soap, fims__ExtensionAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ExtensionAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__ExtensionGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__ExtensionGroup(struct soap *soap, const char *tag, int id, fims__ExtensionGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__ExtensionGroup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 fims__ExtensionGroup ** SOAP_FMAC4 soap_in_PointerTofims__ExtensionGroup(struct soap *soap, const char *tag, fims__ExtensionGroup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fims__ExtensionGroup **)soap_malloc(soap, sizeof(fims__ExtensionGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fims__ExtensionGroup *)soap_instantiate_fims__ExtensionGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	fims__ExtensionGroup ** p = (fims__ExtensionGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__ExtensionGroup, sizeof(fims__ExtensionGroup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__ExtensionGroup);
	if (soap_out_PointerTofims__ExtensionGroup(soap, tag?tag:"fims:ExtensionGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fims__ExtensionGroup ** SOAP_FMAC4 soap_get_PointerTofims__ExtensionGroup(struct soap *soap, fims__ExtensionGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__ExtensionGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofims__RevisionIDType(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_fims__RevisionIDType))
		soap_serialize_fims__RevisionIDType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofims__RevisionIDType(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_fims__RevisionIDType);
	if (id < 0)
		return soap->error;
	return soap_out_fims__RevisionIDType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTofims__RevisionIDType(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_fims__RevisionIDType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fims__RevisionIDType, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofims__RevisionIDType(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofims__RevisionIDType);
	if (soap_out_PointerTofims__RevisionIDType(soap, tag?tag:"fims:RevisionIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTofims__RevisionIDType(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofims__RevisionIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__wstring(struct soap *soap, std::wstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__wstring))
		soap_serialize_std__wstring(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__wstring(struct soap *soap, const char *tag, int id, std::wstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__wstring);
	if (id < 0)
		return soap->error;
	return soap_out_std__wstring(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_in_PointerTostd__wstring(struct soap *soap, const char *tag, std::wstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::wstring **)soap_malloc(soap, sizeof(std::wstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__wstring(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::wstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__wstring, sizeof(std::wstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__wstring(struct soap *soap, std::wstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__wstring);
	if (soap_out_PointerTostd__wstring(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::wstring ** SOAP_FMAC4 soap_get_PointerTostd__wstring(struct soap *soap, std::wstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__ArrayOfClips))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__ArrayOfClips(struct soap *soap, const char *tag, int id, edlprovider__ArrayOfClips *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__ArrayOfClips);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__ArrayOfClips ** SOAP_FMAC4 soap_in_PointerToedlprovider__ArrayOfClips(struct soap *soap, const char *tag, edlprovider__ArrayOfClips **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__ArrayOfClips **)soap_malloc(soap, sizeof(edlprovider__ArrayOfClips *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__ArrayOfClips *)soap_instantiate_edlprovider__ArrayOfClips(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__ArrayOfClips ** p = (edlprovider__ArrayOfClips **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__ArrayOfClips, sizeof(edlprovider__ArrayOfClips), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__ArrayOfClips);
	if (soap_out_PointerToedlprovider__ArrayOfClips(soap, tag?tag:"edlprovider:ArrayOfClips", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__ArrayOfClips ** SOAP_FMAC4 soap_get_PointerToedlprovider__ArrayOfClips(struct soap *soap, edlprovider__ArrayOfClips **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__ArrayOfClips(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToedlprovider__ClipType(struct soap *soap, edlprovider__ClipType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_edlprovider__ClipType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToedlprovider__ClipType(struct soap *soap, const char *tag, int id, edlprovider__ClipType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_edlprovider__ClipType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 edlprovider__ClipType ** SOAP_FMAC4 soap_in_PointerToedlprovider__ClipType(struct soap *soap, const char *tag, edlprovider__ClipType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (edlprovider__ClipType **)soap_malloc(soap, sizeof(edlprovider__ClipType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (edlprovider__ClipType *)soap_instantiate_edlprovider__ClipType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	edlprovider__ClipType ** p = (edlprovider__ClipType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_edlprovider__ClipType, sizeof(edlprovider__ClipType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToedlprovider__ClipType(struct soap *soap, edlprovider__ClipType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToedlprovider__ClipType);
	if (soap_out_PointerToedlprovider__ClipType(soap, tag?tag:"edlprovider:ClipType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 edlprovider__ClipType ** SOAP_FMAC4 soap_get_PointerToedlprovider__ClipType(struct soap *soap, edlprovider__ClipType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToedlprovider__ClipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, std::vector<fims__AncillaryDataFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, const std::vector<fims__AncillaryDataFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__AncillaryDataFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__AncillaryDataFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__AncillaryDataFormatType * >*a, const char *type)
{
	for (std::vector<fims__AncillaryDataFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__AncillaryDataFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__AncillaryDataFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, const char *tag, std::vector<fims__AncillaryDataFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__AncillaryDataFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__AncillaryDataFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType, sizeof(fims__AncillaryDataFormatType), 1))
				break;
			if (!soap_in_PointerTofims__AncillaryDataFormatType(soap, tag, NULL, "fims:AncillaryDataFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__AncillaryDataFormatType(soap, tag, &n, "fims:AncillaryDataFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__AncillaryDataFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__AncillaryDataFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__AncillaryDataFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__AncillaryDataFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__AncillaryDataFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__AncillaryDataFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__AncillaryDataFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__AncillaryDataFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__AncillaryDataFormatType * >*)p = *(std::vector<fims__AncillaryDataFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, std::vector<fims__CaptioningFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, const std::vector<fims__CaptioningFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__CaptioningFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__CaptioningFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__CaptioningFormatType * >*a, const char *type)
{
	for (std::vector<fims__CaptioningFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__CaptioningFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__CaptioningFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, const char *tag, std::vector<fims__CaptioningFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__CaptioningFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__CaptioningFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType, sizeof(fims__CaptioningFormatType), 1))
				break;
			if (!soap_in_PointerTofims__CaptioningFormatType(soap, tag, NULL, "fims:CaptioningFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__CaptioningFormatType(soap, tag, &n, "fims:CaptioningFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__CaptioningFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__CaptioningFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__CaptioningFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__CaptioningFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__CaptioningFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__CaptioningFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__CaptioningFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__CaptioningFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__CaptioningFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__CaptioningFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__CaptioningFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__CaptioningFormatType * >*)p = *(std::vector<fims__CaptioningFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, std::vector<fims__BMTrackType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, const std::vector<fims__BMTrackType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMTrackType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMTrackType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMTrackType * >*a, const char *type)
{
	for (std::vector<fims__BMTrackType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMTrackType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMTrackType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, const char *tag, std::vector<fims__BMTrackType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMTrackType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMTrackType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType, sizeof(fims__BMTrackType), 1))
				break;
			if (!soap_in_PointerTofims__BMTrackType(soap, tag, NULL, "fims:BMTrackType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMTrackType(soap, tag, &n, "fims:BMTrackType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMTrackType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMTrackType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMTrackType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMTrackType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMTrackType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMTrackType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMTrackType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMTrackType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMTrackType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMTrackType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMTrackType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMTrackType * >*)p = *(std::vector<fims__BMTrackType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, std::vector<fims__TechnicalAttributeType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, const std::vector<fims__TechnicalAttributeType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__TechnicalAttributeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__TechnicalAttributeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, int id, const std::vector<fims__TechnicalAttributeType * >*a, const char *type)
{
	for (std::vector<fims__TechnicalAttributeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__TechnicalAttributeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__TechnicalAttributeType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, const char *tag, std::vector<fims__TechnicalAttributeType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__TechnicalAttributeType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__TechnicalAttributeType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType, sizeof(fims__TechnicalAttributeType), 1))
				break;
			if (!soap_in_PointerTofims__TechnicalAttributeType(soap, tag, NULL, "fims:TechnicalAttributeType"))
				break;
		}
		else if (!soap_in_PointerTofims__TechnicalAttributeType(soap, tag, &n, "fims:TechnicalAttributeType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__TechnicalAttributeType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__TechnicalAttributeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__TechnicalAttributeType * >);
		if (size)
			*size = sizeof(std::vector<fims__TechnicalAttributeType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__TechnicalAttributeType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__TechnicalAttributeType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__TechnicalAttributeType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__TechnicalAttributeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__TechnicalAttributeType * > %p -> %p\n", q, p));
	*(std::vector<fims__TechnicalAttributeType * >*)p = *(std::vector<fims__TechnicalAttributeType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOffims__UID(struct soap *soap, std::vector<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOffims__UID(struct soap *soap, const std::vector<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_fims__UID(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOffims__UID(struct soap *soap, const char *tag, int id, const std::vector<std::wstring >*a, const char *type)
{
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_fims__UID(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring >* SOAP_FMAC4 soap_in_std__vectorTemplateOffims__UID(struct soap *soap, const char *tag, std::vector<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_fims__UID(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__UID, SOAP_TYPE_std__vectorTemplateOffims__UID, sizeof(std::wstring), 0))
				break;
			if (!soap_in_fims__UID(soap, tag, NULL, "fims:UID"))
				break;
		}
		else if (!soap_in_fims__UID(soap, tag, &n, "fims:UID"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOffims__UID(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOffims__UID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOffims__UID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOffims__UID, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::wstring >);
		if (size)
			*size = sizeof(std::vector<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::vector<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOffims__UID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::wstring > %p -> %p\n", q, p));
	*(std::vector<std::wstring >*)p = *(std::vector<std::wstring >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::wstring >*a, const char *type)
{
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_xsd__anyURI(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::wstring), 0))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else if (!soap_in_xsd__anyURI(soap, tag, &n, "xsd:anyURI"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::wstring >);
		if (size)
			*size = sizeof(std::vector<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::vector<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::wstring > %p -> %p\n", q, p));
	*(std::vector<std::wstring >*)p = *(std::vector<std::wstring >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, std::vector<fimsdescription__detailsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, const std::vector<fimsdescription__detailsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__detailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__detailsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__detailsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__detailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__detailsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__detailsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, const char *tag, std::vector<fimsdescription__detailsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__detailsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__detailsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType, sizeof(fimsdescription__detailsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__detailsType(soap, tag, NULL, "fimsdescription:detailsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__detailsType(soap, tag, &n, "fimsdescription:detailsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__detailsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__detailsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__detailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__detailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__detailsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__detailsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__detailsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__detailsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__detailsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__detailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__detailsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__detailsType * >*)p = *(std::vector<fimsdescription__detailsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, std::vector<_fimsdescription__entityType_role >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const std::vector<_fimsdescription__entityType_role >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__entityType_role >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__entityType_role >*a, const char *type)
{
	for (std::vector<_fimsdescription__entityType_role >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__entityType_role >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, const char *tag, std::vector<_fimsdescription__entityType_role >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__entityType_role n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__entityType_role, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role, sizeof(_fimsdescription__entityType_role), 0))
				break;
			if (!soap_in__fimsdescription__entityType_role(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__entityType_role(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__entityType_role(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__entityType_role > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__entityType_role(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__entityType_role, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__entityType_role >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__entityType_role >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__entityType_role >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__entityType_role >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__entityType_role >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__entityType_role(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__entityType_role > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__entityType_role >*)p = *(std::vector<_fimsdescription__entityType_role >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, std::vector<fimsdescription__organisationDetailsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, const std::vector<fimsdescription__organisationDetailsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__organisationDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__organisationDetailsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__organisationDetailsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__organisationDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__organisationDetailsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__organisationDetailsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, const char *tag, std::vector<fimsdescription__organisationDetailsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__organisationDetailsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__organisationDetailsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType, sizeof(fimsdescription__organisationDetailsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__organisationDetailsType(soap, tag, NULL, "fimsdescription:organisationDetailsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__organisationDetailsType(soap, tag, &n, "fimsdescription:organisationDetailsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__organisationDetailsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__organisationDetailsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__organisationDetailsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__organisationDetailsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__organisationDetailsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__organisationDetailsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__organisationDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__organisationDetailsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__organisationDetailsType * >*)p = *(std::vector<fimsdescription__organisationDetailsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, std::vector<fimsdescription__contactDetailsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, const std::vector<fimsdescription__contactDetailsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__contactDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__contactDetailsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__contactDetailsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__contactDetailsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__contactDetailsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__contactDetailsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, const char *tag, std::vector<fimsdescription__contactDetailsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__contactDetailsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__contactDetailsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType, sizeof(fimsdescription__contactDetailsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__contactDetailsType(soap, tag, NULL, "fimsdescription:contactDetailsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__contactDetailsType(soap, tag, &n, "fimsdescription:contactDetailsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__contactDetailsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__contactDetailsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__contactDetailsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__contactDetailsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__contactDetailsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__contactDetailsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__contactDetailsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__contactDetailsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__contactDetailsType * >*)p = *(std::vector<fimsdescription__contactDetailsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, std::vector<_fimsdescription__typeType_targetAudience >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const std::vector<_fimsdescription__typeType_targetAudience >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__typeType_targetAudience >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__typeType_targetAudience >*a, const char *type)
{
	for (std::vector<_fimsdescription__typeType_targetAudience >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_targetAudience >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_targetAudience >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__typeType_targetAudience n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__typeType_targetAudience, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience, sizeof(_fimsdescription__typeType_targetAudience), 0))
				break;
			if (!soap_in__fimsdescription__typeType_targetAudience(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__typeType_targetAudience(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__typeType_targetAudience > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_targetAudience, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__typeType_targetAudience >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__typeType_targetAudience >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__typeType_targetAudience >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__typeType_targetAudience >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__typeType_targetAudience >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__typeType_targetAudience(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__typeType_targetAudience > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__typeType_targetAudience >*)p = *(std::vector<_fimsdescription__typeType_targetAudience >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, std::vector<_fimsdescription__typeType_objectType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const std::vector<_fimsdescription__typeType_objectType >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__typeType_objectType >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__typeType_objectType >*a, const char *type)
{
	for (std::vector<_fimsdescription__typeType_objectType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_objectType >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_objectType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__typeType_objectType n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__typeType_objectType, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType, sizeof(_fimsdescription__typeType_objectType), 0))
				break;
			if (!soap_in__fimsdescription__typeType_objectType(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__typeType_objectType(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__typeType_objectType(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__typeType_objectType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_objectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_objectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__typeType_objectType >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__typeType_objectType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__typeType_objectType >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__typeType_objectType >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__typeType_objectType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__typeType_objectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__typeType_objectType > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__typeType_objectType >*)p = *(std::vector<_fimsdescription__typeType_objectType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, std::vector<_fimsdescription__typeType_genre >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const std::vector<_fimsdescription__typeType_genre >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<_fimsdescription__typeType_genre >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, int id, const std::vector<_fimsdescription__typeType_genre >*a, const char *type)
{
	for (std::vector<_fimsdescription__typeType_genre >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_fimsdescription__typeType_genre >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, const char *tag, std::vector<_fimsdescription__typeType_genre >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	_fimsdescription__typeType_genre n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__fimsdescription__typeType_genre, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre, sizeof(_fimsdescription__typeType_genre), 0))
				break;
			if (!soap_in__fimsdescription__typeType_genre(soap, tag, NULL, ""))
				break;
		}
		else if (!soap_in__fimsdescription__typeType_genre(soap, tag, &n, ""))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_fimsdescription__typeType_genre(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_fimsdescription__typeType_genre > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_fimsdescription__typeType_genre(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_fimsdescription__typeType_genre, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_fimsdescription__typeType_genre >);
		if (size)
			*size = sizeof(std::vector<_fimsdescription__typeType_genre >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<_fimsdescription__typeType_genre >, n);
		if (size)
			*size = n * sizeof(std::vector<_fimsdescription__typeType_genre >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<_fimsdescription__typeType_genre >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_fimsdescription__typeType_genre(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_fimsdescription__typeType_genre > %p -> %p\n", q, p));
	*(std::vector<_fimsdescription__typeType_genre >*)p = *(std::vector<_fimsdescription__typeType_genre >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, std::vector<fimsdescription__rightsType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, const std::vector<fimsdescription__rightsType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__rightsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__rightsType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__rightsType * >*a, const char *type)
{
	for (std::vector<fimsdescription__rightsType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__rightsType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__rightsType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, const char *tag, std::vector<fimsdescription__rightsType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__rightsType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__rightsType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType, sizeof(fimsdescription__rightsType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__rightsType(soap, tag, NULL, "fimsdescription:rightsType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__rightsType(soap, tag, &n, "fimsdescription:rightsType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__rightsType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__rightsType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__rightsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__rightsType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__rightsType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__rightsType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__rightsType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__rightsType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__rightsType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__rightsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__rightsType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__rightsType * >*)p = *(std::vector<fimsdescription__rightsType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, std::vector<fimsdescription__coverageType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, const std::vector<fimsdescription__coverageType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__coverageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__coverageType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__coverageType * >*a, const char *type)
{
	for (std::vector<fimsdescription__coverageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__coverageType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__coverageType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, const char *tag, std::vector<fimsdescription__coverageType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__coverageType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__coverageType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType, sizeof(fimsdescription__coverageType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__coverageType(soap, tag, NULL, "fimsdescription:coverageType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__coverageType(soap, tag, &n, "fimsdescription:coverageType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__coverageType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__coverageType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__coverageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__coverageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__coverageType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__coverageType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__coverageType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__coverageType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__coverageType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__coverageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__coverageType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__coverageType * >*)p = *(std::vector<fimsdescription__coverageType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, std::vector<fimsdescription__languageType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, const std::vector<fimsdescription__languageType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__languageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__languageType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__languageType * >*a, const char *type)
{
	for (std::vector<fimsdescription__languageType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__languageType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__languageType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, const char *tag, std::vector<fimsdescription__languageType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__languageType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__languageType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType, sizeof(fimsdescription__languageType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__languageType(soap, tag, NULL, "fimsdescription:languageType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__languageType(soap, tag, &n, "fimsdescription:languageType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__languageType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__languageType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__languageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__languageType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__languageType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__languageType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__languageType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__languageType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__languageType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__languageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__languageType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__languageType * >*)p = *(std::vector<fimsdescription__languageType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, std::vector<fimsdescription__identifierType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, const std::vector<fimsdescription__identifierType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__identifierType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__identifierType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__identifierType * >*a, const char *type)
{
	for (std::vector<fimsdescription__identifierType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__identifierType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__identifierType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, const char *tag, std::vector<fimsdescription__identifierType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__identifierType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__identifierType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType, sizeof(fimsdescription__identifierType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__identifierType(soap, tag, NULL, "fimsdescription:identifierType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__identifierType(soap, tag, &n, "fimsdescription:identifierType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__identifierType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__identifierType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__identifierType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__identifierType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__identifierType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__identifierType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__identifierType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__identifierType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__identifierType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__identifierType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__identifierType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__identifierType * >*)p = *(std::vector<fimsdescription__identifierType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, std::vector<fimsdescription__typeType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, const std::vector<fimsdescription__typeType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__typeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__typeType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__typeType * >*a, const char *type)
{
	for (std::vector<fimsdescription__typeType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__typeType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__typeType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, const char *tag, std::vector<fimsdescription__typeType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__typeType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__typeType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType, sizeof(fimsdescription__typeType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__typeType(soap, tag, NULL, "fimsdescription:typeType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__typeType(soap, tag, &n, "fimsdescription:typeType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__typeType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__typeType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__typeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__typeType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__typeType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__typeType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__typeType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__typeType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__typeType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__typeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__typeType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__typeType * >*)p = *(std::vector<fimsdescription__typeType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, std::vector<fimsdescription__dateType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, const std::vector<fimsdescription__dateType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__dateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__dateType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__dateType * >*a, const char *type)
{
	for (std::vector<fimsdescription__dateType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__dateType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__dateType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, const char *tag, std::vector<fimsdescription__dateType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__dateType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__dateType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType, sizeof(fimsdescription__dateType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__dateType(soap, tag, NULL, "fimsdescription:dateType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__dateType(soap, tag, &n, "fimsdescription:dateType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__dateType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__dateType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__dateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__dateType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__dateType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__dateType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__dateType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__dateType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__dateType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__dateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__dateType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__dateType * >*)p = *(std::vector<fimsdescription__dateType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, std::vector<fimsdescription__descriptionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, const std::vector<fimsdescription__descriptionType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__descriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__descriptionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__descriptionType * >*a, const char *type)
{
	for (std::vector<fimsdescription__descriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__descriptionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__descriptionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, const char *tag, std::vector<fimsdescription__descriptionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__descriptionType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__descriptionType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType, sizeof(fimsdescription__descriptionType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__descriptionType(soap, tag, NULL, "fimsdescription:descriptionType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__descriptionType(soap, tag, &n, "fimsdescription:descriptionType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__descriptionType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__descriptionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__descriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__descriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__descriptionType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__descriptionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__descriptionType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__descriptionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__descriptionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__descriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__descriptionType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__descriptionType * >*)p = *(std::vector<fimsdescription__descriptionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, std::vector<fimsdescription__subjectType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, const std::vector<fimsdescription__subjectType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__subjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__subjectType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__subjectType * >*a, const char *type)
{
	for (std::vector<fimsdescription__subjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__subjectType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__subjectType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, const char *tag, std::vector<fimsdescription__subjectType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__subjectType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__subjectType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType, sizeof(fimsdescription__subjectType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__subjectType(soap, tag, NULL, "fimsdescription:subjectType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__subjectType(soap, tag, &n, "fimsdescription:subjectType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__subjectType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__subjectType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__subjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__subjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__subjectType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__subjectType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__subjectType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__subjectType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__subjectType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__subjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__subjectType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__subjectType * >*)p = *(std::vector<fimsdescription__subjectType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, std::vector<fimsdescription__entityType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, const std::vector<fimsdescription__entityType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__entityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__entityType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__entityType * >*a, const char *type)
{
	for (std::vector<fimsdescription__entityType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__entityType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__entityType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, const char *tag, std::vector<fimsdescription__entityType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__entityType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__entityType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType, sizeof(fimsdescription__entityType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__entityType(soap, tag, NULL, "fimsdescription:entityType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__entityType(soap, tag, &n, "fimsdescription:entityType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__entityType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__entityType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__entityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__entityType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__entityType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__entityType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__entityType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__entityType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__entityType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__entityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__entityType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__entityType * >*)p = *(std::vector<fimsdescription__entityType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, std::vector<fimsdescription__titleType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, const std::vector<fimsdescription__titleType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__titleType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__titleType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__titleType * >*a, const char *type)
{
	for (std::vector<fimsdescription__titleType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__titleType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__titleType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, const char *tag, std::vector<fimsdescription__titleType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__titleType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__titleType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType, sizeof(fimsdescription__titleType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__titleType(soap, tag, NULL, "fimsdescription:titleType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__titleType(soap, tag, &n, "fimsdescription:titleType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__titleType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__titleType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__titleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__titleType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__titleType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__titleType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__titleType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__titleType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__titleType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__titleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__titleType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__titleType * >*)p = *(std::vector<fimsdescription__titleType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, std::vector<fimsdescription__textElementType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, const std::vector<fimsdescription__textElementType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fimsdescription__textElementType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofimsdescription__textElementType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, const char *tag, int id, const std::vector<fimsdescription__textElementType * >*a, const char *type)
{
	for (std::vector<fimsdescription__textElementType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofimsdescription__textElementType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fimsdescription__textElementType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, const char *tag, std::vector<fimsdescription__textElementType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fimsdescription__textElementType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fimsdescription__textElementType, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType, sizeof(fimsdescription__textElementType), 1))
				break;
			if (!soap_in_PointerTofimsdescription__textElementType(soap, tag, NULL, "fimsdescription:textElementType"))
				break;
		}
		else if (!soap_in_PointerTofimsdescription__textElementType(soap, tag, &n, "fimsdescription:textElementType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofimsdescription__textElementType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fimsdescription__textElementType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofimsdescription__textElementType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofimsdescription__textElementType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fimsdescription__textElementType * >);
		if (size)
			*size = sizeof(std::vector<fimsdescription__textElementType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fimsdescription__textElementType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fimsdescription__textElementType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fimsdescription__textElementType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofimsdescription__textElementType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fimsdescription__textElementType * > %p -> %p\n", q, p));
	*(std::vector<fimsdescription__textElementType * >*)p = *(std::vector<fimsdescription__textElementType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, std::vector<fims__DescriptionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, const std::vector<fims__DescriptionType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__DescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__DescriptionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, const char *tag, int id, const std::vector<fims__DescriptionType * >*a, const char *type)
{
	for (std::vector<fims__DescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__DescriptionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__DescriptionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, const char *tag, std::vector<fims__DescriptionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__DescriptionType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__DescriptionType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType, sizeof(fims__DescriptionType), 1))
				break;
			if (!soap_in_PointerTofims__DescriptionType(soap, tag, NULL, "fims:DescriptionType"))
				break;
		}
		else if (!soap_in_PointerTofims__DescriptionType(soap, tag, &n, "fims:DescriptionType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__DescriptionType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__DescriptionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__DescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__DescriptionType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__DescriptionType * >);
		if (size)
			*size = sizeof(std::vector<fims__DescriptionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__DescriptionType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__DescriptionType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__DescriptionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__DescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__DescriptionType * > %p -> %p\n", q, p));
	*(std::vector<fims__DescriptionType * >*)p = *(std::vector<fims__DescriptionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, std::vector<fims__BMEssenceLocatorType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, const std::vector<fims__BMEssenceLocatorType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMEssenceLocatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMEssenceLocatorType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMEssenceLocatorType * >*a, const char *type)
{
	for (std::vector<fims__BMEssenceLocatorType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMEssenceLocatorType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMEssenceLocatorType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, const char *tag, std::vector<fims__BMEssenceLocatorType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMEssenceLocatorType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMEssenceLocatorType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType, sizeof(fims__BMEssenceLocatorType), 1))
				break;
			if (!soap_in_PointerTofims__BMEssenceLocatorType(soap, tag, NULL, "fims:BMEssenceLocatorType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMEssenceLocatorType(soap, tag, &n, "fims:BMEssenceLocatorType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMEssenceLocatorType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMEssenceLocatorType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMEssenceLocatorType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMEssenceLocatorType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMEssenceLocatorType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMEssenceLocatorType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMEssenceLocatorType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMEssenceLocatorType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMEssenceLocatorType * >*)p = *(std::vector<fims__BMEssenceLocatorType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, std::vector<fims__BMContentFormatType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, const std::vector<fims__BMContentFormatType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMContentFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMContentFormatType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMContentFormatType * >*a, const char *type)
{
	for (std::vector<fims__BMContentFormatType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMContentFormatType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMContentFormatType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, const char *tag, std::vector<fims__BMContentFormatType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMContentFormatType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMContentFormatType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType, sizeof(fims__BMContentFormatType), 1))
				break;
			if (!soap_in_PointerTofims__BMContentFormatType(soap, tag, NULL, "fims:BMContentFormatType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMContentFormatType(soap, tag, &n, "fims:BMContentFormatType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMContentFormatType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMContentFormatType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentFormatType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentFormatType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMContentFormatType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMContentFormatType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMContentFormatType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMContentFormatType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMContentFormatType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMContentFormatType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMContentFormatType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMContentFormatType * >*)p = *(std::vector<fims__BMContentFormatType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, std::vector<fims__BMContentType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, const std::vector<fims__BMContentType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMContentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMContentType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMContentType * >*a, const char *type)
{
	for (std::vector<fims__BMContentType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMContentType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMContentType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, const char *tag, std::vector<fims__BMContentType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMContentType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMContentType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType, sizeof(fims__BMContentType), 1))
				break;
			if (!soap_in_PointerTofims__BMContentType(soap, tag, NULL, "fims:BMContentType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMContentType(soap, tag, &n, "fims:BMContentType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMContentType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMContentType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMContentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMContentType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMContentType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMContentType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMContentType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMContentType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMContentType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMContentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMContentType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMContentType * >*)p = *(std::vector<fims__BMContentType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, std::vector<fims__BMObjectType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, const std::vector<fims__BMObjectType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__BMObjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__BMObjectType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, const char *tag, int id, const std::vector<fims__BMObjectType * >*a, const char *type)
{
	for (std::vector<fims__BMObjectType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__BMObjectType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__BMObjectType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, const char *tag, std::vector<fims__BMObjectType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__BMObjectType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__BMObjectType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType, sizeof(fims__BMObjectType), 1))
				break;
			if (!soap_in_PointerTofims__BMObjectType(soap, tag, NULL, "fims:BMObjectType"))
				break;
		}
		else if (!soap_in_PointerTofims__BMObjectType(soap, tag, &n, "fims:BMObjectType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__BMObjectType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__BMObjectType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__BMObjectType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__BMObjectType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__BMObjectType * >);
		if (size)
			*size = sizeof(std::vector<fims__BMObjectType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__BMObjectType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__BMObjectType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__BMObjectType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__BMObjectType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__BMObjectType * > %p -> %p\n", q, p));
	*(std::vector<fims__BMObjectType * >*)p = *(std::vector<fims__BMObjectType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__DataFormatsType_sequence(struct soap *soap, std::vector<__fims__DataFormatsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__DataFormatsType_sequence(struct soap *soap, const std::vector<__fims__DataFormatsType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__DataFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__DataFormatsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__DataFormatsType_sequence >*a, const char *type)
{
	for (std::vector<__fims__DataFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__DataFormatsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__DataFormatsType_sequence(struct soap *soap, const char *tag, std::vector<__fims__DataFormatsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__DataFormatsType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__DataFormatsType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__DataFormatsType_sequence, sizeof(__fims__DataFormatsType_sequence), 0))
				break;
			if (!soap_in___fims__DataFormatsType_sequence(soap, tag, NULL, "-fims:DataFormatsType-sequence"))
				break;
		}
		else if (!soap_in___fims__DataFormatsType_sequence(soap, tag, &n, "-fims:DataFormatsType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__DataFormatsType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__DataFormatsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__DataFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__DataFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__DataFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__DataFormatsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__DataFormatsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__DataFormatsType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__DataFormatsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__DataFormatsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__DataFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__DataFormatsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__DataFormatsType_sequence >*)p = *(std::vector<__fims__DataFormatsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(struct soap *soap, std::vector<__fims__ContainerFormatsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(struct soap *soap, const std::vector<__fims__ContainerFormatsType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__ContainerFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__ContainerFormatsType_sequence >*a, const char *type)
{
	for (std::vector<__fims__ContainerFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__ContainerFormatsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(struct soap *soap, const char *tag, std::vector<__fims__ContainerFormatsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__ContainerFormatsType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__ContainerFormatsType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__ContainerFormatsType_sequence, sizeof(__fims__ContainerFormatsType_sequence), 0))
				break;
			if (!soap_in___fims__ContainerFormatsType_sequence(soap, tag, NULL, "-fims:ContainerFormatsType-sequence"))
				break;
		}
		else if (!soap_in___fims__ContainerFormatsType_sequence(soap, tag, &n, "-fims:ContainerFormatsType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__ContainerFormatsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__ContainerFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__ContainerFormatsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__ContainerFormatsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__ContainerFormatsType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__ContainerFormatsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__ContainerFormatsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__ContainerFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__ContainerFormatsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__ContainerFormatsType_sequence >*)p = *(std::vector<__fims__ContainerFormatsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__AudioFormatsType_sequence(struct soap *soap, std::vector<__fims__AudioFormatsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__AudioFormatsType_sequence(struct soap *soap, const std::vector<__fims__AudioFormatsType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__AudioFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__AudioFormatsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__AudioFormatsType_sequence >*a, const char *type)
{
	for (std::vector<__fims__AudioFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__AudioFormatsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__AudioFormatsType_sequence(struct soap *soap, const char *tag, std::vector<__fims__AudioFormatsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__AudioFormatsType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__AudioFormatsType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__AudioFormatsType_sequence, sizeof(__fims__AudioFormatsType_sequence), 0))
				break;
			if (!soap_in___fims__AudioFormatsType_sequence(soap, tag, NULL, "-fims:AudioFormatsType-sequence"))
				break;
		}
		else if (!soap_in___fims__AudioFormatsType_sequence(soap, tag, &n, "-fims:AudioFormatsType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__AudioFormatsType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__AudioFormatsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__AudioFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__AudioFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__AudioFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__AudioFormatsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__AudioFormatsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__AudioFormatsType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__AudioFormatsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__AudioFormatsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__AudioFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__AudioFormatsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__AudioFormatsType_sequence >*)p = *(std::vector<__fims__AudioFormatsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__VideoFormatsType_sequence(struct soap *soap, std::vector<__fims__VideoFormatsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__VideoFormatsType_sequence(struct soap *soap, const std::vector<__fims__VideoFormatsType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__VideoFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__VideoFormatsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__VideoFormatsType_sequence >*a, const char *type)
{
	for (std::vector<__fims__VideoFormatsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__VideoFormatsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__VideoFormatsType_sequence(struct soap *soap, const char *tag, std::vector<__fims__VideoFormatsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__VideoFormatsType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__VideoFormatsType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__VideoFormatsType_sequence, sizeof(__fims__VideoFormatsType_sequence), 0))
				break;
			if (!soap_in___fims__VideoFormatsType_sequence(soap, tag, NULL, "-fims:VideoFormatsType-sequence"))
				break;
		}
		else if (!soap_in___fims__VideoFormatsType_sequence(soap, tag, &n, "-fims:VideoFormatsType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__VideoFormatsType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__VideoFormatsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__VideoFormatsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__VideoFormatsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__VideoFormatsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__VideoFormatsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__VideoFormatsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__VideoFormatsType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__VideoFormatsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__VideoFormatsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__VideoFormatsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__VideoFormatsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__VideoFormatsType_sequence >*)p = *(std::vector<__fims__VideoFormatsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__JobsType_sequence(struct soap *soap, std::vector<__fims__JobsType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__JobsType_sequence(struct soap *soap, const std::vector<__fims__JobsType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__JobsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__JobsType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__JobsType_sequence >*a, const char *type)
{
	for (std::vector<__fims__JobsType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__JobsType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__JobsType_sequence(struct soap *soap, const char *tag, std::vector<__fims__JobsType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__JobsType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__JobsType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__JobsType_sequence, sizeof(__fims__JobsType_sequence), 0))
				break;
			if (!soap_in___fims__JobsType_sequence(soap, tag, NULL, "-fims:JobsType-sequence"))
				break;
		}
		else if (!soap_in___fims__JobsType_sequence(soap, tag, &n, "-fims:JobsType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__JobsType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__JobsType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__JobsType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__JobsType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__JobsType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__JobsType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__JobsType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__JobsType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__JobsType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__JobsType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__JobsType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__JobsType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__JobsType_sequence >*)p = *(std::vector<__fims__JobsType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__QueuesType_sequence(struct soap *soap, std::vector<__fims__QueuesType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__QueuesType_sequence(struct soap *soap, const std::vector<__fims__QueuesType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__QueuesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__QueuesType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__QueuesType_sequence >*a, const char *type)
{
	for (std::vector<__fims__QueuesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__QueuesType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__QueuesType_sequence(struct soap *soap, const char *tag, std::vector<__fims__QueuesType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__QueuesType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__QueuesType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__QueuesType_sequence, sizeof(__fims__QueuesType_sequence), 0))
				break;
			if (!soap_in___fims__QueuesType_sequence(soap, tag, NULL, "-fims:QueuesType-sequence"))
				break;
		}
		else if (!soap_in___fims__QueuesType_sequence(soap, tag, &n, "-fims:QueuesType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__QueuesType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__QueuesType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__QueuesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__QueuesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__QueuesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__QueuesType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__QueuesType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__QueuesType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__QueuesType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__QueuesType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__QueuesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__QueuesType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__QueuesType_sequence >*)p = *(std::vector<__fims__QueuesType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__ServicesType_sequence(struct soap *soap, std::vector<__fims__ServicesType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__ServicesType_sequence(struct soap *soap, const std::vector<__fims__ServicesType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__ServicesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__ServicesType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__ServicesType_sequence >*a, const char *type)
{
	for (std::vector<__fims__ServicesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__ServicesType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__ServicesType_sequence(struct soap *soap, const char *tag, std::vector<__fims__ServicesType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__ServicesType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__ServicesType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__ServicesType_sequence, sizeof(__fims__ServicesType_sequence), 0))
				break;
			if (!soap_in___fims__ServicesType_sequence(soap, tag, NULL, "-fims:ServicesType-sequence"))
				break;
		}
		else if (!soap_in___fims__ServicesType_sequence(soap, tag, &n, "-fims:ServicesType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__ServicesType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__ServicesType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__ServicesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__ServicesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__ServicesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__ServicesType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__ServicesType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__ServicesType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__ServicesType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__ServicesType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__ServicesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__ServicesType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__ServicesType_sequence >*)p = *(std::vector<__fims__ServicesType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__ProfilesType_sequence(struct soap *soap, std::vector<__fims__ProfilesType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__ProfilesType_sequence(struct soap *soap, const std::vector<__fims__ProfilesType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__ProfilesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__ProfilesType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__ProfilesType_sequence >*a, const char *type)
{
	for (std::vector<__fims__ProfilesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__ProfilesType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__ProfilesType_sequence(struct soap *soap, const char *tag, std::vector<__fims__ProfilesType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__ProfilesType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__ProfilesType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__ProfilesType_sequence, sizeof(__fims__ProfilesType_sequence), 0))
				break;
			if (!soap_in___fims__ProfilesType_sequence(soap, tag, NULL, "-fims:ProfilesType-sequence"))
				break;
		}
		else if (!soap_in___fims__ProfilesType_sequence(soap, tag, &n, "-fims:ProfilesType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__ProfilesType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__ProfilesType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__ProfilesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__ProfilesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__ProfilesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__ProfilesType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__ProfilesType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__ProfilesType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__ProfilesType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__ProfilesType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__ProfilesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__ProfilesType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__ProfilesType_sequence >*)p = *(std::vector<__fims__ProfilesType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf__fims__ResourcesType_sequence(struct soap *soap, std::vector<__fims__ResourcesType_sequence >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf__fims__ResourcesType_sequence(struct soap *soap, const std::vector<__fims__ResourcesType_sequence >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<__fims__ResourcesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf__fims__ResourcesType_sequence(struct soap *soap, const char *tag, int id, const std::vector<__fims__ResourcesType_sequence >*a, const char *type)
{
	for (std::vector<__fims__ResourcesType_sequence >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<__fims__ResourcesType_sequence >* SOAP_FMAC4 soap_in_std__vectorTemplateOf__fims__ResourcesType_sequence(struct soap *soap, const char *tag, std::vector<__fims__ResourcesType_sequence >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	__fims__ResourcesType_sequence n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n.soap_default(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE___fims__ResourcesType_sequence, SOAP_TYPE_std__vectorTemplateOf__fims__ResourcesType_sequence, sizeof(__fims__ResourcesType_sequence), 0))
				break;
			if (!soap_in___fims__ResourcesType_sequence(soap, tag, NULL, "-fims:ResourcesType-sequence"))
				break;
		}
		else if (!soap_in___fims__ResourcesType_sequence(soap, tag, &n, "-fims:ResourcesType-sequence"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf__fims__ResourcesType_sequence(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<__fims__ResourcesType_sequence > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf__fims__ResourcesType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf__fims__ResourcesType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf__fims__ResourcesType_sequence, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<__fims__ResourcesType_sequence >);
		if (size)
			*size = sizeof(std::vector<__fims__ResourcesType_sequence >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<__fims__ResourcesType_sequence >, n);
		if (size)
			*size = n * sizeof(std::vector<__fims__ResourcesType_sequence >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<__fims__ResourcesType_sequence >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf__fims__ResourcesType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<__fims__ResourcesType_sequence > %p -> %p\n", q, p));
	*(std::vector<__fims__ResourcesType_sequence >*)p = *(std::vector<__fims__ResourcesType_sequence >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, std::vector<fims__InnerFaultType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, const std::vector<fims__InnerFaultType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<fims__InnerFaultType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTofims__InnerFaultType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, const char *tag, int id, const std::vector<fims__InnerFaultType * >*a, const char *type)
{
	for (std::vector<fims__InnerFaultType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTofims__InnerFaultType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<fims__InnerFaultType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, const char *tag, std::vector<fims__InnerFaultType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	fims__InnerFaultType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_fims__InnerFaultType, SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType, sizeof(fims__InnerFaultType), 1))
				break;
			if (!soap_in_PointerTofims__InnerFaultType(soap, tag, NULL, "fims:InnerFaultType"))
				break;
		}
		else if (!soap_in_PointerTofims__InnerFaultType(soap, tag, &n, "fims:InnerFaultType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTofims__InnerFaultType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<fims__InnerFaultType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTofims__InnerFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTofims__InnerFaultType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<fims__InnerFaultType * >);
		if (size)
			*size = sizeof(std::vector<fims__InnerFaultType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<fims__InnerFaultType * >, n);
		if (size)
			*size = n * sizeof(std::vector<fims__InnerFaultType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<fims__InnerFaultType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTofims__InnerFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<fims__InnerFaultType * > %p -> %p\n", q, p));
	*(std::vector<fims__InnerFaultType * >*)p = *(std::vector<fims__InnerFaultType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	char *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else if (!soap_inliteral(soap, tag, &n))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<char * >);
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<char * >, n);
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, std::vector<edlprovider__ClipType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, const std::vector<edlprovider__ClipType * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<edlprovider__ClipType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToedlprovider__ClipType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, const char *tag, int id, const std::vector<edlprovider__ClipType * >*a, const char *type)
{
	for (std::vector<edlprovider__ClipType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToedlprovider__ClipType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<edlprovider__ClipType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, const char *tag, std::vector<edlprovider__ClipType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	edlprovider__ClipType *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_edlprovider__ClipType, SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType, sizeof(edlprovider__ClipType), 1))
				break;
			if (!soap_in_PointerToedlprovider__ClipType(soap, tag, NULL, "edlprovider:ClipType"))
				break;
		}
		else if (!soap_in_PointerToedlprovider__ClipType(soap, tag, &n, "edlprovider:ClipType"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerToedlprovider__ClipType(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<edlprovider__ClipType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToedlprovider__ClipType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToedlprovider__ClipType, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<edlprovider__ClipType * >);
		if (size)
			*size = sizeof(std::vector<edlprovider__ClipType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<edlprovider__ClipType * >, n);
		if (size)
			*size = n * sizeof(std::vector<edlprovider__ClipType * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<edlprovider__ClipType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToedlprovider__ClipType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<edlprovider__ClipType * > %p -> %p\n", q, p));
	*(std::vector<edlprovider__ClipType * >*)p = *(std::vector<edlprovider__ClipType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__wstring(struct soap *soap, std::vector<std::wstring >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__wstring(struct soap *soap, const std::vector<std::wstring >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__wstring(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__wstring(struct soap *soap, const char *tag, int id, const std::vector<std::wstring >*a, const char *type)
{
	for (std::vector<std::wstring >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__wstring(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::wstring >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__wstring(struct soap *soap, const char *tag, std::vector<std::wstring >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::wstring n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__wstring(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__wstring, SOAP_TYPE_std__vectorTemplateOfstd__wstring, sizeof(std::wstring), 0))
				break;
			if (!soap_in_std__wstring(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__wstring(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__wstring(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::wstring > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__wstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__wstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__wstring, n, EDLProvider_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::wstring >);
		if (size)
			*size = sizeof(std::vector<std::wstring >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::wstring >, n);
		if (size)
			*size = n * sizeof(std::vector<std::wstring >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::wstring >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__wstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::wstring > %p -> %p\n", q, p));
	*(std::vector<std::wstring >*)p = *(std::vector<std::wstring >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of EDLProviderC.cpp */

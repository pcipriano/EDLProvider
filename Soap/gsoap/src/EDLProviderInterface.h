// Reminder: Modify typemap.dat to customize the header file generated by wsdl2h
/* D:\Sandbox\EdlProvider\Soap\gsoap\src\EDLProviderInterface.h
   Generated by wsdl2h 2.8.17r from D:\Sandbox\EdlProvider\Soap\gsoap\..\Wsdl\EDLProvider.wsdl and D:\Sandbox\EdlProvider\Soap\gsoap\typemapcustom.dat
   2014-04-12 19:16:59 GMT

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS
   USE THE soapcpp2-GENERATED SOURCE CODE FILES FOR YOUR PROJECT BUILDS

   gSOAP XML Web services tools.
   Copyright (C) 2000-2013 Robert van Engelen, Genivia Inc. All Rights Reserved.
   Part of this software is released under one of the following licenses:
   GPL or Genivia's license for commercial use.
*/

/** @page page_notes Usage Notes

NOTE:

 - Run soapcpp2 on D:\Sandbox\EdlProvider\Soap\gsoap\src\EDLProviderInterface.h to generate the SOAP/XML processing logic.
   Use soapcpp2 -I to specify paths for #import
   To build with STL, 'stlvector.h' is imported from 'import' dir in package.
   Use soapcpp2 -j to generate improved proxy and server classes.
 - Use wsdl2h -c and -s to generate pure C code or C++ code without STL.
 - Use 'typemap.dat' to control namespace bindings and type mappings.
   It is strongly recommended to customize the names of the namespace prefixes
   generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
   section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
 - Use Doxygen (www.doxygen.org) on this file to generate documentation.
 - Use wsdl2h -R to generate REST operations.
 - Use wsdl2h -nname to use name as the base namespace prefix instead of 'ns'.
 - Use wsdl2h -Nname for service prefix and produce multiple service bindings
 - Use wsdl2h -d to enable DOM support for xsd:anyType.
 - Use wsdl2h -g to auto-generate readers and writers for root elements.
 - Use wsdl2h -b to auto-generate bi-directional operations (duplex ops).
 - Struct/class members serialized as XML attributes are annotated with a '@'.
 - Struct/class members that have a special role are annotated with a '$'.

WARNING:

   DO NOT INCLUDE THIS ANNOTATED FILE DIRECTLY IN YOUR PROJECT SOURCE CODE.
   USE THE FILES GENERATED BY soapcpp2 FOR YOUR PROJECT'S SOURCE CODE:
   THE soapStub.h FILE CONTAINS THIS CONTENT WITHOUT ANNOTATIONS.

LICENSE:

@verbatim
--------------------------------------------------------------------------------
gSOAP XML Web services tools
Copyright (C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.

This software is released under one of the following licenses:
GPL or Genivia's license for commercial use.
--------------------------------------------------------------------------------
GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org

This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial-use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
@endverbatim

*/


//gsoapopt w

/******************************************************************************\
 *                                                                            *
 * Definitions                                                                *
 *   http://temp/edlprovider                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Import                                                                     *
 *                                                                            *
\******************************************************************************/


// STL vector containers (use option -s to remove STL dependency)
#import "stlvector.h"

/******************************************************************************\
 *                                                                            *
 * Schema Namespaces                                                          *
 *                                                                            *
\******************************************************************************/


/* NOTE:

It is strongly recommended to customize the names of the namespace prefixes
generated by wsdl2h. To do so, modify the prefix bindings below and add the
modified lines to typemap.dat to rerun wsdl2h:

edlprovider = "http://temp/edlprovider"
fims = "http://base.fims.tv"
fimsdescription = "http://description.fims.tv"

*/

#define SOAP_NAMESPACE_OF_edlprovider	"http://temp/edlprovider"
//gsoap edlprovider schema namespace:	http://temp/edlprovider
//gsoap edlprovider schema form:	unqualified

#define SOAP_NAMESPACE_OF_fims	"http://base.fims.tv"
//gsoap fims  schema namespace:	http://base.fims.tv
//gsoap fims  schema elementForm:	qualified
//gsoap fims  schema attributeForm:	unqualified

#define SOAP_NAMESPACE_OF_fimsdescription	"http://description.fims.tv"
//gsoap fimsdescription schema namespace:	http://description.fims.tv
//gsoap fimsdescription schema elementForm:	qualified
//gsoap fimsdescription schema attributeForm:	unqualified

/******************************************************************************\
 *                                                                            *
 * Built-in Schema Types and Top-Level Elements and Attributes                *
 *                                                                            *
\******************************************************************************/


/// Built-in type "xs:base64Binary".
class xsd__base64Binary
{	unsigned char *__ptr;
	int __size;
	char *id, *type, *options; // NOTE: non-NULL for DIMEM/MIME/MTOM XOP attachments only
	struct soap *soap;
};

/// Built-in type "xs:duration".
#import "custom/duration.h"

/// Built-in type "xs:hexBinary".
class xsd__hexBinary { unsigned char *__ptr; int __size; };

/// Primitive built-in type "xs:NMTOKEN"
typedef std::wstring xsd__NMTOKEN;

/// Primitive built-in type "xs:anyURI"
typedef std::wstring xsd__anyURI;

/// Primitive built-in type "xs:date"
typedef std::wstring xsd__date;

/// Primitive built-in type "xs:decimal"
typedef std::wstring xsd__decimal;

/// Primitive built-in type "xs:gYear"
typedef std::wstring xsd__gYear;

/// Primitive built-in type "xs:integer"
typedef std::wstring xsd__integer;

/// Primitive built-in type "xs:language"
typedef std::wstring xsd__language;

/// Primitive built-in type "xs:nonNegativeInteger"
typedef std::wstring xsd__nonNegativeInteger;

/// Primitive built-in type "xs:positiveInteger"
typedef std::wstring xsd__positiveInteger;

/// Primitive built-in type "xs:time"
typedef std::wstring xsd__time;

/// Built-in attribute "xml:lang".
typedef std::wstring _xml__lang;

/******************************************************************************\
 *                                                                            *
 * Forward Declarations                                                       *
 *                                                                            *
\******************************************************************************/



//  Forward declaration of class edlprovider__ArrayOfstring.
class edlprovider__ArrayOfstring;

//  Forward declaration of class edlprovider__ArrayOfClips.
class edlprovider__ArrayOfClips;

//  Forward declaration of class edlprovider__ClipType.
class edlprovider__ClipType;

//  Forward declaration of class edlprovider__EdlCreateRequestBaseType.
class edlprovider__EdlCreateRequestBaseType;

//  Forward declaration of class edlprovider__EdlCreateRequestType.
class edlprovider__EdlCreateRequestType;

//  Forward declaration of class edlprovider__EdlCreateRequestDoubleType.
class edlprovider__EdlCreateRequestDoubleType;

//  Forward declaration of class edlprovider__EdlCreateResponseType.
class edlprovider__EdlCreateResponseType;

//  Forward declaration of class edlprovider__EdlProviderFaultType.
class edlprovider__EdlProviderFaultType;

//  Forward declaration of class fims__ExtensionGroup.
class fims__ExtensionGroup;

//  Forward declaration of class fims__ExtensionAttributes.
class fims__ExtensionAttributes;

//  Forward declaration of class fims__ResourceReferenceType.
class fims__ResourceReferenceType;

//  Forward declaration of class fims__ResourceType.
class fims__ResourceType;

//  Forward declaration of class fims__AsyncEndpointType.
class fims__AsyncEndpointType;

//  Forward declaration of class fims__ServiceType.
class fims__ServiceType;

//  Forward declaration of class fims__ProfileType.
class fims__ProfileType;

//  Forward declaration of class fims__QueueType.
class fims__QueueType;

//  Forward declaration of class fims__JobType.
class fims__JobType;

//  Forward declaration of class fims__FormatType.
class fims__FormatType;

//  Forward declaration of class fims__VideoFormatType.
class fims__VideoFormatType;

//  Forward declaration of class fims__AudioFormatType.
class fims__AudioFormatType;

//  Forward declaration of class fims__DataFormatType.
class fims__DataFormatType;

//  Forward declaration of class fims__CaptioningFormatType.
class fims__CaptioningFormatType;

//  Forward declaration of class fims__AncillaryDataFormatType.
class fims__AncillaryDataFormatType;

//  Forward declaration of class fims__ContainerFormatType.
class fims__ContainerFormatType;

//  Forward declaration of class fims__BMTrackType.
class fims__BMTrackType;

//  Forward declaration of class fims__CodecType.
class fims__CodecType;

//  Forward declaration of class fims__BMObjectType.
class fims__BMObjectType;

//  Forward declaration of class fims__BMContentType.
class fims__BMContentType;

//  Forward declaration of class fims__DescriptionType.
class fims__DescriptionType;

//  Forward declaration of class fims__BMContentFormatType.
class fims__BMContentFormatType;

//  Forward declaration of class fims__BMEssenceLocatorType.
class fims__BMEssenceLocatorType;

//  Forward declaration of class fims__SimpleFileLocatorType.
class fims__SimpleFileLocatorType;

//  Forward declaration of class fims__ListFileLocatorType.
class fims__ListFileLocatorType;

//  Forward declaration of class fims__FolderLocatorType.
class fims__FolderLocatorType;

//  Forward declaration of class fims__TransferAtomType.
class fims__TransferAtomType;

//  Forward declaration of class fims__TransformAtomType.
class fims__TransformAtomType;

//  Forward declaration of class fims__TechnicalAttributeType.
class fims__TechnicalAttributeType;

//  Forward declaration of class fims__LengthType.
class fims__LengthType;

//  Forward declaration of class fims__RationalType.
class fims__RationalType;

//  Forward declaration of class fims__HashType.
class fims__HashType;

//  Forward declaration of class fims__EditUnitNumberType.
class fims__EditUnitNumberType;

//  Forward declaration of class fims__ProcessedInfoType.
class fims__ProcessedInfoType;

//  Forward declaration of class fims__ProcessedInfoByBytesType.
class fims__ProcessedInfoByBytesType;

//  Forward declaration of class fims__ProcessedInfoByFramesType.
class fims__ProcessedInfoByFramesType;

//  Forward declaration of class fims__DurationType.
class fims__DurationType;

//  Forward declaration of class fims__TimeType.
class fims__TimeType;

//  Forward declaration of class fims__StorageType.
class fims__StorageType;

//  Forward declaration of class fims__HashFunctionType.
class fims__HashFunctionType;

//  Forward declaration of class fims__StartProcessType.
class fims__StartProcessType;

//  Forward declaration of class fims__StartProcessByNoWaitType.
class fims__StartProcessByNoWaitType;

//  Forward declaration of class fims__StartProcessByTimeType.
class fims__StartProcessByTimeType;

//  Forward declaration of class fims__StartProcessByTimeMarkType.
class fims__StartProcessByTimeMarkType;

//  Forward declaration of class fims__StartProcessByServiceDefinedTimeType.
class fims__StartProcessByServiceDefinedTimeType;

//  Forward declaration of class fims__StopProcessType.
class fims__StopProcessType;

//  Forward declaration of class fims__StopProcessByTimeType.
class fims__StopProcessByTimeType;

//  Forward declaration of class fims__StopProcessByDurationType.
class fims__StopProcessByDurationType;

//  Forward declaration of class fims__StopProcessByTimeMarkType.
class fims__StopProcessByTimeMarkType;

//  Forward declaration of class fims__StopProcessByServiceDefinedTimeType.
class fims__StopProcessByServiceDefinedTimeType;

//  Forward declaration of class fims__StopProcessByOpenEndType.
class fims__StopProcessByOpenEndType;

//  Forward declaration of class fims__StartJobType.
class fims__StartJobType;

//  Forward declaration of class fims__StartJobByNoWaitType.
class fims__StartJobByNoWaitType;

//  Forward declaration of class fims__StartJobByTimeType.
class fims__StartJobByTimeType;

//  Forward declaration of class fims__StartJobByLatestType.
class fims__StartJobByLatestType;

//  Forward declaration of class fims__ManageJobRequestType.
class fims__ManageJobRequestType;

//  Forward declaration of class fims__ManageJobResponseType.
class fims__ManageJobResponseType;

//  Forward declaration of class fims__ManageQueueRequestType.
class fims__ManageQueueRequestType;

//  Forward declaration of class fims__ManageQueueResponseType.
class fims__ManageQueueResponseType;

//  Forward declaration of class fims__QueryJobRequestType.
class fims__QueryJobRequestType;

//  Forward declaration of class fims__QueryJobRequestByIDType.
class fims__QueryJobRequestByIDType;

//  Forward declaration of class fims__QueryJobRequestByFilterType.
class fims__QueryJobRequestByFilterType;

//  Forward declaration of class fims__QueryJobResponseType.
class fims__QueryJobResponseType;

//  Forward declaration of class fims__QueryServiceDescriptionRequestType.
class fims__QueryServiceDescriptionRequestType;

//  Forward declaration of class fims__QueryServiceDescriptionResponseType.
class fims__QueryServiceDescriptionResponseType;

//  Forward declaration of class fims__ListFilterType.
class fims__ListFilterType;

//  Forward declaration of class fims__FaultType.
class fims__FaultType;

//  Forward declaration of class fims__InnerFaultType.
class fims__InnerFaultType;

//  Forward declaration of class fims__ResourcesType.
class fims__ResourcesType;

//  Forward declaration of class fims__ProfilesType.
class fims__ProfilesType;

//  Forward declaration of class fims__ServicesType.
class fims__ServicesType;

//  Forward declaration of class fims__QueuesType.
class fims__QueuesType;

//  Forward declaration of class fims__JobsType.
class fims__JobsType;

//  Forward declaration of class fims__VideoFormatsType.
class fims__VideoFormatsType;

//  Forward declaration of class fims__AudioFormatsType.
class fims__AudioFormatsType;

//  Forward declaration of class fims__ContainerFormatsType.
class fims__ContainerFormatsType;

//  Forward declaration of class fims__DataFormatsType.
class fims__DataFormatsType;

//  Forward declaration of class fims__BMObjectsType.
class fims__BMObjectsType;

//  Forward declaration of class fims__BMContentsType.
class fims__BMContentsType;

//  Forward declaration of class fims__BMContentFormatsType.
class fims__BMContentFormatsType;

//  Forward declaration of class fims__BMEssenceLocatorsType.
class fims__BMEssenceLocatorsType;

//  Forward declaration of class fims__DescriptionsType.
class fims__DescriptionsType;

//  Forward declaration of class _fims__formatCollection.
class _fims__formatCollection;

//  Forward declaration of class fimsdescription__bmContentDescriptionType.
class fimsdescription__bmContentDescriptionType;

//  Forward declaration of class fimsdescription__titleType.
class fimsdescription__titleType;

//  Forward declaration of class fimsdescription__identifierType.
class fimsdescription__identifierType;

//  Forward declaration of class fimsdescription__subjectType.
class fimsdescription__subjectType;

//  Forward declaration of class fimsdescription__typeType.
class fimsdescription__typeType;

//  Forward declaration of class fimsdescription__descriptionType.
class fimsdescription__descriptionType;

//  Forward declaration of class fimsdescription__coverageType.
class fimsdescription__coverageType;

//  Forward declaration of class fimsdescription__rightsType.
class fimsdescription__rightsType;

//  Forward declaration of class fimsdescription__textElementType.
class fimsdescription__textElementType;

//  Forward declaration of class fimsdescription__dateType.
class fimsdescription__dateType;

//  Forward declaration of class fimsdescription__entityType.
class fimsdescription__entityType;

//  Forward declaration of class fimsdescription__contactDetailsType.
class fimsdescription__contactDetailsType;

//  Forward declaration of class fimsdescription__organisationDetailsType.
class fimsdescription__organisationDetailsType;

//  Forward declaration of class fimsdescription__detailsType.
class fimsdescription__detailsType;

//  Forward declaration of class fimsdescription__addressType.
class fimsdescription__addressType;

//  Forward declaration of class fimsdescription__languageType.
class fimsdescription__languageType;

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://temp/edlprovider                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://base.fims.tv                                                      *
 *                                                                            *
\******************************************************************************/


/// union of values "bms:UUID bms:UMID bms:UL bms:EmptyID"
typedef std::wstring fims__UID;

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://description.fims.tv                                               *
 *                                                                            *
\******************************************************************************/


/// "http://temp/edlprovider":EDLProviderErrorCodeType is a simpleType restriction of xs:string.
/// @brief Specific error codes for the EDL provider service, possible errors: - INF_S00_xxxx: Infrastructure errors (system, storage, network, memory, processor) - DAT_S00_xxxx: Data errors (validation, missing, duplication) - SVC_S00_xxxx: Operation errors (existence, support, lock, connection, failure) - SEC_S00_xxxx: Security errors (authentication, authorization) - EXT_S00_xxxx: Extended code.
/// Note: enum values are prefixed with 'edlprovider__EDLProviderErrorCodeType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum edlprovider__EDLProviderErrorCodeType
{
/// @brief EDL type not found.
	edlprovider__EDLProviderErrorCodeType__EXT_USCORES00_USCORE0001,	///< xs:string value="EXT_S00_0001"
};

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://base.fims.tv                                                      *
 *                                                                            *
\******************************************************************************/


/// "http://base.fims.tv":UUID is a simpleType restriction of xs:string.
/// @brief A universally unique identifier (UUID) or globally unique identifier (GUID) that may be represented as a URN as per RFC 4122.
/// Content pattern is "(urn:uuid:)?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" (note: not automatically enforced)
typedef std::wstring fims__UUID "(urn:uuid:)?[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}";

/// "http://base.fims.tv":UMID is a simpleType restriction of xs:string.
/// @brief A SMPTE unique material number, as specified in SMPTE ST 330 and represented as a URN according to SMPTE ST 2029.
/// Content pattern is "urn:smpte:umid:([0-9a-fA-F]{8}\\.){7}[0-9a-fA-F]{8}" (note: not automatically enforced)
typedef std::wstring fims__UMID "urn:smpte:umid:([0-9a-fA-F]{8}\\.){7}[0-9a-fA-F]{8}";

/// "http://base.fims.tv":UL is a simpleType restriction of xs:string.
/// @brief A SMPTE universal label, as specified in SMPTE ST 298 and represented as a URN according to SMPTE ST 2029.
/// Content pattern is "urn:smpte:ul:([0-9a-fA-F]{8}\\.){3}[0-9a-fA-F]{8}" (note: not automatically enforced)
typedef std::wstring fims__UL "urn:smpte:ul:([0-9a-fA-F]{8}\\.){3}[0-9a-fA-F]{8}";

/// "http://base.fims.tv":EmptyID is a simpleType restriction of xs:string.
/// @brief Empty identification permitted to enable validation of documents where identities are not yet known.
/// Length of this string is exactly 0 characters
typedef std::wstring fims__EmptyID;

/// "http://base.fims.tv":ResourceIDType is a simpleType restriction of "http://base.fims.tv":UID.
/// @brief This type provides a unique way to identify a resource.
typedef fims__UID fims__ResourceIDType;

/// "http://base.fims.tv":RevisionIDType is a simpleType restriction of xs:NMTOKEN.
/// @brief Identification of a specific revision of a resource.
typedef xsd__NMTOKEN fims__RevisionIDType;

/// "http://base.fims.tv":Timecode is a simpleType restriction of xs:string.
/// @brief A SMPTE ST 12-1 timecode value formatted according to the edit decision list grammar specified in SMPTE ST 258.
/// Content pattern is "(([0-1][0-9])|([2][0-3])):[0-5][0-9]:[0-5][0-9](([.,])|([:;]))[0-2][0-9]" (note: not automatically enforced)
typedef std::wstring fims__Timecode "(([0-1][0-9])|([2][0-3])):[0-5][0-9]:[0-5][0-9](([.,])|([:;]))[0-2][0-9]";

/// "http://base.fims.tv":TimecodeDuration is a simpleType restriction of xs:string.
/// @brief A representation of AV duration as a SMPTE timecode-like value, with an upper bound of 99 hours rather than 23 hours.
/// Content pattern is "[0-9][0-9]:[0-5][0-9]:[0-5][0-9](([.,])|([:;]))[0-2][0-9]" (note: not automatically enforced)
typedef std::wstring fims__TimecodeDuration "[0-9][0-9]:[0-5][0-9]:[0-5][0-9](([.,])|([:;]))[0-2][0-9]";

/// "http://base.fims.tv":QueueStatusType is a simpleType restriction of xs:string.
/// @brief Current state of a queue.
/// Note: enum values are prefixed with 'fims__QueueStatusType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__QueueStatusType
{
/// @brief Queue has started successfully.
	fims__QueueStatusType__started,	///< xs:string value="started"
/// @brief Queue has been stopped successfully. The queue is not accepting newly submitted jobs.
	fims__QueueStatusType__stopped,	///< xs:string value="stopped"
/// @brief Queue has been locked successfully and will not accept any new submitted jobs. The jobs already in the queue will continue to start or run to completion.
	fims__QueueStatusType__locked,	///< xs:string value="locked"
};

/// "http://base.fims.tv":PriorityType is a simpleType restriction of xs:string.
/// @brief Acceptable priority values used to determine the execution order of jobs. See specification Part1 "Job Execution Priority".
/// Note: enum values are prefixed with 'fims__PriorityType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__PriorityType
{
/// @brief Job initially allocated to the end of the queue.
	fims__PriorityType__low,	///< xs:string value="low"
/// @brief Job initially allocated to be executed before any low priority jobs but after any existing medium priority jobs.
	fims__PriorityType__medium,	///< xs:string value="medium"
/// @brief Job initially allocated before any medium and low priority jobs but after existing high priority jobs.
	fims__PriorityType__high,	///< xs:string value="high"
/// @brief Job initially allocated to be executed before any high, medium and low priority jobs but after existing urgent jobs.
	fims__PriorityType__urgent,	///< xs:string value="urgent"
/// @brief Job should be executed as soon as the request is received.
	fims__PriorityType__immediate,	///< xs:string value="immediate"
};

/// "http://base.fims.tv":StorageTypes is a simpleType restriction of xs:string.
/// @brief Different kinds of storage media available (e.g. online on disk).
/// Note: enum values are prefixed with 'fims__StorageTypes' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__StorageTypes
{
/// @brief
	fims__StorageTypes__online,	///< xs:string value="online"
/// @brief
	fims__StorageTypes__offline,	///< xs:string value="offline"
/// @brief
	fims__StorageTypes__hsm,	///< xs:string value="hsm"
/// @brief
	fims__StorageTypes__archive,	///< xs:string value="archive"
/// @brief
	fims__StorageTypes__playout,	///< xs:string value="playout"
/// @brief
	fims__StorageTypes__other,	///< xs:string value="other"
};

/// "http://base.fims.tv":QueueCommandType is a simpleType restriction of xs:string.
/// @brief Commands for the control and management of a queue. All commands are optional.
/// Note: enum values are prefixed with 'fims__QueueCommandType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__QueueCommandType
{
/// @brief Retrieve the current status of the queue.
	fims__QueueCommandType__status,	///< xs:string value="status"
/// @brief Delete all remaining jobs in the queue.
	fims__QueueCommandType__clear,	///< xs:string value="clear"
/// @brief Stop the queue. Jobs cannot then be en-queued or de-queued.
	fims__QueueCommandType__stop,	///< xs:string value="stop"
/// @brief Restart a stopped queue.
	fims__QueueCommandType__start,	///< xs:string value="start"
/// @brief Lock the queue. Jobs cannot be en-queued but they are still being processed and can be deleted.
	fims__QueueCommandType__lock,	///< xs:string value="lock"
/// @brief Unlock a locked queue.
	fims__QueueCommandType__unlock,	///< xs:string value="unlock"
};

/// "http://base.fims.tv":JobCommandType is a simpleType restriction of xs:string.
/// @brief Commands for the control and management of a job. All commands are optional.
/// Note: enum values are prefixed with 'fims__JobCommandType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__JobCommandType
{
/// @brief Cancel the job.
	fims__JobCommandType__cancel,	///< xs:string value="cancel"
/// @brief Pause the job. It can be restarted with resume.
	fims__JobCommandType__pause,	///< xs:string value="pause"
/// @brief Resume the job from its paused state.
	fims__JobCommandType__resume,	///< xs:string value="resume"
/// @brief Restart the job from the beginning.
	fims__JobCommandType__restart,	///< xs:string value="restart"
/// @brief Stop the job.
	fims__JobCommandType__stop,	///< xs:string value="stop"
/// @brief Remove all the data associated with the job.
	fims__JobCommandType__cleanup,	///< xs:string value="cleanup"
/// @brief Modify the priority of the job.
	fims__JobCommandType__modifyPriority,	///< xs:string value="modifyPriority"
};

/// "http://base.fims.tv":HashFunctionTypes is a simpleType restriction of xs:string.
/// @brief Different hash functions that can be used to hash the content, as defined in SMPTE ST 2032.
/// Note: enum values are prefixed with 'fims__HashFunctionTypes' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__HashFunctionTypes
{
/// @brief 32-bit Cyclic Redundancy Check, as defined in ISO 3309.
	fims__HashFunctionTypes__CRC32,	///< xs:string value="CRC32"
/// @brief 64-bit Cyclic Redundancy Check, as defined in ISO 3309.
	fims__HashFunctionTypes__CRC64,	///< xs:string value="CRC64"
/// @brief 128-bit Message Digest Algorithm 5, as defined in RFC 1321.
	fims__HashFunctionTypes__MD5,	///< xs:string value="MD5"
/// @brief 160-bit Secure Hash Algorithm, as defined in FIPS 180-2.
	fims__HashFunctionTypes__SHA1,	///< xs:string value="SHA1"
/// @brief 256-bit Secure Hash Algorithm, as defined in FIPS 180-2.
	fims__HashFunctionTypes__SHA256,	///< xs:string value="SHA256"
/// @brief 84-bit Secure Hash Algorithm, as defined in FIPS 180-2.
	fims__HashFunctionTypes__SHA384,	///< xs:string value="SHA384"
/// @brief 512-bit Secure Hash Algorithm, as defined in FIPS 180-2.
	fims__HashFunctionTypes__SHA512,	///< xs:string value="SHA512"
};

/// "http://base.fims.tv":JobStatusType is a simpleType restriction of xs:string.
/// @brief All possible states for a job.
/// Note: enum values are prefixed with 'fims__JobStatusType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__JobStatusType
{
/// @brief Job is in the queue and is ready to start.
	fims__JobStatusType__queued,	///< xs:string value="queued"
/// @brief Job has started successfully and is currently running.
	fims__JobStatusType__running,	///< xs:string value="running"
/// @brief Job has been paused.
	fims__JobStatusType__paused,	///< xs:string value="paused"
/// @brief Job has completed successfully.
	fims__JobStatusType__completed,	///< xs:string value="completed"
/// @brief Job has been canceled.
	fims__JobStatusType__canceled,	///< xs:string value="canceled"
/// @brief Job has been stopped. A partial result may be retrieved.
	fims__JobStatusType__stopped,	///< xs:string value="stopped"
/// @brief Job has ended with an error.
	fims__JobStatusType__failed,	///< xs:string value="failed"
/// @brief A cleanup command was issued for the job. All data related to the job has been removed.
	fims__JobStatusType__cleaned,	///< xs:string value="cleaned"
/// @brief Status for the job is unknown.
	fims__JobStatusType__unknown,	///< xs:string value="unknown"
};

/// "http://base.fims.tv":AudioSampleType is a simpleType restriction of xs:string.
/// @brief Audio sample representation: integer or floating point values.
/// Note: enum values are prefixed with 'fims__AudioSampleType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__AudioSampleType
{
/// @brief
	fims__AudioSampleType__float_,	///< xs:string value="float"
/// @brief
	fims__AudioSampleType__integer,	///< xs:string value="integer"
};

/// "http://base.fims.tv":ScanningFormatType is a simpleType restriction of xs:string.
/// @brief Scanning format representation: interlaced or progressive.
/// Note: enum values are prefixed with 'fims__ScanningFormatType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__ScanningFormatType
{
/// @brief
	fims__ScanningFormatType__interlaced,	///< xs:string value="interlaced"
/// @brief
	fims__ScanningFormatType__progressive,	///< xs:string value="progressive"
};

/// "http://base.fims.tv":ScanningOrderType is a simpleType restriction of xs:string.
/// @brief Scanning order representation: whether the fields are ordered top (upper) or bottom (lower) field first.
/// Note: enum values are prefixed with 'fims__ScanningOrderType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__ScanningOrderType
{
/// @brief
	fims__ScanningOrderType__top,	///< xs:string value="top"
/// @brief
	fims__ScanningOrderType__bottom,	///< xs:string value="bottom"
};

/// "http://base.fims.tv":BitRateModeType is a simpleType restriction of xs:string.
/// @brief Representation of type of bitrate: constant or variable.
/// Note: enum values are prefixed with 'fims__BitRateModeType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__BitRateModeType
{
/// @brief
	fims__BitRateModeType__constant,	///< xs:string value="constant"
/// @brief
	fims__BitRateModeType__variable,	///< xs:string value="variable"
};

/// "http://base.fims.tv":ErrorCodeType is a simpleType restriction of xs:string.
/// @brief Common error codes which can be shared by different classes of adapters. Error codes are classified in five main categories: INF_S00_xxxx: Infrastructure errors (system, storage, network, memory, processor) DAT_S00_xxxx: Data errors (validation, missing, duplication) SVC_S00_xxxx: Operation errors (existence, support, lock, connection, failure) SEC_S00_xxxx: Security errors (authentication, authorization) EXT_S00_xxxx: Extended code. See extended error code for detail.
/// Note: enum values are prefixed with 'fims__ErrorCodeType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__ErrorCodeType
{
/// @brief System unavailable.
	fims__ErrorCodeType__INF_USCORES00_USCORE0001,	///< xs:string value="INF_S00_0001"
/// @brief System timeout.
	fims__ErrorCodeType__INF_USCORES00_USCORE0002,	///< xs:string value="INF_S00_0002"
/// @brief System internal error.
	fims__ErrorCodeType__INF_USCORES00_USCORE0003,	///< xs:string value="INF_S00_0003"
/// @brief Unable to connect to the database.
	fims__ErrorCodeType__INF_USCORES00_USCORE0004,	///< xs:string value="INF_S00_0004"
/// @brief System out of memory.
	fims__ErrorCodeType__INF_USCORES00_USCORE0005,	///< xs:string value="INF_S00_0005"
/// @brief System out of disk space.
	fims__ErrorCodeType__INF_USCORES00_USCORE0006,	///< xs:string value="INF_S00_0006"
/// @brief Job Command is not currently supported by the service URI specified
	fims__ErrorCodeType__SVC_USCORES00_USCORE0001,	///< xs:string value="SVC_S00_0001"
/// @brief Queue Command is not currently supported by the service or the device.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0002,	///< xs:string value="SVC_S00_0002"
/// @brief Operation requested is not currently supported by the service or the device.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0003,	///< xs:string value="SVC_S00_0003"
/// @brief Service unable to find/lookup device endpoint.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0004,	///< xs:string value="SVC_S00_0004"
/// @brief Job command failed.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0005,	///< xs:string value="SVC_S00_0005"
/// @brief Queue command failed.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0006,	///< xs:string value="SVC_S00_0006"
/// @brief Service unable to connect to device endpoint
	fims__ErrorCodeType__SVC_USCORES00_USCORE0007,	///< xs:string value="SVC_S00_0007"
/// @brief Job queue is full, locked or stopped. No new jobs are being accepted.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0008,	///< xs:string value="SVC_S00_0008"
/// @brief Job ended with a failure.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0009,	///< xs:string value="SVC_S00_0009"
/// @brief Service received no response from device.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0010,	///< xs:string value="SVC_S00_0010"
/// @brief Service received an exception from device. See description or exception detail.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0011,	///< xs:string value="SVC_S00_0011"
/// @brief Service received an unknown or an internal error from device. See description for error detail.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0012,	///< xs:string value="SVC_S00_0012"
/// @brief Unable to connect to client's notification service endpoint (replyTo) to send the asynchronous job result notification response.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0013,	///< xs:string value="SVC_S00_0013"
/// @brief Unable to connect to client's service endpoint (faultTo) to send the asynchronous job fault response.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0014,	///< xs:string value="SVC_S00_0014"
/// @brief Feature not supported.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0015,	///< xs:string value="SVC_S00_0015"
/// @brief Deadline passed.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0016,	///< xs:string value="SVC_S00_0016"
/// @brief Time constraints in request cannot be met.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0017,	///< xs:string value="SVC_S00_0017"
/// @brief Internal or Unknown error encountered. See description for error detail.
	fims__ErrorCodeType__SVC_USCORES00_USCORE0018,	///< xs:string value="SVC_S00_0018"
/// @brief Invalid request, XML format.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0001,	///< xs:string value="DAT_S00_0001"
/// @brief Invalid input media format.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0002,	///< xs:string value="DAT_S00_0002"
/// @brief Invalid jobID - the supplied jobID does not exists.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0003,	///< xs:string value="DAT_S00_0003"
/// @brief Missing required service metadata in request.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0004,	///< xs:string value="DAT_S00_0004"
/// @brief Duplicate jobGUID detected for new job.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0005,	///< xs:string value="DAT_S00_0005"
/// @brief Invalid request parameters.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0006,	///< xs:string value="DAT_S00_0006"
/// @brief Job command not valid.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0007,	///< xs:string value="DAT_S00_0007"
/// @brief Queue command not valid.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0008,	///< xs:string value="DAT_S00_0008"
/// @brief Invalid priority.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0009,	///< xs:string value="DAT_S00_0009"
/// @brief Input media not found. Invalid resource URI specified.
	fims__ErrorCodeType__DAT_USCORES00_USCORE0010,	///< xs:string value="DAT_S00_0010"
/// @brief Extended code. See extended error code for details.
	fims__ErrorCodeType__EXT_USCORES00_USCORE0000,	///< xs:string value="EXT_S00_0000"
};

/// "http://base.fims.tv":JobInfoSelectionType is a simpleType restriction of xs:string.
/// @brief Whether to return only mandatory elements or all elements.
/// Note: enum values are prefixed with 'fims__JobInfoSelectionType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum fims__JobInfoSelectionType
{
/// @brief
	fims__JobInfoSelectionType__mandatory,	///< xs:string value="mandatory"
/// @brief
	fims__JobInfoSelectionType__all,	///< xs:string value="all"
};

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://description.fims.tv                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://description.fims.tv                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://description.fims.tv                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://temp/edlprovider                                                  *
 *                                                                            *
\******************************************************************************/


/// "http://temp/edlprovider":ArrayOfstring is a complexType.
/// class edlprovider__ArrayOfstring operations:
/// - soap_new_edlprovider__ArrayOfstring(soap*) allocate
/// - soap_new_edlprovider__ArrayOfstring(soap*, int num) allocate array
/// - soap_new_req_edlprovider__ArrayOfstring(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__ArrayOfstring(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__ArrayOfstring(soap*, edlprovider__ArrayOfstring*) deserialize from a stream
/// - int soap_write_edlprovider__ArrayOfstring(soap, edlprovider__ArrayOfstring*) serialize to a stream
class edlprovider__ArrayOfstring
{ public:
/// Vector of std::wstring with length 0..unbounded
    std::vector<std::wstring           > string                         0;	///< Nillable pointer.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://temp/edlprovider":ArrayOfClips is a complexType.
/// class edlprovider__ArrayOfClips operations:
/// - soap_new_edlprovider__ArrayOfClips(soap*) allocate
/// - soap_new_edlprovider__ArrayOfClips(soap*, int num) allocate array
/// - soap_new_req_edlprovider__ArrayOfClips(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__ArrayOfClips(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__ArrayOfClips(soap*, edlprovider__ArrayOfClips*) deserialize from a stream
/// - int soap_write_edlprovider__ArrayOfClips(soap, edlprovider__ArrayOfClips*) serialize to a stream
class edlprovider__ArrayOfClips
{ public:
/// Vector of edlprovider__ClipType* with length 0..unbounded
    std::vector<edlprovider__ClipType* > clips                          0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://temp/edlprovider":ClipType is a complexType.
/// class edlprovider__ClipType operations:
/// - soap_new_edlprovider__ClipType(soap*) allocate
/// - soap_new_edlprovider__ClipType(soap*, int num) allocate array
/// - soap_new_req_edlprovider__ClipType(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__ClipType(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__ClipType(soap*, edlprovider__ClipType*) deserialize from a stream
/// - int soap_write_edlprovider__ClipType(soap, edlprovider__ClipType*) serialize to a stream
class edlprovider__ClipType
{ public:
/// Element markIn of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      markIn                         1;	///< Required element.
/// Element markOut of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      markOut                        1;	///< Required element.
/// Element clipInfo of type "http://base.fims.tv":BMObjectType.
    fims__BMObjectType*                  clipInfo                       1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://temp/edlprovider":EdlCreateRequestBaseType is a complexType.
/// @brief Represents the request to create a edl for the specified type.
/// class edlprovider__EdlCreateRequestBaseType operations:
/// - soap_new_edlprovider__EdlCreateRequestBaseType(soap*) allocate
/// - soap_new_edlprovider__EdlCreateRequestBaseType(soap*, int num) allocate array
/// - soap_new_req_edlprovider__EdlCreateRequestBaseType(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__EdlCreateRequestBaseType(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__EdlCreateRequestBaseType(soap*, edlprovider__EdlCreateRequestBaseType*) deserialize from a stream
/// - int soap_write_edlprovider__EdlCreateRequestBaseType(soap, edlprovider__EdlCreateRequestBaseType*) serialize to a stream
class edlprovider__EdlCreateRequestBaseType
{ public:
/// @brief The edl type to generate, the types available can be obtained using getInstalledEdls.
/// Element edlType of type xs:string.
    std::wstring                         edlType                        1;	///< Required element.
/// @brief List of clips to include in the created EDL.
/// Element clips of type "http://temp/edlprovider":ArrayOfClips.
    edlprovider__ArrayOfClips*           clips                          0;	///< Nillable pointer.
/// @brief The EDL sequence name. This might mean something different in different EDL's.
/// Element edlSequenceName of type xs:string.
    std::wstring*                        edlSequenceName                0;	///< Nillable pointer.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://temp/edlprovider":EdlCreateResponseType is a complexType.
/// class edlprovider__EdlCreateResponseType operations:
/// - soap_new_edlprovider__EdlCreateResponseType(soap*) allocate
/// - soap_new_edlprovider__EdlCreateResponseType(soap*, int num) allocate array
/// - soap_new_req_edlprovider__EdlCreateResponseType(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__EdlCreateResponseType(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__EdlCreateResponseType(soap*, edlprovider__EdlCreateResponseType*) deserialize from a stream
/// - int soap_write_edlprovider__EdlCreateResponseType(soap, edlprovider__EdlCreateResponseType*) serialize to a stream
class edlprovider__EdlCreateResponseType
{ public:
/// Element getEdlResult of type xs:base64Binary.
    xsd__base64Binary*                   getEdlResult                   0;	///< Nillable pointer.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://base.fims.tv                                                      *
 *                                                                            *
\******************************************************************************/


/// "http://base.fims.tv":ExtensionGroup is a complexType.
/// @brief Each Type includes an ExtensionGroup to allow for vendor-specific extensions, but the definition is out of scope of the FIMS specification.
/// class fims__ExtensionGroup operations:
/// - soap_new_fims__ExtensionGroup(soap*) allocate
/// - soap_new_fims__ExtensionGroup(soap*, int num) allocate array
/// - soap_new_req_fims__ExtensionGroup(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ExtensionGroup(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ExtensionGroup(soap*, fims__ExtensionGroup*) deserialize from a stream
/// - int soap_write_fims__ExtensionGroup(soap, fims__ExtensionGroup*) serialize to a stream
class fims__ExtensionGroup
{ public:
/// TODO: <any namespace="##other" minOccurs="0" maxOccurs="unbounded">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
/// Size of the array of XML or DOM nodes is 0..unbounded
    std::vector<_XML                   > __any                         0;	///< Catch any element content in XML string.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ExtensionAttributes is a complexType.
/// @brief Each Type includes an ExtensionAttributes to allow for vendor-specific extensions, but the definition is out of scope of the FIMS specification.
/// class fims__ExtensionAttributes operations:
/// - soap_new_fims__ExtensionAttributes(soap*) allocate
/// - soap_new_fims__ExtensionAttributes(soap*, int num) allocate array
/// - soap_new_req_fims__ExtensionAttributes(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ExtensionAttributes(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ExtensionAttributes(soap*, fims__ExtensionAttributes*) deserialize from a stream
/// - int soap_write_fims__ExtensionAttributes(soap, fims__ExtensionAttributes*) serialize to a stream
class fims__ExtensionAttributes
{ public:
/// <anyAttribute namespace="##other">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this attribute.
///       Use wsdl2h option -d for xsd__anyAttribute DOM (soap_dom_attribute).
   @_XML                                 __anyAttribute                ;	///< A placeholder that has no effect: please see comment.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ResourceReferenceType is a complexType.
/// @brief The source or target of a reference to a distinct resource. Resources include queues, jobs, assets, descriptions, formats and profiles.
/// class fims__ResourceReferenceType operations:
/// - soap_new_fims__ResourceReferenceType(soap*) allocate
/// - soap_new_fims__ResourceReferenceType(soap*, int num) allocate array
/// - soap_new_req_fims__ResourceReferenceType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ResourceReferenceType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ResourceReferenceType(soap*, fims__ResourceReferenceType*) deserialize from a stream
/// - int soap_write_fims__ResourceReferenceType(soap, fims__ResourceReferenceType*) serialize to a stream
class fims__ResourceReferenceType
{ public:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":AsyncEndpointType is a complexType.
/// @brief Provides endpoints where a service can send back a notification for a job completed or failed.
/// class fims__AsyncEndpointType operations:
/// - soap_new_fims__AsyncEndpointType(soap*) allocate
/// - soap_new_fims__AsyncEndpointType(soap*, int num) allocate array
/// - soap_new_req_fims__AsyncEndpointType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__AsyncEndpointType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__AsyncEndpointType(soap*, fims__AsyncEndpointType*) deserialize from a stream
/// - int soap_write_fims__AsyncEndpointType(soap, fims__AsyncEndpointType*) serialize to a stream
class fims__AsyncEndpointType
{ public:
/// @brief Endpoint where the service sends notifications indicating the successful termination or cancellation of a job. Depending on the invoking client or business process, the endpoint for "faultTo" can be the same as the "replyTo" or it can be different.
/// Element replyTo of type xs:anyURI.
    xsd__anyURI                          replyTo                        1;	///< Required element.
/// @brief Endpoint where the service sends the fault notification indicating the failure of a job. Depending on the invoking client or business process, the endpoint for "faultTo" can be the same as the "replyTo" or it can be different.
/// Element faultTo of type xs:anyURI.
    xsd__anyURI                          faultTo                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":AncillaryDataFormatType is a complexType.
/// @brief Ancillary data packet type. See SMPTE ST 291 and SMPTE ST 436.
/// class fims__AncillaryDataFormatType operations:
/// - soap_new_fims__AncillaryDataFormatType(soap*) allocate
/// - soap_new_fims__AncillaryDataFormatType(soap*, int num) allocate array
/// - soap_new_req_fims__AncillaryDataFormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__AncillaryDataFormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__AncillaryDataFormatType(soap*, fims__AncillaryDataFormatType*) deserialize from a stream
/// - int soap_write_fims__AncillaryDataFormatType(soap, fims__AncillaryDataFormatType*) serialize to a stream
class fims__AncillaryDataFormatType
{ public:
/// @brief ANC DID value.
/// Element DID of type xs:integer.
    xsd__integer*                        DID                            0;	///< Optional element.
/// @brief ANC SDID value.
/// Element SDID of type xs:integer.
    xsd__integer*                        SDID                           0;	///< Optional element.
/// @brief Video line number containing the ANC packets of this type.
/// Element lineNumber of type xs:integer.
    xsd__integer*                        lineNumber                     0;	///< Optional element.
/// @brief Indicates HANC or VANC, and what field in which packets should be stored. See SMPTE ST 436 for legal values.
/// Element wrappingType of type xs:integer.
    xsd__integer*                        wrappingType                   0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":BMTrackType is a complexType.
/// @brief Tracks expose the underlying structural metadata of the content streams embedded inside a physical content essence. Examples of tracks are the separate audio and video streams inside an audiovisual content essence. Tracks have a category, for example "main" (videoTrack), "audioDescription" (audioTrack), "closed captioning" (dataTrack). Tracks have also an identifier and a description.
/// class fims__BMTrackType operations:
/// - soap_new_fims__BMTrackType(soap*) allocate
/// - soap_new_fims__BMTrackType(soap*, int num) allocate array
/// - soap_new_req_fims__BMTrackType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMTrackType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMTrackType(soap*, fims__BMTrackType*) deserialize from a stream
/// - int soap_write_fims__BMTrackType(soap, fims__BMTrackType*) serialize to a stream
class fims__BMTrackType
{ public:
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// @brief Identifier of the track.
/// Attribute trackID of type "http://base.fims.tv":UID.
   @fims__UID*                           trackID                        0;	///< Optional attribute.
/// @brief Name for the track.
/// Attribute trackName of type xs:string.
   @std::wstring*                        trackName                      0;	///< Optional attribute.
/// @brief Language of the track, such as the primary spoken language for an audio track.
/// Attribute language of type xs:language.
   @xsd__language*                       language                       0;	///< Optional attribute.
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":CodecType is a complexType.
/// @brief Describes a codec used for video or audio encoding.
/// class fims__CodecType operations:
/// - soap_new_fims__CodecType(soap*) allocate
/// - soap_new_fims__CodecType(soap*, int num) allocate array
/// - soap_new_req_fims__CodecType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__CodecType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__CodecType(soap*, fims__CodecType*) deserialize from a stream
/// - int soap_write_fims__CodecType(soap, fims__CodecType*) serialize to a stream
class fims__CodecType
{ public:
/// @brief Name of the hardware or software codec.
/// Element name of type xs:string.
    std::wstring*                        name                           0;	///< Optional element.
/// @brief The vendor/organization that produced the codec.
/// Element vendor of type xs:string.
    std::wstring*                        vendor                         0;	///< Optional element.
/// @brief Version of the specific release of the codec.
/// Element version of type xs:string.
    std::wstring*                        version                        0;	///< Optional element.
/// @brief Codec family, e.g. MPEG-2, H.264 etc.
/// Element family of type xs:string.
    std::wstring*                        family                         0;	///< Optional element.
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":TransferAtomType is a complexType.
/// @brief Parameters specific to transfer media services that can be re-used for other services. Note: Some parameters might be added to the atom in future version to specify network resource utilization, a list of acceptable transfer mechanisms or additional security options including whether the received files should be checked against a fingerprint and whether they are encrypted.
/// class fims__TransferAtomType operations:
/// - soap_new_fims__TransferAtomType(soap*) allocate
/// - soap_new_fims__TransferAtomType(soap*, int num) allocate array
/// - soap_new_req_fims__TransferAtomType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__TransferAtomType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__TransferAtomType(soap*, fims__TransferAtomType*) deserialize from a stream
/// - int soap_write_fims__TransferAtomType(soap, fims__TransferAtomType*) serialize to a stream
class fims__TransferAtomType
{ public:
/// @brief Destination path for the target.
/// Element destination of type xs:anyURI.
    xsd__anyURI                          destination                    1;	///< Required element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":TransformAtomType is a complexType.
/// @brief Parameters specific to the transform media service that can be re-used by other services. Note: Some parameters might be added to this type in future version of this specification to specify AV Process, etc.
/// class fims__TransformAtomType operations:
/// - soap_new_fims__TransformAtomType(soap*) allocate
/// - soap_new_fims__TransformAtomType(soap*, int num) allocate array
/// - soap_new_req_fims__TransformAtomType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__TransformAtomType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__TransformAtomType(soap*, fims__TransformAtomType*) deserialize from a stream
/// - int soap_write_fims__TransformAtomType(soap, fims__TransformAtomType*) serialize to a stream
class fims__TransformAtomType
{ public:
/// @brief Specifies the output video format. See 'videoFormat' in EBU tech 3293 for more information.
/// Element videoFormat of type "http://base.fims.tv":VideoFormatType.
    fims__VideoFormatType*               videoFormat                    0;	///< Optional element.
/// @brief Specifies the output audio format. See 'audioFormat' in EBU tech 3293 for more information.
/// Element audioFormat of type "http://base.fims.tv":AudioFormatType.
    fims__AudioFormatType*               audioFormat                    0;	///< Optional element.
/// @brief Container/wrapper format of the output file. See "fileFormat" in EBU tech 3293 for more information.
/// Element containerFormat of type "http://base.fims.tv":ContainerFormatType.
    fims__ContainerFormatType*           containerFormat                0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":HashType is a complexType.
/// @brief Provides information on the algorithm used in an integrity check process. It is based on the 'hash' type defined in SMPTE ST 2032.
/// class fims__HashType operations:
/// - soap_new_fims__HashType(soap*) allocate
/// - soap_new_fims__HashType(soap*, int num) allocate array
/// - soap_new_req_fims__HashType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__HashType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__HashType(soap*, fims__HashType*) deserialize from a stream
/// - int soap_write_fims__HashType(soap, fims__HashType*) serialize to a stream
class fims__HashType
{ public:
/// @brief The hash function used to hash the content (e.g. CRC32).
/// Element hashFunction of type "http://base.fims.tv":HashFunctionType.
    fims__HashFunctionType*              hashFunction                   1;	///< Required element.
/// @brief Hash (digest) value as a hexadecimal string.
/// Element value of type xs:hexBinary.
    xsd__hexBinary                       value                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ProcessedInfoType is an abstract complexType.
/// @brief Statistics on the amount of information processed so far. For example in terms of bytes or frames processed.
/// class fims__ProcessedInfoType operations:
/// - soap_new_fims__ProcessedInfoType(soap*) allocate
/// - soap_new_fims__ProcessedInfoType(soap*, int num) allocate array
/// - soap_new_req_fims__ProcessedInfoType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ProcessedInfoType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ProcessedInfoType(soap*, fims__ProcessedInfoType*) deserialize from a stream
/// - int soap_write_fims__ProcessedInfoType(soap, fims__ProcessedInfoType*) serialize to a stream
class fims__ProcessedInfoType
{ public:
/// @brief The percentage of job completed. The percentage can be based on one of two metrics: number of bytes processed, or number of frames processed (e.g. for transcoding video files). If the "processedBytesCount" metric is provided, then the percentage is based on number of bytes processed. If the "processedFramesCount" metric is provided, then the percentage is based on the number of processed frames.
/// Value range is [0..100]
    xsd__nonNegativeInteger                                            
                                         percentageProcessedCompleted   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":DurationType is a complexType.
/// @brief Measure of the duration of an operation or item of content.
/// class fims__DurationType operations:
/// - soap_new_fims__DurationType(soap*) allocate
/// - soap_new_fims__DurationType(soap*, int num) allocate array
/// - soap_new_req_fims__DurationType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__DurationType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__DurationType(soap*, fims__DurationType*) deserialize from a stream
/// - int soap_write_fims__DurationType(soap, fims__DurationType*) serialize to a stream
class fims__DurationType
{ public:
/// CHOICE <xs:choice>
   $int                                  __union_DurationType          ;	///< Union _fims__union_DurationType selector: set to SOAP_UNION__fims__union_DurationType_<fieldname>
/// Union for choice in type fims__DurationType
    union _fims__union_DurationType
    {
/// @brief Duration of AV content in a timecode-like format (e.g. SMPTE ST 12-1) as defined in EBU Tech 3293.
/// Element timecode of type "http://base.fims.tv":TimecodeDuration.
    fims__TimecodeDuration*              timecode                       1;	///< Required element.
/// @brief A duration expressed using usual time representation as in RFC 2326 and ISO 8601 (e.g.:PT1H31M25.152S)
/// Element normalPlayTime of type xs:duration.
    xsd__duration*                       normalPlayTime                 1;	///< Required element.
/// @brief A duration expressed as a number of edit units, as defined in EBU Tech 3293.
/// Element editUnitNumber of type "http://base.fims.tv":EditUnitNumberType.
    fims__EditUnitNumberType*            editUnitNumber                 1;	///< Required element.
    }                                    union_DurationType            ;
//  END OF CHOICE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":TimeType is a complexType.
/// @brief Value used to represent a point in time, such as at what time to start an operation.
/// class fims__TimeType operations:
/// - soap_new_fims__TimeType(soap*) allocate
/// - soap_new_fims__TimeType(soap*, int num) allocate array
/// - soap_new_req_fims__TimeType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__TimeType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__TimeType(soap*, fims__TimeType*) deserialize from a stream
/// - int soap_write_fims__TimeType(soap, fims__TimeType*) serialize to a stream
class fims__TimeType
{ public:
/// CHOICE <xs:choice>
   $int                                  __union_TimeType              ;	///< Union _fims__union_TimeType selector: set to SOAP_UNION__fims__union_TimeType_<fieldname>
/// Union for choice in type fims__TimeType
    union _fims__union_TimeType
    {
/// @brief Start time expressed using timecode values compliant with SMPTE ST 12-1.
/// Element timecode of type "http://base.fims.tv":Timecode.
    fims__Timecode*                      timecode                       1;	///< Required element.
/// @brief Start time expressed by time of day in the format hh:mm:ss.sss with an optional following time zone indicator.
/// Element normalPlayTime of type xs:time.
    xsd__time*                           normalPlayTime                 1;	///< Required element.
/// @brief Start time expressed as a number of edit units.
/// Element editUnitNumber of type "http://base.fims.tv":EditUnitNumberType.
    fims__EditUnitNumberType*            editUnitNumber                 1;	///< Required element.
    }                                    union_TimeType                ;
//  END OF CHOICE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":StartProcessType is an abstract complexType.
/// @brief Kinds of time, time code, or event based information used to start a real-time process such as a capture process.
/// class fims__StartProcessType operations:
/// - soap_new_fims__StartProcessType(soap*) allocate
/// - soap_new_fims__StartProcessType(soap*, int num) allocate array
/// - soap_new_req_fims__StartProcessType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartProcessType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartProcessType(soap*, fims__StartProcessType*) deserialize from a stream
/// - int soap_write_fims__StartProcessType(soap, fims__StartProcessType*) serialize to a stream
class fims__StartProcessType
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":StopProcessType is an abstract complexType.
/// @brief Kind of time, time code, or event information used to stop a real-time process, such as a capture process.
/// class fims__StopProcessType operations:
/// - soap_new_fims__StopProcessType(soap*) allocate
/// - soap_new_fims__StopProcessType(soap*, int num) allocate array
/// - soap_new_req_fims__StopProcessType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StopProcessType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StopProcessType(soap*, fims__StopProcessType*) deserialize from a stream
/// - int soap_write_fims__StopProcessType(soap, fims__StopProcessType*) serialize to a stream
class fims__StopProcessType
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":StartJobType is an abstract complexType.
/// @brief Kinds of time when a job is required to start.
/// class fims__StartJobType operations:
/// - soap_new_fims__StartJobType(soap*) allocate
/// - soap_new_fims__StartJobType(soap*, int num) allocate array
/// - soap_new_req_fims__StartJobType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartJobType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartJobType(soap*, fims__StartJobType*) deserialize from a stream
/// - int soap_write_fims__StartJobType(soap, fims__StartJobType*) serialize to a stream
class fims__StartJobType
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ManageJobRequestType is a complexType.
/// @brief FIMS service common mechanism to manage jobs and update jobs properties, including job priority. The manage job request uses the jobCommand to set the intent of the command (acting on the job state).
/// class fims__ManageJobRequestType operations:
/// - soap_new_fims__ManageJobRequestType(soap*) allocate
/// - soap_new_fims__ManageJobRequestType(soap*, int num) allocate array
/// - soap_new_req_fims__ManageJobRequestType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ManageJobRequestType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ManageJobRequestType(soap*, fims__ManageJobRequestType*) deserialize from a stream
/// - int soap_write_fims__ManageJobRequestType(soap, fims__ManageJobRequestType*) serialize to a stream
class fims__ManageJobRequestType
{ public:
/// @brief Resource identifier of the job to be managed.
/// Element jobID of type "http://base.fims.tv":UID.
    fims__UID                            jobID                          1;	///< Required element.
/// @brief Action to perform on the job.
/// Element jobCommand of type "http://base.fims.tv":JobCommandType.
    enum fims__JobCommandType            jobCommand                     1;	///< Required element.
/// @brief New priority for the job.
/// Element priority of type "http://base.fims.tv":PriorityType.
    enum fims__PriorityType*             priority                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ManageJobResponseType is a complexType.
/// @brief This type provides job status as a response to a job management request (e.g. pausing a job).
/// class fims__ManageJobResponseType operations:
/// - soap_new_fims__ManageJobResponseType(soap*) allocate
/// - soap_new_fims__ManageJobResponseType(soap*, int num) allocate array
/// - soap_new_req_fims__ManageJobResponseType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ManageJobResponseType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ManageJobResponseType(soap*, fims__ManageJobResponseType*) deserialize from a stream
/// - int soap_write_fims__ManageJobResponseType(soap, fims__ManageJobResponseType*) serialize to a stream
class fims__ManageJobResponseType
{ public:
/// @brief Job status as a response to a job management request.
/// Element reference "http://base.fims.tv":job.
    fims__JobType*                       job                            1;	///< Required element.
/// @brief Extension point
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ManageQueueRequestType is a complexType.
/// @brief This type provides a mechanism to manage a queue, for example checking the status of the queue, stopping and starting the queue and locking the queue. The queue management request uses the queueCommand to set the intent of the command (requesting status or acting on the queue state).
/// class fims__ManageQueueRequestType operations:
/// - soap_new_fims__ManageQueueRequestType(soap*) allocate
/// - soap_new_fims__ManageQueueRequestType(soap*, int num) allocate array
/// - soap_new_req_fims__ManageQueueRequestType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ManageQueueRequestType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ManageQueueRequestType(soap*, fims__ManageQueueRequestType*) deserialize from a stream
/// - int soap_write_fims__ManageQueueRequestType(soap, fims__ManageQueueRequestType*) serialize to a stream
class fims__ManageQueueRequestType
{ public:
/// @brief Identifier for the queue, required for services with more than one queue. Note: FIMS 1.0 does not allow more than one queue per service.
/// Element queueID of type "http://base.fims.tv":UID.
    fims__UID*                           queueID                        0;	///< Optional element.
/// @brief This element specifies the intent of the command. Possible values for the command are listed in QueueCommandType.
/// Element queueCommand of type "http://base.fims.tv":QueueCommandType.
    enum fims__QueueCommandType          queueCommand                   1;	///< Required element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ManageQueueResponseType is a complexType.
/// @brief This type represents a response to a queue management request. It provides information such as the status and the length of queue.
/// class fims__ManageQueueResponseType operations:
/// - soap_new_fims__ManageQueueResponseType(soap*) allocate
/// - soap_new_fims__ManageQueueResponseType(soap*, int num) allocate array
/// - soap_new_req_fims__ManageQueueResponseType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ManageQueueResponseType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ManageQueueResponseType(soap*, fims__ManageQueueResponseType*) deserialize from a stream
/// - int soap_write_fims__ManageQueueResponseType(soap, fims__ManageQueueResponseType*) serialize to a stream
class fims__ManageQueueResponseType
{ public:
/// @brief Queue information such as the status and the length of queue.
/// Element reference "http://base.fims.tv":queue.
    fims__QueueType*                     queue                          1;	///< Required element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":QueryJobRequestType is an abstract complexType.
/// @brief This is an abstract type to be extended to create types to request status of multiple identified jobs or to list the status of jobs that meet requirements specified by a filter object.
/// class fims__QueryJobRequestType operations:
/// - soap_new_fims__QueryJobRequestType(soap*) allocate
/// - soap_new_fims__QueryJobRequestType(soap*, int num) allocate array
/// - soap_new_req_fims__QueryJobRequestType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueryJobRequestType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueryJobRequestType(soap*, fims__QueryJobRequestType*) deserialize from a stream
/// - int soap_write_fims__QueryJobRequestType(soap, fims__QueryJobRequestType*) serialize to a stream
class fims__QueryJobRequestType
{ public:
/// @brief Level of status details to be returned for the jobs.
/// Element jobInfoSelection of type "http://base.fims.tv":JobInfoSelectionType.
    enum fims__JobInfoSelectionType      jobInfoSelection               1;	///< Required element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":QueryJobResponseType is a complexType.
/// @brief This type provides a response to QueryJobRequestType. It contains a list of queryJobInfo elements. Furthermore, the response message provided by this type supports a polling interaction pattern for retrieving the status and the response of an asynchronous job request.
/// class fims__QueryJobResponseType operations:
/// - soap_new_fims__QueryJobResponseType(soap*) allocate
/// - soap_new_fims__QueryJobResponseType(soap*, int num) allocate array
/// - soap_new_req_fims__QueryJobResponseType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueryJobResponseType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueryJobResponseType(soap*, fims__QueryJobResponseType*) deserialize from a stream
/// - int soap_write_fims__QueryJobResponseType(soap, fims__QueryJobResponseType*) serialize to a stream
class fims__QueryJobResponseType
{ public:
/// @brief List of jobs matching the query parameters.
/// Element jobs of type "http://base.fims.tv":JobsType.
    fims__JobsType*                      jobs                           0;	///< Optional element.
/// @brief This optional element indicates the number of results that were not reported due to the restriction imposed by the maximum number of results specified in the request.
/// Element notReportedResultsNumber of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             notReportedResultsNumber       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":QueryServiceDescriptionRequestType is a complexType.
/// @brief Provides a mechanism to query Service Description.
/// class fims__QueryServiceDescriptionRequestType operations:
/// - soap_new_fims__QueryServiceDescriptionRequestType(soap*) allocate
/// - soap_new_fims__QueryServiceDescriptionRequestType(soap*, int num) allocate array
/// - soap_new_req_fims__QueryServiceDescriptionRequestType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueryServiceDescriptionRequestType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueryServiceDescriptionRequestType(soap*, fims__QueryServiceDescriptionRequestType*) deserialize from a stream
/// - int soap_write_fims__QueryServiceDescriptionRequestType(soap, fims__QueryServiceDescriptionRequestType*) serialize to a stream
class fims__QueryServiceDescriptionRequestType
{ public:
/// @brief Whether the response is required as an embedded description or as a reference.
@    enum _fims__QueryServiceDescriptionRequestType_responseType
    {
/// @brief Response is required as a reference to the Service Description.
	_fims__QueryServiceDescriptionRequestType_responseType__ref,	///< xs:string value="ref"
/// @brief Response is required as an embedded value with the complete Service Description.
	_fims__QueryServiceDescriptionRequestType_responseType__value,	///< xs:string value="value"
    }
                                         responseType                   0 = _fims__QueryServiceDescriptionRequestType_responseType__value;	///< Default value="value".
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":QueryServiceDescriptionResponseType is a complexType.
/// @brief Response to the Service Description query.
/// class fims__QueryServiceDescriptionResponseType operations:
/// - soap_new_fims__QueryServiceDescriptionResponseType(soap*) allocate
/// - soap_new_fims__QueryServiceDescriptionResponseType(soap*, int num) allocate array
/// - soap_new_req_fims__QueryServiceDescriptionResponseType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueryServiceDescriptionResponseType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueryServiceDescriptionResponseType(soap*, fims__QueryServiceDescriptionResponseType*) deserialize from a stream
/// - int soap_write_fims__QueryServiceDescriptionResponseType(soap, fims__QueryServiceDescriptionResponseType*) serialize to a stream
class fims__QueryServiceDescriptionResponseType
{ public:
/// @brief Service Description, embedded or by reference.
/// Element service of type "http://base.fims.tv":ServiceType.
    fims__ServiceType*                   service                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ListFilterType is a complexType.
/// @brief Specifies a list of jobs to be retrieved. The list includes only jobs that fall in the period of time specified (if provided) and in the specified category (queued, active, completed, failed).
/// class fims__ListFilterType operations:
/// - soap_new_fims__ListFilterType(soap*) allocate
/// - soap_new_fims__ListFilterType(soap*, int num) allocate array
/// - soap_new_req_fims__ListFilterType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ListFilterType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ListFilterType(soap*, fims__ListFilterType*) deserialize from a stream
/// - int soap_write_fims__ListFilterType(soap, fims__ListFilterType*) serialize to a stream
class fims__ListFilterType
{ public:
/// @brief A 'from' date filter. If this element is not specified, the list includes jobs that started at any point in time (that still complies with the 'toDatte' field).
/// Element fromDate of type xs:dateTime.
    time_t*                              fromDate                       0;	///< Optional element.
/// @brief A 'to' date filter. If this element is not specified, the list includes jobs that started at any point in time (that still complies with the 'fromDatte' field).
/// Element toDate of type xs:dateTime.
    time_t*                              toDate                         0;	///< Optional element.
/// @brief A flag to indicate job or jobs in the queue.
/// Element includeQueued of type xs:boolean.
    bool                                 includeQueued                  1;	///< Required element.
/// @brief A flag to indicate job or jobs in the 'Running', 'Paused' or 'Unknown' state.
/// Element includeActive of type xs:boolean.
    bool                                 includeActive                  1;	///< Required element.
/// @brief A flag to indicate job or jobs in the 'Completed', 'Stopped' or 'Cleaned' state.
/// Element includeFinished of type xs:boolean.
    bool                                 includeFinished                1;	///< Required element.
/// @brief A flag to indicate job or jobs in the 'Failed' state.
/// Element includeFailed of type xs:boolean.
    bool                                 includeFailed                  1;	///< Required element.
/// @brief Maximum number of results to be listed.
/// Element maxNumberResults of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             maxNumberResults               0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":FaultType is a complexType.
/// @brief Details of a fault. This type can be extended by each service to provide additional error codes.
/// class fims__FaultType operations:
/// - soap_new_fims__FaultType(soap*) allocate
/// - soap_new_fims__FaultType(soap*, int num) allocate array
/// - soap_new_req_fims__FaultType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__FaultType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__FaultType(soap*, fims__FaultType*) deserialize from a stream
/// - int soap_write_fims__FaultType(soap, fims__FaultType*) serialize to a stream
class fims__FaultType
{ public:
/// @brief The error code specified in ErrorCodeType.
/// Element code of type "http://base.fims.tv":ErrorCodeType.
    enum fims__ErrorCodeType             code                           1;	///< Required element.
/// @brief An optional description of the error.
/// Element description of type xs:string.
    std::wstring*                        description                    0;	///< Optional element.
/// @brief This optional field can provide a detailed description of the error.
/// Element detail of type xs:string.
    std::wstring*                        detail                         0;	///< Optional element.
/// @brief Additional description of the lower-level errors.
/// Vector of fims__InnerFaultType* with length 0..unbounded
    std::vector<fims__InnerFaultType*  > innerFault                     0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":InnerFaultType is a complexType.
/// @brief Additional description of the lower-level errors.
/// class fims__InnerFaultType operations:
/// - soap_new_fims__InnerFaultType(soap*) allocate
/// - soap_new_fims__InnerFaultType(soap*, int num) allocate array
/// - soap_new_req_fims__InnerFaultType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__InnerFaultType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__InnerFaultType(soap*, fims__InnerFaultType*) deserialize from a stream
/// - int soap_write_fims__InnerFaultType(soap, fims__InnerFaultType*) serialize to a stream
class fims__InnerFaultType
{ public:
/// @brief Lower-level error code. This can be any value that is relevant to the appropriate subsystem
/// Element code of type xs:string.
    std::wstring                         code                           1;	///< Required element.
/// @brief Description of lower-level error code.
/// Element description of type xs:string.
    std::wstring*                        description                    0;	///< Optional element.
/// @brief This optional field can provide a detailed description of the lower-level error.
/// Element detail of type xs:string.
    std::wstring*                        detail                         0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ResourcesType is a complexType.
/// class fims__ResourcesType operations:
/// - soap_new_fims__ResourcesType(soap*) allocate
/// - soap_new_fims__ResourcesType(soap*, int num) allocate array
/// - soap_new_req_fims__ResourcesType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ResourcesType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ResourcesType(soap*, fims__ResourcesType*) deserialize from a stream
/// - int soap_write_fims__ResourcesType(soap, fims__ResourcesType*) serialize to a stream
class fims__ResourcesType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__ResourcesType_sequence
    {
/// Element reference "http://base.fims.tv":resource.
    fims__ResourceType*                  resource                       1;	///< Required element.
    }>                                   __ResourcesType_sequence       1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ProfilesType is a complexType.
/// class fims__ProfilesType operations:
/// - soap_new_fims__ProfilesType(soap*) allocate
/// - soap_new_fims__ProfilesType(soap*, int num) allocate array
/// - soap_new_req_fims__ProfilesType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ProfilesType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ProfilesType(soap*, fims__ProfilesType*) deserialize from a stream
/// - int soap_write_fims__ProfilesType(soap, fims__ProfilesType*) serialize to a stream
class fims__ProfilesType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__ProfilesType_sequence
    {
/// Element reference "http://base.fims.tv":profile.
    fims__ProfileType*                   profile                        1;	///< Required element.
    }>                                   __ProfilesType_sequence        1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ServicesType is a complexType.
/// class fims__ServicesType operations:
/// - soap_new_fims__ServicesType(soap*) allocate
/// - soap_new_fims__ServicesType(soap*, int num) allocate array
/// - soap_new_req_fims__ServicesType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ServicesType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ServicesType(soap*, fims__ServicesType*) deserialize from a stream
/// - int soap_write_fims__ServicesType(soap, fims__ServicesType*) serialize to a stream
class fims__ServicesType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__ServicesType_sequence
    {
/// Element reference "http://base.fims.tv":service.
    fims__ServiceType*                   service                        1;	///< Required element.
    }>                                   __ServicesType_sequence        1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":QueuesType is a complexType.
/// class fims__QueuesType operations:
/// - soap_new_fims__QueuesType(soap*) allocate
/// - soap_new_fims__QueuesType(soap*, int num) allocate array
/// - soap_new_req_fims__QueuesType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueuesType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueuesType(soap*, fims__QueuesType*) deserialize from a stream
/// - int soap_write_fims__QueuesType(soap, fims__QueuesType*) serialize to a stream
class fims__QueuesType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__QueuesType_sequence
    {
/// Element reference "http://base.fims.tv":queue.
    fims__QueueType*                     queue                          1;	///< Required element.
    }>                                   __QueuesType_sequence          1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":JobsType is a complexType.
/// class fims__JobsType operations:
/// - soap_new_fims__JobsType(soap*) allocate
/// - soap_new_fims__JobsType(soap*, int num) allocate array
/// - soap_new_req_fims__JobsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__JobsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__JobsType(soap*, fims__JobsType*) deserialize from a stream
/// - int soap_write_fims__JobsType(soap, fims__JobsType*) serialize to a stream
class fims__JobsType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__JobsType_sequence
    {
/// Element reference "http://base.fims.tv":job.
    fims__JobType*                       job                            1;	///< Required element.
    }>                                   __JobsType_sequence            1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":VideoFormatsType is a complexType.
/// class fims__VideoFormatsType operations:
/// - soap_new_fims__VideoFormatsType(soap*) allocate
/// - soap_new_fims__VideoFormatsType(soap*, int num) allocate array
/// - soap_new_req_fims__VideoFormatsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__VideoFormatsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__VideoFormatsType(soap*, fims__VideoFormatsType*) deserialize from a stream
/// - int soap_write_fims__VideoFormatsType(soap, fims__VideoFormatsType*) serialize to a stream
class fims__VideoFormatsType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__VideoFormatsType_sequence
    {
/// Element reference "http://base.fims.tv":videoFormat.
    fims__VideoFormatType*               videoFormat                    1;	///< Required element.
    }>                                   __VideoFormatsType_sequence    1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":AudioFormatsType is a complexType.
/// class fims__AudioFormatsType operations:
/// - soap_new_fims__AudioFormatsType(soap*) allocate
/// - soap_new_fims__AudioFormatsType(soap*, int num) allocate array
/// - soap_new_req_fims__AudioFormatsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__AudioFormatsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__AudioFormatsType(soap*, fims__AudioFormatsType*) deserialize from a stream
/// - int soap_write_fims__AudioFormatsType(soap, fims__AudioFormatsType*) serialize to a stream
class fims__AudioFormatsType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__AudioFormatsType_sequence
    {
/// Element reference "http://base.fims.tv":audioFormat.
    fims__AudioFormatType*               audioFormat                    1;	///< Required element.
    }>                                   __AudioFormatsType_sequence    1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ContainerFormatsType is a complexType.
/// class fims__ContainerFormatsType operations:
/// - soap_new_fims__ContainerFormatsType(soap*) allocate
/// - soap_new_fims__ContainerFormatsType(soap*, int num) allocate array
/// - soap_new_req_fims__ContainerFormatsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ContainerFormatsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ContainerFormatsType(soap*, fims__ContainerFormatsType*) deserialize from a stream
/// - int soap_write_fims__ContainerFormatsType(soap, fims__ContainerFormatsType*) serialize to a stream
class fims__ContainerFormatsType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__ContainerFormatsType_sequence
    {
/// Element reference "http://base.fims.tv":containerFormat.
    fims__ContainerFormatType*           containerFormat                1;	///< Required element.
    }>                                   __ContainerFormatsType_sequence 1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":DataFormatsType is a complexType.
/// class fims__DataFormatsType operations:
/// - soap_new_fims__DataFormatsType(soap*) allocate
/// - soap_new_fims__DataFormatsType(soap*, int num) allocate array
/// - soap_new_req_fims__DataFormatsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__DataFormatsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__DataFormatsType(soap*, fims__DataFormatsType*) deserialize from a stream
/// - int soap_write_fims__DataFormatsType(soap, fims__DataFormatsType*) serialize to a stream
class fims__DataFormatsType
{ public:
/// SEQUENCE <xs:sequence minOccurs="1" maxOccurs="unbounded">
    std::vector<                                                       
    class __fims__DataFormatsType_sequence
    {
/// Element reference "http://base.fims.tv":dataFormat.
    fims__DataFormatType*                dataFormat                     1;	///< Required element.
    }>                                   __DataFormatsType_sequence     1;
//  END OF SEQUENCE
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":BMObjectsType is a complexType.
/// class fims__BMObjectsType operations:
/// - soap_new_fims__BMObjectsType(soap*) allocate
/// - soap_new_fims__BMObjectsType(soap*, int num) allocate array
/// - soap_new_req_fims__BMObjectsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMObjectsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMObjectsType(soap*, fims__BMObjectsType*) deserialize from a stream
/// - int soap_write_fims__BMObjectsType(soap, fims__BMObjectsType*) serialize to a stream
class fims__BMObjectsType
{ public:
/// Vector of fims__BMObjectType* element refs with length 1..unbounded
    std::vector<fims__BMObjectType*    > bmObject                       1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":BMContentsType is a complexType.
/// class fims__BMContentsType operations:
/// - soap_new_fims__BMContentsType(soap*) allocate
/// - soap_new_fims__BMContentsType(soap*, int num) allocate array
/// - soap_new_req_fims__BMContentsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMContentsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMContentsType(soap*, fims__BMContentsType*) deserialize from a stream
/// - int soap_write_fims__BMContentsType(soap, fims__BMContentsType*) serialize to a stream
class fims__BMContentsType
{ public:
/// Vector of fims__BMContentType* element refs with length 1..unbounded
    std::vector<fims__BMContentType*   > bmContent                      1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":BMContentFormatsType is a complexType.
/// class fims__BMContentFormatsType operations:
/// - soap_new_fims__BMContentFormatsType(soap*) allocate
/// - soap_new_fims__BMContentFormatsType(soap*, int num) allocate array
/// - soap_new_req_fims__BMContentFormatsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMContentFormatsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMContentFormatsType(soap*, fims__BMContentFormatsType*) deserialize from a stream
/// - int soap_write_fims__BMContentFormatsType(soap, fims__BMContentFormatsType*) serialize to a stream
class fims__BMContentFormatsType
{ public:
/// Vector of fims__BMContentFormatType* element refs with length 1..unbounded
    std::vector<fims__BMContentFormatType*> bmContentFormat                1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":BMEssenceLocatorsType is a complexType.
/// class fims__BMEssenceLocatorsType operations:
/// - soap_new_fims__BMEssenceLocatorsType(soap*) allocate
/// - soap_new_fims__BMEssenceLocatorsType(soap*, int num) allocate array
/// - soap_new_req_fims__BMEssenceLocatorsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMEssenceLocatorsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMEssenceLocatorsType(soap*, fims__BMEssenceLocatorsType*) deserialize from a stream
/// - int soap_write_fims__BMEssenceLocatorsType(soap, fims__BMEssenceLocatorsType*) serialize to a stream
class fims__BMEssenceLocatorsType
{ public:
/// Vector of fims__BMEssenceLocatorType* element refs with length 1..unbounded
    std::vector<fims__BMEssenceLocatorType*> bmEssenceLocator               1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":DescriptionsType is a complexType.
/// class fims__DescriptionsType operations:
/// - soap_new_fims__DescriptionsType(soap*) allocate
/// - soap_new_fims__DescriptionsType(soap*, int num) allocate array
/// - soap_new_req_fims__DescriptionsType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__DescriptionsType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__DescriptionsType(soap*, fims__DescriptionsType*) deserialize from a stream
/// - int soap_write_fims__DescriptionsType(soap, fims__DescriptionsType*) serialize to a stream
class fims__DescriptionsType
{ public:
/// Vector of fims__DescriptionType* element refs with length 1..unbounded
    std::vector<fims__DescriptionType* > description                    1;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://base.fims.tv":formatCollection

/// "http://base.fims.tv":formatCollection is a complexType.
/// class _fims__formatCollection operations:
/// - soap_new__fims__formatCollection(soap*) allocate
/// - soap_new__fims__formatCollection(soap*, int num) allocate array
/// - soap_new_req__fims__formatCollection(soap*, ...) allocate, set required members
/// - soap_new_set__fims__formatCollection(soap*, ...) allocate, set all public members
/// - int soap_read__fims__formatCollection(soap*, _fims__formatCollection*) deserialize from a stream
/// - int soap_write__fims__formatCollection(soap, _fims__formatCollection*) serialize to a stream
class _fims__formatCollection
{ public:
/// Element reference "http://base.fims.tv":videoFormat.
    fims__VideoFormatType*               videoFormat                    0;	///< Optional element.
/// Element reference "http://base.fims.tv":audioFormat.
    fims__AudioFormatType*               audioFormat                    0;	///< Optional element.
/// Element reference "http://base.fims.tv":dataFormat.
    fims__DataFormatType*                dataFormat                     0;	///< Optional element.
/// Element reference "http://base.fims.tv":containerFormat.
    fims__ContainerFormatType*           containerFormat                0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://description.fims.tv                                               *
 *                                                                            *
\******************************************************************************/


/// "http://description.fims.tv":bmContentDescriptionType is a complexType.
/// class fimsdescription__bmContentDescriptionType operations:
/// - soap_new_fimsdescription__bmContentDescriptionType(soap*) allocate
/// - soap_new_fimsdescription__bmContentDescriptionType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__bmContentDescriptionType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__bmContentDescriptionType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__bmContentDescriptionType(soap*, fimsdescription__bmContentDescriptionType*) deserialize from a stream
/// - int soap_write_fimsdescription__bmContentDescriptionType(soap, fimsdescription__bmContentDescriptionType*) serialize to a stream
class fimsdescription__bmContentDescriptionType
{ public:
/// Vector of fimsdescription__textElementType* with length 0..unbounded
    std::vector<fimsdescription__textElementType*> title                          0;
/// Vector of fimsdescription__titleType* with length 0..unbounded
    std::vector<fimsdescription__titleType*> alternativeTitle               0;
/// Vector of fimsdescription__entityType* with length 0..unbounded
    std::vector<fimsdescription__entityType*> creator                        0;
/// Vector of fimsdescription__subjectType* with length 0..unbounded
    std::vector<fimsdescription__subjectType*> subject                        0;
/// Vector of fimsdescription__descriptionType* with length 0..unbounded
    std::vector<fimsdescription__descriptionType*> description                    0;
/// Vector of fimsdescription__entityType* with length 0..unbounded
    std::vector<fimsdescription__entityType*> publisher                      0;
/// Vector of fimsdescription__entityType* with length 0..unbounded
    std::vector<fimsdescription__entityType*> contributor                    0;
/// Vector of fimsdescription__dateType* with length 0..unbounded
    std::vector<fimsdescription__dateType*> date                           0;
/// Vector of fimsdescription__typeType* with length 0..unbounded
    std::vector<fimsdescription__typeType*> type                           0;
/// Vector of fimsdescription__identifierType* with length 0..unbounded
    std::vector<fimsdescription__identifierType*> identifier                     0;
/// Vector of fimsdescription__languageType* with length 0..unbounded
    std::vector<fimsdescription__languageType*> language                       0;
/// Vector of fimsdescription__coverageType* with length 0..unbounded
    std::vector<fimsdescription__coverageType*> coverage                       0;
/// Vector of fimsdescription__rightsType* with length 0..unbounded
    std::vector<fimsdescription__rightsType*> rights                         0;
/// Element version of type xs:string.
    std::wstring*                        version                        0;	///< Optional element.
/// Imported attribute reference xml:lang.
   @_xml__lang*                          xml__lang                      0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":typeType is a complexType.
/// class fimsdescription__typeType operations:
/// - soap_new_fimsdescription__typeType(soap*) allocate
/// - soap_new_fimsdescription__typeType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__typeType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__typeType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__typeType(soap*, fimsdescription__typeType*) deserialize from a stream
/// - int soap_write_fimsdescription__typeType(soap, fimsdescription__typeType*) serialize to a stream
class fimsdescription__typeType
{ public:
/// Vector of genre with length 0..unbounded
    std::vector<
/// class _fimsdescription__typeType_genre operations:
/// - soap_new__fimsdescription__typeType_genre(soap*) allocate
/// - soap_new__fimsdescription__typeType_genre(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__typeType_genre(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__typeType_genre(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__typeType_genre(soap*, _fimsdescription__typeType_genre*) deserialize from a stream
/// - int soap_write__fimsdescription__typeType_genre(soap, _fimsdescription__typeType_genre*) serialize to a stream
    class _fimsdescription__typeType_genre
    {
/// INHERITED FROM fimsdescription__textElementType:
//  END OF INHERITED FROM fimsdescription__textElementType
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }>                                  *genre                          0;
/// Vector of objectType with length 0..unbounded
    std::vector<
/// class _fimsdescription__typeType_objectType operations:
/// - soap_new__fimsdescription__typeType_objectType(soap*) allocate
/// - soap_new__fimsdescription__typeType_objectType(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__typeType_objectType(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__typeType_objectType(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__typeType_objectType(soap*, _fimsdescription__typeType_objectType*) deserialize from a stream
/// - int soap_write__fimsdescription__typeType_objectType(soap, _fimsdescription__typeType_objectType*) serialize to a stream
    class _fimsdescription__typeType_objectType
    {
/// INHERITED FROM fimsdescription__textElementType:
//  END OF INHERITED FROM fimsdescription__textElementType
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }>                                  *objectType                     0;
/// Vector of targetAudience with length 0..unbounded
    std::vector<
/// class _fimsdescription__typeType_targetAudience operations:
/// - soap_new__fimsdescription__typeType_targetAudience(soap*) allocate
/// - soap_new__fimsdescription__typeType_targetAudience(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__typeType_targetAudience(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__typeType_targetAudience(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__typeType_targetAudience(soap*, _fimsdescription__typeType_targetAudience*) deserialize from a stream
/// - int soap_write__fimsdescription__typeType_targetAudience(soap, _fimsdescription__typeType_targetAudience*) serialize to a stream
    class _fimsdescription__typeType_targetAudience
    {
/// INHERITED FROM fimsdescription__textElementType:
//  END OF INHERITED FROM fimsdescription__textElementType
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }>                                  *targetAudience                 0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":coverageType is a complexType.
/// class fimsdescription__coverageType operations:
/// - soap_new_fimsdescription__coverageType(soap*) allocate
/// - soap_new_fimsdescription__coverageType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__coverageType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__coverageType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__coverageType(soap*, fimsdescription__coverageType*) deserialize from a stream
/// - int soap_write_fimsdescription__coverageType(soap, fimsdescription__coverageType*) serialize to a stream
class fimsdescription__coverageType
{ public:
/// class _fimsdescription__coverageType_temporal operations:
/// - soap_new__fimsdescription__coverageType_temporal(soap*) allocate
/// - soap_new__fimsdescription__coverageType_temporal(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__coverageType_temporal(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__coverageType_temporal(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__coverageType_temporal(soap*, _fimsdescription__coverageType_temporal*) deserialize from a stream
/// - int soap_write__fimsdescription__coverageType_temporal(soap, _fimsdescription__coverageType_temporal*) serialize to a stream
    class _fimsdescription__coverageType_temporal
    {
/// INHERITED FROM fimsdescription__textElementType:
//  END OF INHERITED FROM fimsdescription__textElementType
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *temporal                       0;	///< Optional element.
/// class _fimsdescription__coverageType_spatial operations:
/// - soap_new__fimsdescription__coverageType_spatial(soap*) allocate
/// - soap_new__fimsdescription__coverageType_spatial(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__coverageType_spatial(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__coverageType_spatial(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__coverageType_spatial(soap*, _fimsdescription__coverageType_spatial*) deserialize from a stream
/// - int soap_write__fimsdescription__coverageType_spatial(soap, _fimsdescription__coverageType_spatial*) serialize to a stream
    class _fimsdescription__coverageType_spatial
    {
/// class _fimsdescription__coverageType_spatial_locationName operations:
/// - soap_new__fimsdescription__coverageType_spatial_locationName(soap*) allocate
/// - soap_new__fimsdescription__coverageType_spatial_locationName(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__coverageType_spatial_locationName(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__coverageType_spatial_locationName(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__coverageType_spatial_locationName(soap*, _fimsdescription__coverageType_spatial_locationName*) deserialize from a stream
/// - int soap_write__fimsdescription__coverageType_spatial_locationName(soap, _fimsdescription__coverageType_spatial_locationName*) serialize to a stream
    class _fimsdescription__coverageType_spatial_locationName
    {
/// INHERITED FROM fimsdescription__textElementType:
//  END OF INHERITED FROM fimsdescription__textElementType
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                    locationName                   1;	///< Required element.
/// @brief Optional geospatial coordinates. 'posy' is the latitude. 'posx' is the longitude. Both are expressed in digital degrees
/// class _fimsdescription__coverageType_spatial_coordinates operations:
/// - soap_new__fimsdescription__coverageType_spatial_coordinates(soap*) allocate
/// - soap_new__fimsdescription__coverageType_spatial_coordinates(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__coverageType_spatial_coordinates(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__coverageType_spatial_coordinates(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__coverageType_spatial_coordinates(soap*, _fimsdescription__coverageType_spatial_coordinates*) deserialize from a stream
/// - int soap_write__fimsdescription__coverageType_spatial_coordinates(soap, _fimsdescription__coverageType_spatial_coordinates*) serialize to a stream
    class _fimsdescription__coverageType_spatial_coordinates
    {
/// Element posy of type xs:float.
    float                                posy                           1;	///< Required element.
/// Element posx of type xs:float.
    float                                posx                           1;	///< Required element.
/// Begin attributeGroup formatGroup.
/// Attribute formatLabel of type xs:string.
   @std::wstring*                        formatLabel                    0;	///< Optional attribute.
/// Attribute formatDefinition of type xs:string.
   @std::wstring*                        formatDefinition               0;	///< Optional attribute.
/// Attribute formatLink of type xs:anyURI.
   @xsd__anyURI*                         formatLink                     0;	///< Optional attribute.
/// Attribute formatLanguage of type xs:language.
   @xsd__language*                       formatLanguage                 0;	///< Optional attribute.
/// End of attributeGroup formatGroup.
    }                                   *coordinates                    0;	///< Optional element.
    }                                   *spatial                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":rightsType is a complexType.
/// class fimsdescription__rightsType operations:
/// - soap_new_fimsdescription__rightsType(soap*) allocate
/// - soap_new_fimsdescription__rightsType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__rightsType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__rightsType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__rightsType(soap*, fimsdescription__rightsType*) deserialize from a stream
/// - int soap_write_fimsdescription__rightsType(soap, fimsdescription__rightsType*) serialize to a stream
class fimsdescription__rightsType
{ public:
/// Vector of fimsdescription__textElementType* with length 0..unbounded
    std::vector<fimsdescription__textElementType*> rightsExpression               0;
/// Element rightsLink of type xs:anyURI.
    xsd__anyURI*                         rightsLink                     0;	///< Optional element.
/// Element rightsHolder of type "http://description.fims.tv":entityType.
    fimsdescription__entityType*         rightsHolder                   0;	///< Optional element.
/// Element exploitationIssues of type "http://description.fims.tv":textElementType.
    fimsdescription__textElementType*    exploitationIssues             0;	///< Optional element.
/// Element coverage of type "http://description.fims.tv":coverageType.
    fimsdescription__coverageType*       coverage                       0;	///< Optional element.
/// Element rightsClearanceFlag of type xs:boolean.
    bool*                                rightsClearanceFlag            0;	///< Optional element.
/// Vector of fimsdescription__textElementType* with length 0..unbounded
    std::vector<fimsdescription__textElementType*> disclaimer                     0;
/// Vector of fimsdescription__identifierType* with length 0..unbounded
    std::vector<fimsdescription__identifierType*> rightsId                       0;
/// Vector of fimsdescription__contactDetailsType* with length 0..unbounded
    std::vector<fimsdescription__contactDetailsType*> contactDetails                 0;
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":dateType is a complexType.
/// class fimsdescription__dateType operations:
/// - soap_new_fimsdescription__dateType(soap*) allocate
/// - soap_new_fimsdescription__dateType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__dateType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__dateType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__dateType(soap*, fimsdescription__dateType*) deserialize from a stream
/// - int soap_write_fimsdescription__dateType(soap, fimsdescription__dateType*) serialize to a stream
class fimsdescription__dateType
{ public:
/// class _fimsdescription__dateType_created operations:
/// - soap_new__fimsdescription__dateType_created(soap*) allocate
/// - soap_new__fimsdescription__dateType_created(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__dateType_created(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__dateType_created(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__dateType_created(soap*, _fimsdescription__dateType_created*) deserialize from a stream
/// - int soap_write__fimsdescription__dateType_created(soap, _fimsdescription__dateType_created*) serialize to a stream
    class _fimsdescription__dateType_created
    {
/// Begin attributeGroup dateGroup.
/// Attribute startYear of type xs:gYear.
   @xsd__gYear*                          startYear                      0;	///< Optional attribute.
/// Attribute startDate of type xs:date.
   @xsd__date*                           startDate                      0;	///< Optional attribute.
/// Attribute startTime of type xs:time.
   @xsd__time*                           startTime                      0;	///< Optional attribute.
/// Attribute endYear of type xs:gYear.
   @xsd__gYear*                          endYear                        0;	///< Optional attribute.
/// Attribute endDate of type xs:date.
   @xsd__date*                           endDate                        0;	///< Optional attribute.
/// Attribute endTime of type xs:time.
   @xsd__time*                           endTime                        0;	///< Optional attribute.
/// Attribute period of type xs:string.
   @std::wstring*                        period                         0;	///< Optional attribute.
/// End of attributeGroup dateGroup.
    }                                   *created                        0;	///< Optional element.
/// class _fimsdescription__dateType_modified operations:
/// - soap_new__fimsdescription__dateType_modified(soap*) allocate
/// - soap_new__fimsdescription__dateType_modified(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__dateType_modified(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__dateType_modified(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__dateType_modified(soap*, _fimsdescription__dateType_modified*) deserialize from a stream
/// - int soap_write__fimsdescription__dateType_modified(soap, _fimsdescription__dateType_modified*) serialize to a stream
    class _fimsdescription__dateType_modified
    {
/// Begin attributeGroup dateGroup.
/// Attribute startYear of type xs:gYear.
   @xsd__gYear*                          startYear                      0;	///< Optional attribute.
/// Attribute startDate of type xs:date.
   @xsd__date*                           startDate                      0;	///< Optional attribute.
/// Attribute startTime of type xs:time.
   @xsd__time*                           startTime                      0;	///< Optional attribute.
/// Attribute endYear of type xs:gYear.
   @xsd__gYear*                          endYear                        0;	///< Optional attribute.
/// Attribute endDate of type xs:date.
   @xsd__date*                           endDate                        0;	///< Optional attribute.
/// Attribute endTime of type xs:time.
   @xsd__time*                           endTime                        0;	///< Optional attribute.
/// Attribute period of type xs:string.
   @std::wstring*                        period                         0;	///< Optional attribute.
/// End of attributeGroup dateGroup.
    }                                   *modified                       0;	///< Optional element.
/// class _fimsdescription__dateType_issued operations:
/// - soap_new__fimsdescription__dateType_issued(soap*) allocate
/// - soap_new__fimsdescription__dateType_issued(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__dateType_issued(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__dateType_issued(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__dateType_issued(soap*, _fimsdescription__dateType_issued*) deserialize from a stream
/// - int soap_write__fimsdescription__dateType_issued(soap, _fimsdescription__dateType_issued*) serialize to a stream
    class _fimsdescription__dateType_issued
    {
/// Begin attributeGroup dateGroup.
/// Attribute startYear of type xs:gYear.
   @xsd__gYear*                          startYear                      0;	///< Optional attribute.
/// Attribute startDate of type xs:date.
   @xsd__date*                           startDate                      0;	///< Optional attribute.
/// Attribute startTime of type xs:time.
   @xsd__time*                           startTime                      0;	///< Optional attribute.
/// Attribute endYear of type xs:gYear.
   @xsd__gYear*                          endYear                        0;	///< Optional attribute.
/// Attribute endDate of type xs:date.
   @xsd__date*                           endDate                        0;	///< Optional attribute.
/// Attribute endTime of type xs:time.
   @xsd__time*                           endTime                        0;	///< Optional attribute.
/// Attribute period of type xs:string.
   @std::wstring*                        period                         0;	///< Optional attribute.
/// End of attributeGroup dateGroup.
    }                                   *issued                         0;	///< Optional element.
/// class _fimsdescription__dateType_alternative operations:
/// - soap_new__fimsdescription__dateType_alternative(soap*) allocate
/// - soap_new__fimsdescription__dateType_alternative(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__dateType_alternative(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__dateType_alternative(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__dateType_alternative(soap*, _fimsdescription__dateType_alternative*) deserialize from a stream
/// - int soap_write__fimsdescription__dateType_alternative(soap, _fimsdescription__dateType_alternative*) serialize to a stream
    class _fimsdescription__dateType_alternative
    {
/// Begin attributeGroup dateGroup.
/// Attribute startYear of type xs:gYear.
   @xsd__gYear*                          startYear                      0;	///< Optional attribute.
/// Attribute startDate of type xs:date.
   @xsd__date*                           startDate                      0;	///< Optional attribute.
/// Attribute startTime of type xs:time.
   @xsd__time*                           startTime                      0;	///< Optional attribute.
/// Attribute endYear of type xs:gYear.
   @xsd__gYear*                          endYear                        0;	///< Optional attribute.
/// Attribute endDate of type xs:date.
   @xsd__date*                           endDate                        0;	///< Optional attribute.
/// Attribute endTime of type xs:time.
   @xsd__time*                           endTime                        0;	///< Optional attribute.
/// Attribute period of type xs:string.
   @std::wstring*                        period                         0;	///< Optional attribute.
/// End of attributeGroup dateGroup.
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *alternative                    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":entityType is a complexType.
/// class fimsdescription__entityType operations:
/// - soap_new_fimsdescription__entityType(soap*) allocate
/// - soap_new_fimsdescription__entityType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__entityType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__entityType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__entityType(soap*, fimsdescription__entityType*) deserialize from a stream
/// - int soap_write_fimsdescription__entityType(soap, fimsdescription__entityType*) serialize to a stream
class fimsdescription__entityType
{ public:
/// Vector of fimsdescription__contactDetailsType* with length 0..unbounded
    std::vector<fimsdescription__contactDetailsType*> contactDetails                 0;
/// Vector of fimsdescription__organisationDetailsType* with length 0..unbounded
    std::vector<fimsdescription__organisationDetailsType*> organisationDetails            0;
/// Vector of role with length 0..unbounded
    std::vector<
/// class _fimsdescription__entityType_role operations:
/// - soap_new__fimsdescription__entityType_role(soap*) allocate
/// - soap_new__fimsdescription__entityType_role(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__entityType_role(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__entityType_role(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__entityType_role(soap*, _fimsdescription__entityType_role*) deserialize from a stream
/// - int soap_write__fimsdescription__entityType_role(soap, _fimsdescription__entityType_role*) serialize to a stream
    class _fimsdescription__entityType_role
    {
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }>                                  *role                           0;
/// Attribute entityId of type xs:anyURI.
   @xsd__anyURI*                         entityId                       0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":contactDetailsType is a complexType.
/// class fimsdescription__contactDetailsType operations:
/// - soap_new_fimsdescription__contactDetailsType(soap*) allocate
/// - soap_new_fimsdescription__contactDetailsType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__contactDetailsType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__contactDetailsType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__contactDetailsType(soap*, fimsdescription__contactDetailsType*) deserialize from a stream
/// - int soap_write_fimsdescription__contactDetailsType(soap, fimsdescription__contactDetailsType*) serialize to a stream
class fimsdescription__contactDetailsType
{ public:
/// CHOICE <xs:choice>
/// Note: <xs:choice> with embedded <xs:sequence> or <xs:group> prevents the use of a union
/// Element name of type xs:string.
    std::wstring*                        name                          ;
/// SEQUENCE <xs:sequence>
/// Element givenName of type xs:string.
    std::wstring*                        givenName                     ;
/// Element familyName of type xs:string.
    std::wstring*                        familyName                    ;
/// Vector of std::wstring with length 0..unbounded
    std::vector<std::wstring           > otherGivenName                ;
/// Element suffix of type xs:string.
    std::wstring*                        suffix                        ;
/// Element salutation of type xs:string.
    std::wstring*                        salutation                    ;
//  END OF SEQUENCE
;
//  END OF CHOICE
/// Vector of fimsdescription__textElementType* with length 0..unbounded
    std::vector<fimsdescription__textElementType*> username                       0;
/// Element occupation of type "http://description.fims.tv":textElementType.
    fimsdescription__textElementType*    occupation                     0;	///< Optional element.
/// Vector of fimsdescription__detailsType* with length 0..unbounded
    std::vector<fimsdescription__detailsType*> details                        0;
/// @brief For example, in the case the contact is a performing actor/actress, the stage name will be the fictitious character's name
/// Vector of fimsdescription__textElementType* with length 0..unbounded
    std::vector<fimsdescription__textElementType*> stageName                      0;
/// @brief This is used to identify contacts related to the contact being described
/// Vector of fimsdescription__entityType* with length 0..unbounded
    std::vector<fimsdescription__entityType*> relatedContacts                0;
/// Attribute contactId of type xs:anyURI.
   @xsd__anyURI*                         contactId                      0;	///< Optional attribute.
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":organisationDetailsType is a complexType.
/// class fimsdescription__organisationDetailsType operations:
/// - soap_new_fimsdescription__organisationDetailsType(soap*) allocate
/// - soap_new_fimsdescription__organisationDetailsType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__organisationDetailsType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__organisationDetailsType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__organisationDetailsType(soap*, fimsdescription__organisationDetailsType*) deserialize from a stream
/// - int soap_write_fimsdescription__organisationDetailsType(soap, fimsdescription__organisationDetailsType*) serialize to a stream
class fimsdescription__organisationDetailsType
{ public:
/// @brief The organisation name is optional as an organisation maybe identified by its OrganisationId
/// Vector of fimsdescription__textElementType* with length 0..unbounded
    std::vector<fimsdescription__textElementType*> organisationName               0;
/// Vector of xsd__anyURI with length 0..unbounded
    std::vector<xsd__anyURI            > organisationCode               0;
/// @brief To identify one or more production area / department / service where the resource was created/originated, in free text
/// class _fimsdescription__organisationDetailsType_organisationDepartment operations:
/// - soap_new__fimsdescription__organisationDetailsType_organisationDepartment(soap*) allocate
/// - soap_new__fimsdescription__organisationDetailsType_organisationDepartment(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__organisationDetailsType_organisationDepartment(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__organisationDetailsType_organisationDepartment(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__organisationDetailsType_organisationDepartment(soap*, _fimsdescription__organisationDetailsType_organisationDepartment*) deserialize from a stream
/// - int soap_write__fimsdescription__organisationDetailsType_organisationDepartment(soap, _fimsdescription__organisationDetailsType_organisationDepartment*) serialize to a stream
    class _fimsdescription__organisationDetailsType_organisationDepartment
    {
/// INHERITED FROM fimsdescription__textElementType:
//  END OF INHERITED FROM fimsdescription__textElementType
/// Attribute departmentId of type xs:anyURI.
   @xsd__anyURI*                         departmentId                   0;	///< Optional attribute.
    }                                   *organisationDepartment         0;	///< Optional element.
/// Vector of fimsdescription__detailsType* with length 0..unbounded
    std::vector<fimsdescription__detailsType*> details                        0;
/// @brief Useful to provide contact information particularly is no other person information is otherwise provided.
/// Vector of fimsdescription__entityType* with length 0..unbounded
    std::vector<fimsdescription__entityType*> contacts                       0;
/// Attribute organisationId of type xs:anyURI.
   @xsd__anyURI*                         organisationId                 0;	///< Optional attribute.
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":detailsType is a complexType.
/// class fimsdescription__detailsType operations:
/// - soap_new_fimsdescription__detailsType(soap*) allocate
/// - soap_new_fimsdescription__detailsType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__detailsType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__detailsType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__detailsType(soap*, fimsdescription__detailsType*) deserialize from a stream
/// - int soap_write_fimsdescription__detailsType(soap, fimsdescription__detailsType*) serialize to a stream
class fimsdescription__detailsType
{ public:
/// @brief The e-mail address through which the contact can be directly accessed
/// Vector of std::wstring with length 0..unbounded
    std::vector<std::wstring           > emailAddress                   0;
/// @brief The web address where additional information can be found regarding the company
/// Element webAddress of type xs:string.
    std::wstring*                        webAddress                     0;	///< Optional element.
/// @brief The organisation address is also the professional address of the contact in the context of the content being described and in relation to the contact occupation provided in the contact details
/// Element address of type "http://description.fims.tv":addressType.
    fimsdescription__addressType*        address                        0;	///< Optional element.
/// Element telephoneNumber of type xs:string.
    std::wstring*                        telephoneNumber                0;	///< Optional element.
/// Element mobileTelephoneNumber of type xs:string.
    std::wstring*                        mobileTelephoneNumber          0;	///< Optional element.
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":addressType is a complexType.
/// @brief Provides address details for an organisation
/// class fimsdescription__addressType operations:
/// - soap_new_fimsdescription__addressType(soap*) allocate
/// - soap_new_fimsdescription__addressType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__addressType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__addressType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__addressType(soap*, fimsdescription__addressType*) deserialize from a stream
/// - int soap_write_fimsdescription__addressType(soap, fimsdescription__addressType*) serialize to a stream
class fimsdescription__addressType
{ public:
/// Vector of fimsdescription__textElementType* with length 0..unbounded
    std::vector<fimsdescription__textElementType*> addressLine                    0;
/// Element addressTownCity of type "http://description.fims.tv":textElementType.
    fimsdescription__textElementType*    addressTownCity                0;	///< Optional element.
/// Element addressCountyState of type "http://description.fims.tv":textElementType.
    fimsdescription__textElementType*    addressCountyState             0;	///< Optional element.
/// Element addressDeliveryCode of type xs:string.
    std::wstring*                        addressDeliveryCode            0;	///< Optional element.
/// class _fimsdescription__addressType_country operations:
/// - soap_new__fimsdescription__addressType_country(soap*) allocate
/// - soap_new__fimsdescription__addressType_country(soap*, int num) allocate array
/// - soap_new_req__fimsdescription__addressType_country(soap*, ...) allocate, set required members
/// - soap_new_set__fimsdescription__addressType_country(soap*, ...) allocate, set all public members
/// - int soap_read__fimsdescription__addressType_country(soap*, _fimsdescription__addressType_country*) deserialize from a stream
/// - int soap_write__fimsdescription__addressType_country(soap, _fimsdescription__addressType_country*) serialize to a stream
    class _fimsdescription__addressType_country
    {
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *country                        0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":languageType is a complexType.
/// class fimsdescription__languageType operations:
/// - soap_new_fimsdescription__languageType(soap*) allocate
/// - soap_new_fimsdescription__languageType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__languageType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__languageType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__languageType(soap*, fimsdescription__languageType*) deserialize from a stream
/// - int soap_write_fimsdescription__languageType(soap, fimsdescription__languageType*) serialize to a stream
class fimsdescription__languageType
{ public:
/// Imported attribute reference xml:lang.
   @_xml__lang*                          xml__lang                      0;	///< Optional attribute.
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://temp/edlprovider":EdlCreateRequestType is a complexType with complexContent extension of "http://temp/edlprovider":EdlCreateRequestBaseType.
/// @brief Represents the request to create a edl for the specified type and frame rate.
/// class edlprovider__EdlCreateRequestType operations:
/// - soap_new_edlprovider__EdlCreateRequestType(soap*) allocate
/// - soap_new_edlprovider__EdlCreateRequestType(soap*, int num) allocate array
/// - soap_new_req_edlprovider__EdlCreateRequestType(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__EdlCreateRequestType(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__EdlCreateRequestType(soap*, edlprovider__EdlCreateRequestType*) deserialize from a stream
/// - int soap_write_edlprovider__EdlCreateRequestType(soap, edlprovider__EdlCreateRequestType*) serialize to a stream
class edlprovider__EdlCreateRequestType : public edlprovider__EdlCreateRequestBaseType
{ public:
/*  INHERITED FROM edlprovider__EdlCreateRequestBaseType:
/// @brief The edl type to generate, the types available can be obtained using getInstalledEdls.
/// Element edlType of type xs:string.
    std::wstring                         edlType                        1;	///< Required element.
/// @brief List of clips to include in the created EDL.
/// Element clips of type "http://temp/edlprovider":ArrayOfClips.
    edlprovider__ArrayOfClips*           clips                          0;	///< Nillable pointer.
/// @brief The EDL sequence name. This might mean something different in different EDL's.
/// Element edlSequenceName of type xs:string.
    std::wstring*                        edlSequenceName                0;	///< Nillable pointer.
    END OF INHERITED FROM edlprovider__EdlCreateRequestBaseType */
/// @brief The EDL frames per second.
/// Element edlFramesPerSecond of type "http://base.fims.tv":RationalType.
    fims__RationalType*                  edlFramesPerSecond             1;	///< Required element.
};

/// "http://temp/edlprovider":EdlCreateRequestDoubleType is a complexType with complexContent extension of "http://temp/edlprovider":EdlCreateRequestBaseType.
/// @brief Represents the request to create a edl for the specified type and frame rate.
/// class edlprovider__EdlCreateRequestDoubleType operations:
/// - soap_new_edlprovider__EdlCreateRequestDoubleType(soap*) allocate
/// - soap_new_edlprovider__EdlCreateRequestDoubleType(soap*, int num) allocate array
/// - soap_new_req_edlprovider__EdlCreateRequestDoubleType(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__EdlCreateRequestDoubleType(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__EdlCreateRequestDoubleType(soap*, edlprovider__EdlCreateRequestDoubleType*) deserialize from a stream
/// - int soap_write_edlprovider__EdlCreateRequestDoubleType(soap, edlprovider__EdlCreateRequestDoubleType*) serialize to a stream
class edlprovider__EdlCreateRequestDoubleType : public edlprovider__EdlCreateRequestBaseType
{ public:
/*  INHERITED FROM edlprovider__EdlCreateRequestBaseType:
/// @brief The edl type to generate, the types available can be obtained using getInstalledEdls.
/// Element edlType of type xs:string.
    std::wstring                         edlType                        1;	///< Required element.
/// @brief List of clips to include in the created EDL.
/// Element clips of type "http://temp/edlprovider":ArrayOfClips.
    edlprovider__ArrayOfClips*           clips                          0;	///< Nillable pointer.
/// @brief The EDL sequence name. This might mean something different in different EDL's.
/// Element edlSequenceName of type xs:string.
    std::wstring*                        edlSequenceName                0;	///< Nillable pointer.
    END OF INHERITED FROM edlprovider__EdlCreateRequestBaseType */
/// @brief The EDL frames per second.
/// Element edlFramesPerSecond of type xs:double.
    double                               edlFramesPerSecond             1;	///< Required element.
};

/// "http://temp/edlprovider":EdlProviderFaultType is a complexType with complexContent extension of "http://base.fims.tv":FaultType.
/// @brief Fault information for the EDL provider service.
/// class edlprovider__EdlProviderFaultType operations:
/// - soap_new_edlprovider__EdlProviderFaultType(soap*) allocate
/// - soap_new_edlprovider__EdlProviderFaultType(soap*, int num) allocate array
/// - soap_new_req_edlprovider__EdlProviderFaultType(soap*, ...) allocate, set required members
/// - soap_new_set_edlprovider__EdlProviderFaultType(soap*, ...) allocate, set all public members
/// - int soap_read_edlprovider__EdlProviderFaultType(soap*, edlprovider__EdlProviderFaultType*) deserialize from a stream
/// - int soap_write_edlprovider__EdlProviderFaultType(soap, edlprovider__EdlProviderFaultType*) serialize to a stream
class edlprovider__EdlProviderFaultType : public fims__FaultType
{ public:
/*  INHERITED FROM fims__FaultType:
/// @brief The error code specified in ErrorCodeType.
/// Element code of type "http://base.fims.tv":ErrorCodeType.
    enum fims__ErrorCodeType             code                           1;	///< Required element.
/// @brief An optional description of the error.
/// Element description of type xs:string.
    std::wstring*                        description                    0;	///< Optional element.
/// @brief This optional field can provide a detailed description of the error.
/// Element detail of type xs:string.
    std::wstring*                        detail                         0;	///< Optional element.
/// @brief Additional description of the lower-level errors.
/// Vector of fims__InnerFaultType* with length 0..unbounded
    std::vector<fims__InnerFaultType*  > innerFault                     0;
    END OF INHERITED FROM fims__FaultType */
/// @brief EDL provider service-specific error codes as detailed in EDLProviderErrorCodeType.
/// Element extendedCode of type "http://temp/edlprovider":EDLProviderErrorCodeType.
    enum edlprovider__EDLProviderErrorCodeType*  extendedCode                   0;	///< Optional element.
};

/// "http://base.fims.tv":ResourceType is an abstract complexType with complexContent extension of "http://base.fims.tv":ResourceReferenceType.
/// @brief Resources include queues, jobs, assets, descriptions, formats and profiles.
/// class fims__ResourceType operations:
/// - soap_new_fims__ResourceType(soap*) allocate
/// - soap_new_fims__ResourceType(soap*, int num) allocate array
/// - soap_new_req_fims__ResourceType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ResourceType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ResourceType(soap*, fims__ResourceType*) deserialize from a stream
/// - int soap_write_fims__ResourceType(soap, fims__ResourceType*) serialize to a stream
class fims__ResourceType : public fims__ResourceReferenceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
};

/// "http://base.fims.tv":CaptioningFormatType is a complexType with simpleContent.
/// @brief Describes a captioning format and its purpose.
/// class fims__CaptioningFormatType operations:
/// - soap_new_fims__CaptioningFormatType(soap*) allocate
/// - soap_new_fims__CaptioningFormatType(soap*, int num) allocate array
/// - soap_new_req_fims__CaptioningFormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__CaptioningFormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__CaptioningFormatType(soap*, fims__CaptioningFormatType*) deserialize from a stream
/// - int soap_write_fims__CaptioningFormatType(soap, fims__CaptioningFormatType*) serialize to a stream
class fims__CaptioningFormatType
{ public:
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// @brief Location of the file with the captioning/subtitling data. See '@captioningSourceUri' in EBU Tech 3293 for more information.
/// Attribute captioningSourceUri of type xs:anyURI.
   @xsd__anyURI*                         captioningSourceUri            0;	///< Optional attribute.
/// @brief Language of the caption as delivered (e.g., en-UK). See 'captioningFormat - dc:language' in EBU Tech 3293 for more information.
/// Attribute language of type xs:language.
   @xsd__language*                       language                       0;	///< Optional attribute.
/// Begin attributeGroup formatGroup.
/// @brief Free text field. See EBU Tech 3293 for more information.
/// Attribute formatLabel of type xs:string.
   @std::wstring*                        formatLabel                    0;	///< Optional attribute.
/// @brief An optional definition. See EBU Tech 3293 for more information.
/// Attribute formatDefinition of type xs:string.
   @std::wstring*                        formatDefinition               0;	///< Optional attribute.
/// @brief A link to a term or identification of a classification scheme. See EBU Tech 3293 for more information.
/// Attribute formatLink of type xs:anyURI.
   @xsd__anyURI*                         formatLink                     0;	///< Optional attribute.
/// End of attributeGroup formatGroup.
/// <anyAttribute namespace="##other">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this attribute.
///       Use wsdl2h option -d for xsd__anyAttribute DOM (soap_dom_attribute).
   @_XML                                 __anyAttribute                ;	///< A placeholder that has no effect: please see comment.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":TechnicalAttributeType is a complexType with simpleContent.
/// @brief Allows users / implementers to define their own technical parameters as string for which a format can be defined to restrict the string format. See 'TechnicalAttributeString' in EBU Tech 3293 for more information.
/// class fims__TechnicalAttributeType operations:
/// - soap_new_fims__TechnicalAttributeType(soap*) allocate
/// - soap_new_fims__TechnicalAttributeType(soap*, int num) allocate array
/// - soap_new_req_fims__TechnicalAttributeType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__TechnicalAttributeType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__TechnicalAttributeType(soap*, fims__TechnicalAttributeType*) deserialize from a stream
/// - int soap_write_fims__TechnicalAttributeType(soap, fims__TechnicalAttributeType*) serialize to a stream
class fims__TechnicalAttributeType
{ public:
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// Begin attributeGroup formatGroup.
/// @brief Free text field. See EBU Tech 3293 for more information.
/// Attribute formatLabel of type xs:string.
   @std::wstring*                        formatLabel                    0;	///< Optional attribute.
/// @brief An optional definition. See EBU Tech 3293 for more information.
/// Attribute formatDefinition of type xs:string.
   @std::wstring*                        formatDefinition               0;	///< Optional attribute.
/// @brief A link to a term or identification of a classification scheme. See EBU Tech 3293 for more information.
/// Attribute formatLink of type xs:anyURI.
   @xsd__anyURI*                         formatLink                     0;	///< Optional attribute.
/// End of attributeGroup formatGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":LengthType is a complexType with simpleContent.
/// @brief A length value and its unit of measurement.
/// class fims__LengthType operations:
/// - soap_new_fims__LengthType(soap*) allocate
/// - soap_new_fims__LengthType(soap*, int num) allocate array
/// - soap_new_req_fims__LengthType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__LengthType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__LengthType(soap*, fims__LengthType*) deserialize from a stream
/// - int soap_write_fims__LengthType(soap, fims__LengthType*) serialize to a stream
class fims__LengthType
{ public:
/// __item wraps 'xs:nonNegativeInteger' simpleContent.
    xsd__nonNegativeInteger              __item                        ;
/// @brief Specifies the unit in which the length is expressed. See '@unit' in EBU Tech 3293 for more information.
/// Attribute unit of type xs:string.
   @std::wstring*                        unit                           0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":RationalType is a complexType with simpleContent.
/// @brief A rational value expressed by its fraction of a second numerator and denominator components. Rational values can be used to represent edit rates. For example, a frame rate of 29.97 would be represented as 30 corrected by 1000 (numerator) / 1001 (denominator).
/// class fims__RationalType operations:
/// - soap_new_fims__RationalType(soap*) allocate
/// - soap_new_fims__RationalType(soap*, int num) allocate array
/// - soap_new_req_fims__RationalType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__RationalType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__RationalType(soap*, fims__RationalType*) deserialize from a stream
/// - int soap_write_fims__RationalType(soap, fims__RationalType*) serialize to a stream
class fims__RationalType
{ public:
/// __item wraps 'xs:long' simpleContent.
    LONG64                               __item                        ;
/// @brief The numerator of the rational value.
/// Attribute numerator of type xs:positiveInteger.
   @xsd__positiveInteger                 numerator                      1;	///< Required attribute.
/// @brief The denominator of the rational value.
/// Attribute denominator of type xs:positiveInteger.
   @xsd__positiveInteger                 denominator                    1;	///< Required attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":EditUnitNumberType is a complexType with simpleContent.
/// @brief A number of edit units as defined in EBU Tech 3293. An editUnit is the inverse of the edit rate, or corrected edit rate as the result of editUnit=1/(editrate*(factorNumerator/factorDenominator)). A number of edit units as defined in EBU Tech 3293. An editUnit is the inverse of the edit rate, or corrected edit rate as the result of editUnit=1/(editRrate*(factorNumerator/factorDenominator)). Values of the combination of editRate, factorNumerator, and factorDenominator shall be subject to the constraints listed in the Annex EditUnitNumberType. See EBU Tech 3293 for more information.
/// class fims__EditUnitNumberType operations:
/// - soap_new_fims__EditUnitNumberType(soap*) allocate
/// - soap_new_fims__EditUnitNumberType(soap*, int num) allocate array
/// - soap_new_req_fims__EditUnitNumberType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__EditUnitNumberType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__EditUnitNumberType(soap*, fims__EditUnitNumberType*) deserialize from a stream
/// - int soap_write_fims__EditUnitNumberType(soap, fims__EditUnitNumberType*) serialize to a stream
class fims__EditUnitNumberType
{ public:
/// __item wraps 'xs:long' simpleContent.
    LONG64                               __item                        ;
/// @brief The base number of frames or samples per seconds. This base number can be corrected by a factor calculated as the product of the edit rate and 'factorNumerator/factorDenominator'.
/// Attribute editRate of type xs:positiveInteger.
   @xsd__positiveInteger                 editRate                       1;	///< Required attribute.
/// @brief The numerator of the correction factor.
/// Attribute factorNumerator of type xs:positiveInteger.
   @xsd__positiveInteger                 factorNumerator                1;	///< Required attribute.
/// @brief The denominator of the correction factor.
/// Attribute factorDenominator of type xs:positiveInteger.
   @xsd__positiveInteger                 factorDenominator              1;	///< Required attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ProcessedInfoByBytesType is a complexType with complexContent extension of "http://base.fims.tv":ProcessedInfoType.
/// @brief Statistics on number of bytes processed.
/// class fims__ProcessedInfoByBytesType operations:
/// - soap_new_fims__ProcessedInfoByBytesType(soap*) allocate
/// - soap_new_fims__ProcessedInfoByBytesType(soap*, int num) allocate array
/// - soap_new_req_fims__ProcessedInfoByBytesType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ProcessedInfoByBytesType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ProcessedInfoByBytesType(soap*, fims__ProcessedInfoByBytesType*) deserialize from a stream
/// - int soap_write_fims__ProcessedInfoByBytesType(soap, fims__ProcessedInfoByBytesType*) serialize to a stream
class fims__ProcessedInfoByBytesType : public fims__ProcessedInfoType
{ public:
/*  INHERITED FROM fims__ProcessedInfoType:
/// @brief The percentage of job completed. The percentage can be based on one of two metrics: number of bytes processed, or number of frames processed (e.g. for transcoding video files). If the "processedBytesCount" metric is provided, then the percentage is based on number of bytes processed. If the "processedFramesCount" metric is provided, then the percentage is based on the number of processed frames.
/// Value range is [0..100]
    xsd__nonNegativeInteger                                            
                                         percentageProcessedCompleted   1;	///< Required element.
    END OF INHERITED FROM fims__ProcessedInfoType */
/// @brief The number of bytes processed from the start of the job.
/// Element processedBytesCount of type xs:unsignedLong.
    ULONG64                              processedBytesCount            1;	///< Required element.
};

/// "http://base.fims.tv":ProcessedInfoByFramesType is a complexType with complexContent extension of "http://base.fims.tv":ProcessedInfoType.
/// @brief Statistics on number of frames processed.
/// class fims__ProcessedInfoByFramesType operations:
/// - soap_new_fims__ProcessedInfoByFramesType(soap*) allocate
/// - soap_new_fims__ProcessedInfoByFramesType(soap*, int num) allocate array
/// - soap_new_req_fims__ProcessedInfoByFramesType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ProcessedInfoByFramesType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ProcessedInfoByFramesType(soap*, fims__ProcessedInfoByFramesType*) deserialize from a stream
/// - int soap_write_fims__ProcessedInfoByFramesType(soap, fims__ProcessedInfoByFramesType*) serialize to a stream
class fims__ProcessedInfoByFramesType : public fims__ProcessedInfoType
{ public:
/*  INHERITED FROM fims__ProcessedInfoType:
/// @brief The percentage of job completed. The percentage can be based on one of two metrics: number of bytes processed, or number of frames processed (e.g. for transcoding video files). If the "processedBytesCount" metric is provided, then the percentage is based on number of bytes processed. If the "processedFramesCount" metric is provided, then the percentage is based on the number of processed frames.
/// Value range is [0..100]
    xsd__nonNegativeInteger                                            
                                         percentageProcessedCompleted   1;	///< Required element.
    END OF INHERITED FROM fims__ProcessedInfoType */
/// @brief The number of frames (for audiovisual content only) processed from the beginning of the job.
/// Element processedFramesCount of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger              processedFramesCount           1;	///< Required element.
};

/// "http://base.fims.tv":StartProcessByNoWaitType is a complexType with complexContent extension of "http://base.fims.tv":StartProcessType.
/// @brief Start a real-time process with no initial wait.
/// class fims__StartProcessByNoWaitType operations:
/// - soap_new_fims__StartProcessByNoWaitType(soap*) allocate
/// - soap_new_fims__StartProcessByNoWaitType(soap*, int num) allocate array
/// - soap_new_req_fims__StartProcessByNoWaitType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartProcessByNoWaitType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartProcessByNoWaitType(soap*, fims__StartProcessByNoWaitType*) deserialize from a stream
/// - int soap_write_fims__StartProcessByNoWaitType(soap, fims__StartProcessByNoWaitType*) serialize to a stream
class fims__StartProcessByNoWaitType : public fims__StartProcessType
{ public:
/*  INHERITED FROM fims__StartProcessType:
    END OF INHERITED FROM fims__StartProcessType */
/// @brief Actual time that the process started.
/// Element actualStartTime of type xs:dateTime.
    time_t*                              actualStartTime                0;	///< Optional element.
/// @brief Time mark indicating the time that the process started as a value measured along the associated audio and/or video stream.
/// Element actualStartMark of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      actualStartMark                0;	///< Optional element.
};

/// "http://base.fims.tv":StartProcessByTimeType is a complexType with complexContent extension of "http://base.fims.tv":StartProcessType.
/// @brief Provides the time when a real-time process should start.
/// class fims__StartProcessByTimeType operations:
/// - soap_new_fims__StartProcessByTimeType(soap*) allocate
/// - soap_new_fims__StartProcessByTimeType(soap*, int num) allocate array
/// - soap_new_req_fims__StartProcessByTimeType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartProcessByTimeType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartProcessByTimeType(soap*, fims__StartProcessByTimeType*) deserialize from a stream
/// - int soap_write_fims__StartProcessByTimeType(soap, fims__StartProcessByTimeType*) serialize to a stream
class fims__StartProcessByTimeType : public fims__StartProcessType
{ public:
/*  INHERITED FROM fims__StartProcessType:
    END OF INHERITED FROM fims__StartProcessType */
/// @brief The time for starting a real-time process.
/// Element time of type xs:dateTime.
    time_t                               time                           1;	///< Required element.
};

/// "http://base.fims.tv":StartProcessByTimeMarkType is a complexType with complexContent extension of "http://base.fims.tv":StartProcessType.
/// @brief Provides a video or audio stream time mark value to indicate the required start of a real-time process.
/// class fims__StartProcessByTimeMarkType operations:
/// - soap_new_fims__StartProcessByTimeMarkType(soap*) allocate
/// - soap_new_fims__StartProcessByTimeMarkType(soap*, int num) allocate array
/// - soap_new_req_fims__StartProcessByTimeMarkType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartProcessByTimeMarkType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartProcessByTimeMarkType(soap*, fims__StartProcessByTimeMarkType*) deserialize from a stream
/// - int soap_write_fims__StartProcessByTimeMarkType(soap, fims__StartProcessByTimeMarkType*) serialize to a stream
class fims__StartProcessByTimeMarkType : public fims__StartProcessType
{ public:
/*  INHERITED FROM fims__StartProcessType:
    END OF INHERITED FROM fims__StartProcessType */
/// @brief A video and audio time point reference.
/// Element timeMark of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      timeMark                       1;	///< Required element.
};

/// "http://base.fims.tv":StartProcessByServiceDefinedTimeType is a complexType with complexContent extension of "http://base.fims.tv":StartProcessType.
/// @brief A service-specific time mechanism specifies when a process is required to start.
/// class fims__StartProcessByServiceDefinedTimeType operations:
/// - soap_new_fims__StartProcessByServiceDefinedTimeType(soap*) allocate
/// - soap_new_fims__StartProcessByServiceDefinedTimeType(soap*, int num) allocate array
/// - soap_new_req_fims__StartProcessByServiceDefinedTimeType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartProcessByServiceDefinedTimeType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartProcessByServiceDefinedTimeType(soap*, fims__StartProcessByServiceDefinedTimeType*) deserialize from a stream
/// - int soap_write_fims__StartProcessByServiceDefinedTimeType(soap, fims__StartProcessByServiceDefinedTimeType*) serialize to a stream
class fims__StartProcessByServiceDefinedTimeType : public fims__StartProcessType
{ public:
/*  INHERITED FROM fims__StartProcessType:
    END OF INHERITED FROM fims__StartProcessType */
/// @brief Actual time that the process started.
/// Element actualStartTime of type xs:dateTime.
    time_t*                              actualStartTime                0;	///< Optional element.
/// @brief Time mark indicating the time that the process started as a value measured along the associated audio and/or video stream.
/// Element actualStartMark of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      actualStartMark                0;	///< Optional element.
};

/// "http://base.fims.tv":StopProcessByTimeType is a complexType with complexContent extension of "http://base.fims.tv":StopProcessType.
/// @brief The time when a real-time process should stop.
/// class fims__StopProcessByTimeType operations:
/// - soap_new_fims__StopProcessByTimeType(soap*) allocate
/// - soap_new_fims__StopProcessByTimeType(soap*, int num) allocate array
/// - soap_new_req_fims__StopProcessByTimeType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StopProcessByTimeType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StopProcessByTimeType(soap*, fims__StopProcessByTimeType*) deserialize from a stream
/// - int soap_write_fims__StopProcessByTimeType(soap, fims__StopProcessByTimeType*) serialize to a stream
class fims__StopProcessByTimeType : public fims__StopProcessType
{ public:
/*  INHERITED FROM fims__StopProcessType:
    END OF INHERITED FROM fims__StopProcessType */
/// @brief Time to stop a real-time process.
/// Element time of type xs:dateTime.
    time_t                               time                           1;	///< Required element.
};

/// "http://base.fims.tv":StopProcessByDurationType is a complexType with complexContent extension of "http://base.fims.tv":StopProcessType.
/// @brief Total duration of the real time process.
/// class fims__StopProcessByDurationType operations:
/// - soap_new_fims__StopProcessByDurationType(soap*) allocate
/// - soap_new_fims__StopProcessByDurationType(soap*, int num) allocate array
/// - soap_new_req_fims__StopProcessByDurationType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StopProcessByDurationType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StopProcessByDurationType(soap*, fims__StopProcessByDurationType*) deserialize from a stream
/// - int soap_write_fims__StopProcessByDurationType(soap, fims__StopProcessByDurationType*) serialize to a stream
class fims__StopProcessByDurationType : public fims__StopProcessType
{ public:
/*  INHERITED FROM fims__StopProcessType:
    END OF INHERITED FROM fims__StopProcessType */
/// @brief Total required duration of the real-time process.
/// Element duration of type "http://base.fims.tv":DurationType.
    fims__DurationType*                  duration                       1;	///< Required element.
};

/// "http://base.fims.tv":StopProcessByTimeMarkType is a complexType with complexContent extension of "http://base.fims.tv":StopProcessType.
/// @brief A video or audio stream time reference when the real-time process stops.
/// class fims__StopProcessByTimeMarkType operations:
/// - soap_new_fims__StopProcessByTimeMarkType(soap*) allocate
/// - soap_new_fims__StopProcessByTimeMarkType(soap*, int num) allocate array
/// - soap_new_req_fims__StopProcessByTimeMarkType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StopProcessByTimeMarkType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StopProcessByTimeMarkType(soap*, fims__StopProcessByTimeMarkType*) deserialize from a stream
/// - int soap_write_fims__StopProcessByTimeMarkType(soap, fims__StopProcessByTimeMarkType*) serialize to a stream
class fims__StopProcessByTimeMarkType : public fims__StopProcessType
{ public:
/*  INHERITED FROM fims__StopProcessType:
    END OF INHERITED FROM fims__StopProcessType */
/// @brief A video or audio time point reference.
/// Element timeMark of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      timeMark                       1;	///< Required element.
};

/// "http://base.fims.tv":StopProcessByServiceDefinedTimeType is a complexType with complexContent extension of "http://base.fims.tv":StopProcessType.
/// @brief A service-specific time mechanism specifies when a process is required to stop.
/// class fims__StopProcessByServiceDefinedTimeType operations:
/// - soap_new_fims__StopProcessByServiceDefinedTimeType(soap*) allocate
/// - soap_new_fims__StopProcessByServiceDefinedTimeType(soap*, int num) allocate array
/// - soap_new_req_fims__StopProcessByServiceDefinedTimeType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StopProcessByServiceDefinedTimeType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StopProcessByServiceDefinedTimeType(soap*, fims__StopProcessByServiceDefinedTimeType*) deserialize from a stream
/// - int soap_write_fims__StopProcessByServiceDefinedTimeType(soap, fims__StopProcessByServiceDefinedTimeType*) serialize to a stream
class fims__StopProcessByServiceDefinedTimeType : public fims__StopProcessType
{ public:
/*  INHERITED FROM fims__StopProcessType:
    END OF INHERITED FROM fims__StopProcessType */
/// @brief Actual time that the process stopped.
/// Element actualStopTime of type xs:dateTime.
    time_t*                              actualStopTime                 0;	///< Optional element.
/// @brief Time mark indicating the time that the process stopped as a value measured along the the associated audio and/or video stream.
/// Element actualStopMark of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      actualStopMark                 0;	///< Optional element.
};

/// "http://base.fims.tv":StopProcessByOpenEndType is a complexType with complexContent extension of "http://base.fims.tv":StopProcessType.
/// @brief The real-time process is to continue indefinitely until a stop command (manageJobRequest) is received.
/// class fims__StopProcessByOpenEndType operations:
/// - soap_new_fims__StopProcessByOpenEndType(soap*) allocate
/// - soap_new_fims__StopProcessByOpenEndType(soap*, int num) allocate array
/// - soap_new_req_fims__StopProcessByOpenEndType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StopProcessByOpenEndType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StopProcessByOpenEndType(soap*, fims__StopProcessByOpenEndType*) deserialize from a stream
/// - int soap_write_fims__StopProcessByOpenEndType(soap, fims__StopProcessByOpenEndType*) serialize to a stream
class fims__StopProcessByOpenEndType : public fims__StopProcessType
{ public:
/*  INHERITED FROM fims__StopProcessType:
    END OF INHERITED FROM fims__StopProcessType */
/// @brief Actual time that the process stopped.
/// Element actualStopTime of type xs:dateTime.
    time_t*                              actualStopTime                 0;	///< Optional element.
/// @brief Time mark indicating the time that the process stopped as a value measured along the the associated audio and/or video stream.
/// Element actualStopMark of type "http://base.fims.tv":TimeType.
    fims__TimeType*                      actualStopMark                 0;	///< Optional element.
};

/// "http://base.fims.tv":StartJobByNoWaitType is a complexType with complexContent extension of "http://base.fims.tv":StartJobType.
/// @brief Start a job as soon as possible.
/// class fims__StartJobByNoWaitType operations:
/// - soap_new_fims__StartJobByNoWaitType(soap*) allocate
/// - soap_new_fims__StartJobByNoWaitType(soap*, int num) allocate array
/// - soap_new_req_fims__StartJobByNoWaitType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartJobByNoWaitType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartJobByNoWaitType(soap*, fims__StartJobByNoWaitType*) deserialize from a stream
/// - int soap_write_fims__StartJobByNoWaitType(soap, fims__StartJobByNoWaitType*) serialize to a stream
class fims__StartJobByNoWaitType : public fims__StartJobType
{ public:
/*  INHERITED FROM fims__StartJobType:
    END OF INHERITED FROM fims__StartJobType */
};

/// "http://base.fims.tv":StartJobByTimeType is a complexType with complexContent extension of "http://base.fims.tv":StartJobType.
/// @brief Provides a time when the job should start.
/// class fims__StartJobByTimeType operations:
/// - soap_new_fims__StartJobByTimeType(soap*) allocate
/// - soap_new_fims__StartJobByTimeType(soap*, int num) allocate array
/// - soap_new_req_fims__StartJobByTimeType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartJobByTimeType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartJobByTimeType(soap*, fims__StartJobByTimeType*) deserialize from a stream
/// - int soap_write_fims__StartJobByTimeType(soap, fims__StartJobByTimeType*) serialize to a stream
class fims__StartJobByTimeType : public fims__StartJobType
{ public:
/*  INHERITED FROM fims__StartJobType:
    END OF INHERITED FROM fims__StartJobType */
/// @brief Time when the job should start.
/// Element time of type xs:dateTime.
    time_t                               time                           1;	///< Required element.
};

/// "http://base.fims.tv":StartJobByLatestType is a complexType with complexContent extension of "http://base.fims.tv":StartJobType.
/// @brief Start the job as close as possible to the defined start process time.
/// class fims__StartJobByLatestType operations:
/// - soap_new_fims__StartJobByLatestType(soap*) allocate
/// - soap_new_fims__StartJobByLatestType(soap*, int num) allocate array
/// - soap_new_req_fims__StartJobByLatestType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StartJobByLatestType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StartJobByLatestType(soap*, fims__StartJobByLatestType*) deserialize from a stream
/// - int soap_write_fims__StartJobByLatestType(soap, fims__StartJobByLatestType*) serialize to a stream
class fims__StartJobByLatestType : public fims__StartJobType
{ public:
/*  INHERITED FROM fims__StartJobType:
    END OF INHERITED FROM fims__StartJobType */
};

/// "http://base.fims.tv":QueryJobRequestByIDType is a complexType with complexContent extension of "http://base.fims.tv":QueryJobRequestType.
/// @brief This type is part of the FIMS service common status interface and provides a mechanism query jobs and retrieve information associated to them. A client can request the status of multiple identified jobs.
/// class fims__QueryJobRequestByIDType operations:
/// - soap_new_fims__QueryJobRequestByIDType(soap*) allocate
/// - soap_new_fims__QueryJobRequestByIDType(soap*, int num) allocate array
/// - soap_new_req_fims__QueryJobRequestByIDType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueryJobRequestByIDType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueryJobRequestByIDType(soap*, fims__QueryJobRequestByIDType*) deserialize from a stream
/// - int soap_write_fims__QueryJobRequestByIDType(soap, fims__QueryJobRequestByIDType*) serialize to a stream
class fims__QueryJobRequestByIDType : public fims__QueryJobRequestType
{ public:
/*  INHERITED FROM fims__QueryJobRequestType:
/// @brief Level of status details to be returned for the jobs.
/// Element jobInfoSelection of type "http://base.fims.tv":JobInfoSelectionType.
    enum fims__JobInfoSelectionType      jobInfoSelection               1;	///< Required element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__QueryJobRequestType */
/// @brief This element carries the IDs of one or more jobs for which status is to be retrieved.
/// Vector of fims__UID with length 1..unbounded
    std::vector<fims__UID              > jobID                          1;
};

/// "http://base.fims.tv":QueryJobRequestByFilterType is a complexType with complexContent extension of "http://base.fims.tv":QueryJobRequestType.
/// @brief This type is part of the FIMS service common status interface and provides a mechanism query jobs and retrieve information associated to them. A client can request the status of jobs that meet requirements specified by a filter object.
/// class fims__QueryJobRequestByFilterType operations:
/// - soap_new_fims__QueryJobRequestByFilterType(soap*) allocate
/// - soap_new_fims__QueryJobRequestByFilterType(soap*, int num) allocate array
/// - soap_new_req_fims__QueryJobRequestByFilterType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueryJobRequestByFilterType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueryJobRequestByFilterType(soap*, fims__QueryJobRequestByFilterType*) deserialize from a stream
/// - int soap_write_fims__QueryJobRequestByFilterType(soap, fims__QueryJobRequestByFilterType*) serialize to a stream
class fims__QueryJobRequestByFilterType : public fims__QueryJobRequestType
{ public:
/*  INHERITED FROM fims__QueryJobRequestType:
/// @brief Level of status details to be returned for the jobs.
/// Element jobInfoSelection of type "http://base.fims.tv":JobInfoSelectionType.
    enum fims__JobInfoSelectionType      jobInfoSelection               1;	///< Required element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__QueryJobRequestType */
/// @brief This element defines the filtering parameters to list jobs for which status is to be retrieved.
/// Element listFilter of type "http://base.fims.tv":ListFilterType.
    fims__ListFilterType*                listFilter                     1;	///< Required element.
};

/// "http://description.fims.tv":identifierType is a complexType with simpleContent.
/// class fimsdescription__identifierType operations:
/// - soap_new_fimsdescription__identifierType(soap*) allocate
/// - soap_new_fimsdescription__identifierType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__identifierType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__identifierType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__identifierType(soap*, fimsdescription__identifierType*) deserialize from a stream
/// - int soap_write_fimsdescription__identifierType(soap, fimsdescription__identifierType*) serialize to a stream
class fimsdescription__identifierType
{ public:
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// Begin attributeGroup formatGroup.
/// Attribute formatLabel of type xs:string.
   @std::wstring*                        formatLabel                    0;	///< Optional attribute.
/// Attribute formatDefinition of type xs:string.
   @std::wstring*                        formatDefinition               0;	///< Optional attribute.
/// Attribute formatLink of type xs:anyURI.
   @xsd__anyURI*                         formatLink                     0;	///< Optional attribute.
/// Attribute formatLanguage of type xs:language.
   @xsd__language*                       formatLanguage                 0;	///< Optional attribute.
/// End of attributeGroup formatGroup.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":textElementType is a complexType with simpleContent.
/// class fimsdescription__textElementType operations:
/// - soap_new_fimsdescription__textElementType(soap*) allocate
/// - soap_new_fimsdescription__textElementType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__textElementType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__textElementType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__textElementType(soap*, fimsdescription__textElementType*) deserialize from a stream
/// - int soap_write_fimsdescription__textElementType(soap, fimsdescription__textElementType*) serialize to a stream
class fimsdescription__textElementType
{ public:
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Imported attribute reference xml:lang.
   @_xml__lang*                          xml__lang                      0;	///< Optional attribute.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":ServiceType is a complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Describes the location endpoint, provider and Service Description of the service.
/// class fims__ServiceType operations:
/// - soap_new_fims__ServiceType(soap*) allocate
/// - soap_new_fims__ServiceType(soap*, int num) allocate array
/// - soap_new_req_fims__ServiceType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ServiceType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ServiceType(soap*, fims__ServiceType*) deserialize from a stream
/// - int soap_write_fims__ServiceType(soap, fims__ServiceType*) serialize to a stream
class fims__ServiceType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief Name for the provider of a service.
/// Element providerName of type xs:string.
    std::wstring*                        providerName                   0;	///< Optional element.
/// @brief Provider endpoint that uniquely locates the provider servicing the job request.
/// Element providerEndPoint of type xs:anyURI.
    xsd__anyURI*                         providerEndPoint               0;	///< Optional element.
/// @brief Service-specific description of the capabilities offered by the service. The transfer, transcode and capture services defined alongside the original FIMS framework have service descriptions provided and, if used, it is recommended that these are embedded here.
/// class _fims__ServiceType_serviceDescription operations:
/// - soap_new__fims__ServiceType_serviceDescription(soap*) allocate
/// - soap_new__fims__ServiceType_serviceDescription(soap*, int num) allocate array
/// - soap_new_req__fims__ServiceType_serviceDescription(soap*, ...) allocate, set required members
/// - soap_new_set__fims__ServiceType_serviceDescription(soap*, ...) allocate, set all public members
/// - int soap_read__fims__ServiceType_serviceDescription(soap*, _fims__ServiceType_serviceDescription*) deserialize from a stream
/// - int soap_write__fims__ServiceType_serviceDescription(soap, _fims__ServiceType_serviceDescription*) serialize to a stream
    class _fims__ServiceType_serviceDescription
    {
/// TODO: <any namespace="##other" minOccurs="1" maxOccurs="unbounded">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
/// Size of the array of XML or DOM nodes is 1..unbounded
    std::vector<_XML                   > __any                         0;	///< Catch any element content in XML string.
    }                                   *serviceDescription             0;	///< Optional element.
};

/// "http://base.fims.tv":ProfileType is an abstract complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief A profile used by a FIMS media service to perform a job on media content. For example, it may represent the profile of a transfer media service for transferring media content and, as such, may specify the media format to be produced in output. The profile provides a mechanism to specify service-provider-specific information for each operation.
/// class fims__ProfileType operations:
/// - soap_new_fims__ProfileType(soap*) allocate
/// - soap_new_fims__ProfileType(soap*, int num) allocate array
/// - soap_new_req_fims__ProfileType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ProfileType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ProfileType(soap*, fims__ProfileType*) deserialize from a stream
/// - int soap_write_fims__ProfileType(soap, fims__ProfileType*) serialize to a stream
class fims__ProfileType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief Details of the service that has been selected to execute this profile.
/// Element service of type "http://base.fims.tv":ServiceType.
    fims__ServiceType*                   service                        0;	///< Optional element.
/// @brief Name of the profile.
/// Attribute name of type xs:string.
   @std::wstring*                        name                           0;	///< Optional attribute.
/// @brief Description of the profile.
/// Attribute description of type xs:string.
   @std::wstring*                        description                    0;	///< Optional attribute.
};

/// "http://base.fims.tv":QueueType is a complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Provides basic queue information, such as the status and length of the queue.
/// class fims__QueueType operations:
/// - soap_new_fims__QueueType(soap*) allocate
/// - soap_new_fims__QueueType(soap*, int num) allocate array
/// - soap_new_req_fims__QueueType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__QueueType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__QueueType(soap*, fims__QueueType*) deserialize from a stream
/// - int soap_write_fims__QueueType(soap, fims__QueueType*) serialize to a stream
class fims__QueueType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief Status information for the queue.
/// Element status of type "http://base.fims.tv":QueueStatusType.
    enum fims__QueueStatusType*          status                         0;	///< Optional element.
/// @brief An optional description for the status.
/// Element statusDescription of type xs:string.
    std::wstring*                        statusDescription              0;	///< Optional element.
/// @brief Length of the queue, measured in the number of jobs currently in this queue.
/// Element length of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             length                         0;	///< Optional element.
/// @brief Determines if the queue is currently available.
/// Element availability of type xs:boolean.
    bool*                                availability                   0;	///< Optional element.
/// @brief Estimate of the time duration required for processing all jobs currently in the queue.
/// Element estimatedTotalCompletionDuration of type xs:duration.
    xsd__duration*                       estimatedTotalCompletionDuration 0;	///< Optional element.
/// @brief Optional list of jobs currently in the queue.
/// Element jobs of type "http://base.fims.tv":JobsType.
    fims__JobsType*                      jobs                           0;	///< Optional element.
};

/// "http://base.fims.tv":JobType is an abstract complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Describes a job, which is extended in each service schema.
/// class fims__JobType operations:
/// - soap_new_fims__JobType(soap*) allocate
/// - soap_new_fims__JobType(soap*, int num) allocate array
/// - soap_new_req_fims__JobType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__JobType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__JobType(soap*, fims__JobType*) deserialize from a stream
/// - int soap_write_fims__JobType(soap, fims__JobType*) serialize to a stream
class fims__JobType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief The current status of the job (e.g. running, completed), enumerated in JobStatusType.
/// Element status of type "http://base.fims.tv":JobStatusType.
    enum fims__JobStatusType*            status                         0;	///< Optional element.
/// @brief Optional description for job status.
/// Element statusDescription of type xs:string.
    std::wstring*                        statusDescription              0;	///< Optional element.
/// @brief Service-provided local job identifier, such as a job identifier provided locally by an application.
/// Element serviceProviderJobID of type xs:string.
    std::wstring*                        serviceProviderJobID           0;	///< Optional element.
/// @brief The queue that has master control over execution of this job. As a FIMS-compliant device is not required to support queues, this element is optional.
/// Element queueReference of type "http://base.fims.tv":QueueType.
    fims__QueueType*                     queueReference                 0;	///< Optional element.
/// @brief A list of sub-tasks that consists of related jobs running in parallel. For information only in FIMS 1.0. Whether the sub-tasks are running in parallel or sequence to one another is not recorded in this model.
/// Element tasks of type "http://base.fims.tv":JobsType.
    fims__JobsType*                      tasks                          0;	///< Optional element.
/// @brief Descriptive name of the operation associated with this job.
/// Element operationName of type xs:string.
    std::wstring*                        operationName                  0;	///< Optional element.
/// @brief Business media objects produced or consumed by the job. For some services, such as a capture service, no BMObjects are consumed. However, the job will include a BMObject on completion.
/// Element bmObjects of type "http://base.fims.tv":BMObjectsType.
    fims__BMObjectsType*                 bmObjects                      0;	///< Optional element.
/// @brief The priority for the job (e.g. "immediate", "high"...) enumerated in PriorityType. Where supported, job priorities describe the relative priority of a job in the owning queue.
/// Element priority of type "http://base.fims.tv":PriorityType.
    enum fims__PriorityType*             priority                       0;	///< Optional element.
/// @brief Parameter used to indicate that the job shall be initiated no earlier then the specified time.
/// Element startJob of type "http://base.fims.tv":StartJobType.
    fims__StartJobType*                  startJob                       0;	///< Optional element.
/// @brief Specifies the time by which the job shall have been completed. This element also specifies the deadline for job execution. For example, in the case of specifying "TimeMark" type in the "stopProcess", it can be used as a timeout time.
/// Element finishBefore of type xs:dateTime.
    time_t*                              finishBefore                   0;	///< Optional element.
/// @brief Before the job has started, an estimate for the expected total duration of the job. Once the job has started, it provides an estimation of time remaining until the end of the job.
/// Element estimatedCompletionDuration of type xs:duration.
    xsd__duration*                       estimatedCompletionDuration    0;	///< Optional element.
/// @brief The position of the job in the queue.
/// Element currentQueuePosition of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             currentQueuePosition           0;	///< Optional element.
/// @brief The date and time this job started.
/// Element jobStartedTime of type xs:dateTime.
    time_t*                              jobStartedTime                 0;	///< Optional element.
/// @brief The time elapsed since the job started.
/// Element jobElapsedTime of type xs:duration.
    xsd__duration*                       jobElapsedTime                 0;	///< Optional element.
/// @brief The time and date that the job completed.
/// Element jobCompletedTime of type xs:dateTime.
    time_t*                              jobCompletedTime               0;	///< Optional element.
/// @brief Provides statistics on number of bytes or frames processed. Note that a time-based percentage value to completion is not directly provided, but can be calculated if the service provides the "estimatedCompletionDuration". The time-based percentage is a ratio between "jobElapsedTime" and "estimatedCompletionDuration".
/// Element processed of type "http://base.fims.tv":ProcessedInfoType.
    fims__ProcessedInfoType*             processed                      0;	///< Optional element.
};

/// "http://base.fims.tv":FormatType is an abstract complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Characteristics of files, video, audio and ancillary data.
/// class fims__FormatType operations:
/// - soap_new_fims__FormatType(soap*) allocate
/// - soap_new_fims__FormatType(soap*, int num) allocate array
/// - soap_new_req_fims__FormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__FormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__FormatType(soap*, fims__FormatType*) deserialize from a stream
/// - int soap_write_fims__FormatType(soap, fims__FormatType*) serialize to a stream
class fims__FormatType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief User defined technical attributes. See 'technical attribute' in EBU Tech 3293 for more information.
/// Vector of fims__TechnicalAttributeType* with length 0..unbounded
    std::vector<fims__TechnicalAttributeType*> technicalAttribute             0;
};

/// "http://base.fims.tv":BMObjectType is a complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Common representation of the content exchanged by FIMS media services, through reference to logical content objects. Note that although the current BMObject can only reference at most one logical content item, it is intended that future versions of FIMS will extend BMObject to provide different kinds of content collections, such as sequences and edit decision lists.
/// class fims__BMObjectType operations:
/// - soap_new_fims__BMObjectType(soap*) allocate
/// - soap_new_fims__BMObjectType(soap*, int num) allocate array
/// - soap_new_req_fims__BMObjectType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMObjectType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMObjectType(soap*, fims__BMObjectType*) deserialize from a stream
/// - int soap_write_fims__BMObjectType(soap, fims__BMObjectType*) serialize to a stream
class fims__BMObjectType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief Logical content item that is exchanged by a FIMS media service.
/// Element bmContents of type "http://base.fims.tv":BMContentsType.
    fims__BMContentsType*                bmContents                     0;	///< Optional element.
};

/// "http://base.fims.tv":BMContentType is a complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Logical items of content, representing a sequence of frames and/or samples that have a fixed length and are intended to be played sequentially from end-to-end.
/// class fims__BMContentType operations:
/// - soap_new_fims__BMContentType(soap*) allocate
/// - soap_new_fims__BMContentType(soap*, int num) allocate array
/// - soap_new_req_fims__BMContentType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMContentType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMContentType(soap*, fims__BMContentType*) deserialize from a stream
/// - int soap_write_fims__BMContentType(soap, fims__BMContentType*) serialize to a stream
class fims__BMContentType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief List of different content formats that provide physical representations of the logical content item. Content formats are different renditions of the same content, differing in the way they are encoded. Content formats have technical metadata.
/// Element bmContentFormats of type "http://base.fims.tv":BMContentFormatsType.
    fims__BMContentFormatsType*          bmContentFormats               0;	///< Optional element.
/// @brief Non-technical descriptions of the logical content. It is recommended that a basic description of the content items is included by making use of the FIMS description metadata schema (http://description.fims.tv), which is based on a subset of descriptive metadata fields from EBUCore and Dublin Core. This will be useful for interoperable monitoring applications by providing a consistent place where, say, a title field can be found for presentation in a GUI. Content items may have many different descriptions for different purposes, such as for archiving, presentation, rights management and contributor management. For this purpose, the use of multiple descriptions in included. Also, a programme may be an episode that is part of a series that is part of a brand and the descriptions of each level in that hierarchy could be included (by reference) here.
/// Element descriptions of type "http://base.fims.tv":DescriptionsType.
    fims__DescriptionsType*              descriptions                   0;	///< Optional element.
};

/// "http://base.fims.tv":DescriptionType is a complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Description of a logical content, containing descriptive metadata. Descriptive metadata is attached using the proposed core XML description based on EBUCore or using the schema "any" facility supported by all resources.
/// class fims__DescriptionType operations:
/// - soap_new_fims__DescriptionType(soap*) allocate
/// - soap_new_fims__DescriptionType(soap*, int num) allocate array
/// - soap_new_req_fims__DescriptionType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__DescriptionType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__DescriptionType(soap*, fims__DescriptionType*) deserialize from a stream
/// - int soap_write_fims__DescriptionType(soap, fims__DescriptionType*) serialize to a stream
class fims__DescriptionType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief Description of a logical content, containing core descriptive metadata based on EBUCore.
/// Element reference "http://description.fims.tv":bmContentDescription.
    fimsdescription__bmContentDescriptionType*  fimsdescription__bmContentDescription 0;	///< Optional element.
};

/// "http://base.fims.tv":BMContentFormatType is a complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Format description and essence locations of a physical representation of single rendition of a logical content item.
/// class fims__BMContentFormatType operations:
/// - soap_new_fims__BMContentFormatType(soap*) allocate
/// - soap_new_fims__BMContentFormatType(soap*, int num) allocate array
/// - soap_new_req_fims__BMContentFormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMContentFormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMContentFormatType(soap*, fims__BMContentFormatType*) deserialize from a stream
/// - int soap_write_fims__BMContentFormatType(soap, fims__BMContentFormatType*) serialize to a stream
class fims__BMContentFormatType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief Known locations for the content.
/// Element bmEssenceLocators of type "http://base.fims.tv":BMEssenceLocatorsType.
    fims__BMEssenceLocatorsType*         bmEssenceLocators              0;	///< Optional element.
/// @brief Technical metadata describing this specific physical embodiment of the content. The description contains the video, audio, data and container formats of the content format.
/// Element reference "http://base.fims.tv":formatCollection.
    _fims__formatCollection*             formatCollection               0;	///< Optional element.
/// @brief Duration of the audio and/or visual content.
/// Element duration of type "http://base.fims.tv":DurationType.
    fims__DurationType*                  duration                       0;	///< Optional element.
/// @brief Hash code value calculated for the physical essence representation.
/// Element hash of type "http://base.fims.tv":HashType.
    fims__HashType*                      hash                           0;	///< Optional element.
/// @brief Size of the file or collection of files that provide the physical essence representation.
/// Element packageSize of type xs:unsignedLong.
    ULONG64*                             packageSize                    0;	///< Optional element.
/// @brief Multipurpose Internet Mail Extensions Media Type for the physical essence representation. The MIME type can include any required or optional parameters after the type, separated by semicolons. Note that this MIME type refers to the overall type of media, for example a folder containing P2 card data or an AS-02 bundle both use MXF file formats, setting this property to "application/mxf".
/// class _fims__BMContentFormatType_mimeType operations:
/// - soap_new__fims__BMContentFormatType_mimeType(soap*) allocate
/// - soap_new__fims__BMContentFormatType_mimeType(soap*, int num) allocate array
/// - soap_new_req__fims__BMContentFormatType_mimeType(soap*, ...) allocate, set required members
/// - soap_new_set__fims__BMContentFormatType_mimeType(soap*, ...) allocate, set all public members
/// - int soap_read__fims__BMContentFormatType_mimeType(soap*, _fims__BMContentFormatType_mimeType*) deserialize from a stream
/// - int soap_write__fims__BMContentFormatType_mimeType(soap, _fims__BMContentFormatType_mimeType*) serialize to a stream
    class _fims__BMContentFormatType_mimeType
    {
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *mimeType                       0;	///< Optional element.
};

/// "http://base.fims.tv":BMEssenceLocatorType is an abstract complexType with complexContent extension of "http://base.fims.tv":ResourceType.
/// @brief Location of a physical representation of an item of content. Note that essence locations may be shared by multiple physical content formats and/or logical content items. For example, a folder structure taken from a camera may contain both master-quality and proxy-quality versions. The same essence locator can be targeted by two different physical content formats for the same logical content item. As another example, an AS-02 bundle may contain two different editorial versions of the same programme and can be referenced from two separate logical content items.
/// class fims__BMEssenceLocatorType operations:
/// - soap_new_fims__BMEssenceLocatorType(soap*) allocate
/// - soap_new_fims__BMEssenceLocatorType(soap*, int num) allocate array
/// - soap_new_req_fims__BMEssenceLocatorType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__BMEssenceLocatorType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__BMEssenceLocatorType(soap*, fims__BMEssenceLocatorType*) deserialize from a stream
/// - int soap_write_fims__BMEssenceLocatorType(soap, fims__BMEssenceLocatorType*) serialize to a stream
class fims__BMEssenceLocatorType : public fims__ResourceType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/// @brief Kind of storage for the essence, for example "online" or "hsm".
/// Element storageType of type "http://base.fims.tv":StorageType.
    fims__StorageType*                   storageType                    0;	///< Optional element.
/// @brief Describes the geographical location of the content, for example "New York".
/// Element locatorInfo of type xs:string.
    std::wstring*                        locatorInfo                    0;	///< Optional element.
/// @brief Multipurpose Internet Mail Extensions Media Type for the physical container used for the representation. Vendors are encouraged to register MIME types for the containers in use, such as a folder containing capture data from a camera. Where additional structural data is required, vendors are encouraged to extend one of the essence locator types (single file, list, folder).
/// class _fims__BMEssenceLocatorType_containerMimeType operations:
/// - soap_new__fims__BMEssenceLocatorType_containerMimeType(soap*) allocate
/// - soap_new__fims__BMEssenceLocatorType_containerMimeType(soap*, int num) allocate array
/// - soap_new_req__fims__BMEssenceLocatorType_containerMimeType(soap*, ...) allocate, set required members
/// - soap_new_set__fims__BMEssenceLocatorType_containerMimeType(soap*, ...) allocate, set all public members
/// - int soap_read__fims__BMEssenceLocatorType_containerMimeType(soap*, _fims__BMEssenceLocatorType_containerMimeType*) deserialize from a stream
/// - int soap_write__fims__BMEssenceLocatorType_containerMimeType(soap, _fims__BMEssenceLocatorType_containerMimeType*) serialize to a stream
    class _fims__BMEssenceLocatorType_containerMimeType
    {
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *containerMimeType              0;	///< Optional element.
};

/// "http://base.fims.tv":StorageType is a complexType with simpleContent.
/// @brief Different kinds of storage media available (e.g. online on disk), in combination with type group attributes.
/// class fims__StorageType operations:
/// - soap_new_fims__StorageType(soap*) allocate
/// - soap_new_fims__StorageType(soap*, int num) allocate array
/// - soap_new_req_fims__StorageType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__StorageType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__StorageType(soap*, fims__StorageType*) deserialize from a stream
/// - int soap_write_fims__StorageType(soap, fims__StorageType*) serialize to a stream
class fims__StorageType
{ public:
/// __item wraps '"http://base.fims.tv":StorageTypes' simpleContent.
    enum fims__StorageTypes              __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// <anyAttribute namespace="##other">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this attribute.
///       Use wsdl2h option -d for xsd__anyAttribute DOM (soap_dom_attribute).
   @_XML                                 __anyAttribute                ;	///< A placeholder that has no effect: please see comment.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://base.fims.tv":HashFunctionType is a complexType with simpleContent.
/// @brief Different hash functions that can be used to hash the content, as defined in SMPTE ST 2032, in combination with type group description.
/// class fims__HashFunctionType operations:
/// - soap_new_fims__HashFunctionType(soap*) allocate
/// - soap_new_fims__HashFunctionType(soap*, int num) allocate array
/// - soap_new_req_fims__HashFunctionType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__HashFunctionType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__HashFunctionType(soap*, fims__HashFunctionType*) deserialize from a stream
/// - int soap_write_fims__HashFunctionType(soap, fims__HashFunctionType*) serialize to a stream
class fims__HashFunctionType
{ public:
/// __item wraps '"http://base.fims.tv":HashFunctionTypes' simpleContent.
    enum fims__HashFunctionTypes         __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
/// <anyAttribute namespace="##other">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this attribute.
///       Use wsdl2h option -d for xsd__anyAttribute DOM (soap_dom_attribute).
   @_XML                                 __anyAttribute                ;	///< A placeholder that has no effect: please see comment.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://description.fims.tv":titleType is a complexType with complexContent extension of "http://description.fims.tv":textElementType.
/// class fimsdescription__titleType operations:
/// - soap_new_fimsdescription__titleType(soap*) allocate
/// - soap_new_fimsdescription__titleType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__titleType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__titleType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__titleType(soap*, fimsdescription__titleType*) deserialize from a stream
/// - int soap_write_fimsdescription__titleType(soap, fimsdescription__titleType*) serialize to a stream
class fimsdescription__titleType : public fimsdescription__textElementType
{ public:
/*  INHERITED FROM fimsdescription__textElementType:
    END OF INHERITED FROM fimsdescription__textElementType */
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
};

/// "http://description.fims.tv":subjectType is a complexType with complexContent extension of "http://description.fims.tv":textElementType.
/// class fimsdescription__subjectType operations:
/// - soap_new_fimsdescription__subjectType(soap*) allocate
/// - soap_new_fimsdescription__subjectType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__subjectType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__subjectType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__subjectType(soap*, fimsdescription__subjectType*) deserialize from a stream
/// - int soap_write_fimsdescription__subjectType(soap, fimsdescription__subjectType*) serialize to a stream
class fimsdescription__subjectType : public fimsdescription__textElementType
{ public:
/*  INHERITED FROM fimsdescription__textElementType:
    END OF INHERITED FROM fimsdescription__textElementType */
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
};

/// "http://description.fims.tv":descriptionType is a complexType with complexContent extension of "http://description.fims.tv":textElementType.
/// class fimsdescription__descriptionType operations:
/// - soap_new_fimsdescription__descriptionType(soap*) allocate
/// - soap_new_fimsdescription__descriptionType(soap*, int num) allocate array
/// - soap_new_req_fimsdescription__descriptionType(soap*, ...) allocate, set required members
/// - soap_new_set_fimsdescription__descriptionType(soap*, ...) allocate, set all public members
/// - int soap_read_fimsdescription__descriptionType(soap*, fimsdescription__descriptionType*) deserialize from a stream
/// - int soap_write_fimsdescription__descriptionType(soap, fimsdescription__descriptionType*) serialize to a stream
class fimsdescription__descriptionType : public fimsdescription__textElementType
{ public:
/*  INHERITED FROM fimsdescription__textElementType:
    END OF INHERITED FROM fimsdescription__textElementType */
/// Begin attributeGroup typeGroup.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// Attribute typeLanguage of type xs:language.
   @xsd__language*                       typeLanguage                   0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
};

/// "http://base.fims.tv":VideoFormatType is a complexType with complexContent extension of "http://base.fims.tv":FormatType.
/// @brief Characteristics of a video signal. See 'videoFormat' in EBU Tech 3293 for more information.
/// class fims__VideoFormatType operations:
/// - soap_new_fims__VideoFormatType(soap*) allocate
/// - soap_new_fims__VideoFormatType(soap*, int num) allocate array
/// - soap_new_req_fims__VideoFormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__VideoFormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__VideoFormatType(soap*, fims__VideoFormatType*) deserialize from a stream
/// - int soap_write_fims__VideoFormatType(soap, fims__VideoFormatType*) serialize to a stream
class fims__VideoFormatType : public fims__FormatType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/*  INHERITED FROM fims__FormatType:
/// @brief User defined technical attributes. See 'technical attribute' in EBU Tech 3293 for more information.
/// Vector of fims__TechnicalAttributeType* with length 0..unbounded
    std::vector<fims__TechnicalAttributeType*> technicalAttribute             0;
    END OF INHERITED FROM fims__FormatType */
/// @brief Width of the image or picture. Used as numerator to define the aspect ratio for video content. See 'width' in EBU Tech 3293 for more information.
/// Element displayWidth of type "http://base.fims.tv":LengthType.
    fims__LengthType*                    displayWidth                   0;	///< Optional element.
/// @brief Height of the image or picture. Used as denominator to define the aspect ratio for video content. See 'height' in EBU Tech 3293 for more information.
/// Element displayHeight of type "http://base.fims.tv":LengthType.
    fims__LengthType*                    displayHeight                  0;	///< Optional element.
/// @brief Frame rate for the video content, measured in frames/second.
/// Element frameRate of type "http://base.fims.tv":RationalType.
    fims__RationalType*                  frameRate                      0;	///< Optional element.
/// @brief Ratio of the picture (the width by the height), for instance '4:3' or '16:9' (rational). The format of the aspect ratio is specified in the format attributes. See 'aspectRatio' in EBU Tech 3293 for more information.
/// Element aspectRatio of type "http://base.fims.tv":RationalType.
    fims__RationalType*                  aspectRatio                    0;	///< Optional element.
/// @brief Defines the encoding parameters of the resource (e.g. H264) for a video channel. See 'videoEncoding' in EBU Tech 3293 for more information.
/// Element videoEncoding of type "http://base.fims.tv":CodecType.
    fims__CodecType*                     videoEncoding                  0;	///< Optional element.
/// @brief Definition of the video tracks in the source.
/// Vector of fims__BMTrackType* with length 0..unbounded
    std::vector<fims__BMTrackType*     > videoTrack                     0;
/// @brief Number of bits at which the video is encoded, measured in bits per second.
/// Element bitRate of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             bitRate                        0;	///< Optional element.
/// @brief Type of bitrate, either constant or variable.
/// Element bitRateMode of type "http://base.fims.tv":BitRateModeType.
    enum fims__BitRateModeType*          bitRateMode                    0;	///< Optional element.
/// @brief Number of scanning lines in the image, also known as resolution height. For example, 1080, 720, 576 etc..
/// Element lines of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             lines                          0;	///< Optional element.
/// @brief Whether the image is presented using interlaced or progressive scanning.
/// Element scanningFormat of type "http://base.fims.tv":ScanningFormatType.
    enum fims__ScanningFormatType*       scanningFormat                 0;	///< Optional element.
/// @brief Whether the fields are ordered top (upper) or bottom (lower) field first in video stream encoding order.
/// Element scanningOrder of type "http://base.fims.tv":ScanningOrderType.
    enum fims__ScanningOrderType*        scanningOrder                  0;	///< Optional element.
/// @brief Whether noise was removed from the signal.
/// Element noiseFilter of type xs:boolean.
    bool*                                noiseFilter                    0;	///< Optional element.
};

/// "http://base.fims.tv":AudioFormatType is a complexType with complexContent extension of "http://base.fims.tv":FormatType.
/// @brief Characteristics of an audio signal. See 'audioFormat' in EBU Tech 3293 for more information.
/// class fims__AudioFormatType operations:
/// - soap_new_fims__AudioFormatType(soap*) allocate
/// - soap_new_fims__AudioFormatType(soap*, int num) allocate array
/// - soap_new_req_fims__AudioFormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__AudioFormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__AudioFormatType(soap*, fims__AudioFormatType*) deserialize from a stream
/// - int soap_write_fims__AudioFormatType(soap, fims__AudioFormatType*) serialize to a stream
class fims__AudioFormatType : public fims__FormatType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/*  INHERITED FROM fims__FormatType:
/// @brief User defined technical attributes. See 'technical attribute' in EBU Tech 3293 for more information.
/// Vector of fims__TechnicalAttributeType* with length 0..unbounded
    std::vector<fims__TechnicalAttributeType*> technicalAttribute             0;
    END OF INHERITED FROM fims__FormatType */
/// @brief Audio sampling rate that defines the number of samples per second taken from the continuous audio signal, and it is expressed in Hertz.
/// Element samplingRate of type xs:decimal.
    xsd__decimal*                        samplingRate                   0;	///< Optional element.
/// @brief Defines the audio compression format of the resource (e.g. AAC) for an audio channel.
/// Element audioEncoding of type "http://base.fims.tv":CodecType.
    fims__CodecType*                     audioEncoding                  0;	///< Optional element.
/// @brief Defines the audio track configuration that expresses the arrangement or audio tracks e.g. 'stereo', '2+1', 'surround', 'surround (7+1)' etc..
/// class _fims__AudioFormatType_trackConfiguration operations:
/// - soap_new__fims__AudioFormatType_trackConfiguration(soap*) allocate
/// - soap_new__fims__AudioFormatType_trackConfiguration(soap*, int num) allocate array
/// - soap_new_req__fims__AudioFormatType_trackConfiguration(soap*, ...) allocate, set required members
/// - soap_new_set__fims__AudioFormatType_trackConfiguration(soap*, ...) allocate, set all public members
/// - int soap_read__fims__AudioFormatType_trackConfiguration(soap*, _fims__AudioFormatType_trackConfiguration*) deserialize from a stream
/// - int soap_write__fims__AudioFormatType_trackConfiguration(soap, _fims__AudioFormatType_trackConfiguration*) serialize to a stream
    class _fims__AudioFormatType_trackConfiguration
    {
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *trackConfiguration             0;	///< Optional element.
/// @brief Definition of audio tracks in the source.
/// Vector of fims__BMTrackType* with length 0..unbounded
    std::vector<fims__BMTrackType*     > audioTrack                     0;
/// @brief Number of channels used for the source recording.
/// Element channels of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             channels                       0;	///< Optional element.
/// @brief Number of bits at which the audio is encoded, measured in bits per second.
/// Element bitRate of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             bitRate                        0;	///< Optional element.
/// @brief Type of bitrate, either constant or variable.
/// Element bitRateMode of type "http://base.fims.tv":BitRateModeType.
    enum fims__BitRateModeType*          bitRateMode                    0;	///< Optional element.
/// @brief Sample size for the recording, e.g. 16- or 24-bits per sample.
/// Element sampleSize of type xs:nonNegativeInteger.
    xsd__nonNegativeInteger*             sampleSize                     0;	///< Optional element.
/// @brief Whether the samples are represented as integer or floating point values.
/// Element sampleType of type "http://base.fims.tv":AudioSampleType.
    enum fims__AudioSampleType*          sampleType                     0;	///< Optional element.
};

/// "http://base.fims.tv":DataFormatType is a complexType with complexContent extension of "http://base.fims.tv":FormatType.
/// @brief Characteristics of a data signal, used to carry captioning or ancillary data.
/// class fims__DataFormatType operations:
/// - soap_new_fims__DataFormatType(soap*) allocate
/// - soap_new_fims__DataFormatType(soap*, int num) allocate array
/// - soap_new_req_fims__DataFormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__DataFormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__DataFormatType(soap*, fims__DataFormatType*) deserialize from a stream
/// - int soap_write_fims__DataFormatType(soap, fims__DataFormatType*) serialize to a stream
class fims__DataFormatType : public fims__FormatType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/*  INHERITED FROM fims__FormatType:
/// @brief User defined technical attributes. See 'technical attribute' in EBU Tech 3293 for more information.
/// Vector of fims__TechnicalAttributeType* with length 0..unbounded
    std::vector<fims__TechnicalAttributeType*> technicalAttribute             0;
    END OF INHERITED FROM fims__FormatType */
/// @brief Where captioning data is present, describes the captioning formats and their purpose.
/// Vector of fims__CaptioningFormatType* with length 0..unbounded
    std::vector<fims__CaptioningFormatType*> captioningFormat               0;
/// @brief Where ancillary data is present, describes the captioning formats and their purpose.
/// Vector of fims__AncillaryDataFormatType* with length 0..unbounded
    std::vector<fims__AncillaryDataFormatType*> ancillaryDataFormat            0;
};

/// "http://base.fims.tv":ContainerFormatType is a complexType with complexContent extension of "http://base.fims.tv":FormatType.
/// @brief Container/wrapper format that is used in complement to the streams encoding, for example MXF, wave, Quicktime, etc.. See 'fileFormat' in EBU Tech 3293 for more information.
/// class fims__ContainerFormatType operations:
/// - soap_new_fims__ContainerFormatType(soap*) allocate
/// - soap_new_fims__ContainerFormatType(soap*, int num) allocate array
/// - soap_new_req_fims__ContainerFormatType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ContainerFormatType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ContainerFormatType(soap*, fims__ContainerFormatType*) deserialize from a stream
/// - int soap_write_fims__ContainerFormatType(soap, fims__ContainerFormatType*) serialize to a stream
class fims__ContainerFormatType : public fims__FormatType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/*  INHERITED FROM fims__FormatType:
/// @brief User defined technical attributes. See 'technical attribute' in EBU Tech 3293 for more information.
/// Vector of fims__TechnicalAttributeType* with length 0..unbounded
    std::vector<fims__TechnicalAttributeType*> technicalAttribute             0;
    END OF INHERITED FROM fims__FormatType */
/// @brief Defines the file format for the data. See 'fileFormat' in EBU Tech 3293 for more information.
/// class _fims__ContainerFormatType_containerFormat operations:
/// - soap_new__fims__ContainerFormatType_containerFormat(soap*) allocate
/// - soap_new__fims__ContainerFormatType_containerFormat(soap*, int num) allocate array
/// - soap_new_req__fims__ContainerFormatType_containerFormat(soap*, ...) allocate, set required members
/// - soap_new_set__fims__ContainerFormatType_containerFormat(soap*, ...) allocate, set all public members
/// - int soap_read__fims__ContainerFormatType_containerFormat(soap*, _fims__ContainerFormatType_containerFormat*) deserialize from a stream
/// - int soap_write__fims__ContainerFormatType_containerFormat(soap, _fims__ContainerFormatType_containerFormat*) serialize to a stream
    class _fims__ContainerFormatType_containerFormat
    {
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup formatGroup.
/// @brief Free text field. See EBU Tech 3293 for more information.
/// Attribute formatLabel of type xs:string.
   @std::wstring*                        formatLabel                    0;	///< Optional attribute.
/// @brief An optional definition. See EBU Tech 3293 for more information.
/// Attribute formatDefinition of type xs:string.
   @std::wstring*                        formatDefinition               0;	///< Optional attribute.
/// @brief A link to a term or identification of a classification scheme. See EBU Tech 3293 for more information.
/// Attribute formatLink of type xs:anyURI.
   @xsd__anyURI*                         formatLink                     0;	///< Optional attribute.
/// End of attributeGroup formatGroup.
    }                                   *containerFormat                0;	///< Optional element.
};

/// "http://base.fims.tv":SimpleFileLocatorType is a complexType with complexContent extension of "http://base.fims.tv":BMEssenceLocatorType.
/// @brief Location of essence represented by a single file
/// class fims__SimpleFileLocatorType operations:
/// - soap_new_fims__SimpleFileLocatorType(soap*) allocate
/// - soap_new_fims__SimpleFileLocatorType(soap*, int num) allocate array
/// - soap_new_req_fims__SimpleFileLocatorType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__SimpleFileLocatorType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__SimpleFileLocatorType(soap*, fims__SimpleFileLocatorType*) deserialize from a stream
/// - int soap_write_fims__SimpleFileLocatorType(soap, fims__SimpleFileLocatorType*) serialize to a stream
class fims__SimpleFileLocatorType : public fims__BMEssenceLocatorType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/*  INHERITED FROM fims__BMEssenceLocatorType:
/// @brief Kind of storage for the essence, for example "online" or "hsm".
/// Element storageType of type "http://base.fims.tv":StorageType.
    fims__StorageType*                   storageType                    0;	///< Optional element.
/// @brief Describes the geographical location of the content, for example "New York".
/// Element locatorInfo of type xs:string.
    std::wstring*                        locatorInfo                    0;	///< Optional element.
/// @brief Multipurpose Internet Mail Extensions Media Type for the physical container used for the representation. Vendors are encouraged to register MIME types for the containers in use, such as a folder containing capture data from a camera. Where additional structural data is required, vendors are encouraged to extend one of the essence locator types (single file, list, folder).
/// class _fims__SimpleFileLocatorType_containerMimeType operations:
/// - soap_new__fims__SimpleFileLocatorType_containerMimeType(soap*) allocate
/// - soap_new__fims__SimpleFileLocatorType_containerMimeType(soap*, int num) allocate array
/// - soap_new_req__fims__SimpleFileLocatorType_containerMimeType(soap*, ...) allocate, set required members
/// - soap_new_set__fims__SimpleFileLocatorType_containerMimeType(soap*, ...) allocate, set all public members
/// - int soap_read__fims__SimpleFileLocatorType_containerMimeType(soap*, _fims__SimpleFileLocatorType_containerMimeType*) deserialize from a stream
/// - int soap_write__fims__SimpleFileLocatorType_containerMimeType(soap, _fims__SimpleFileLocatorType_containerMimeType*) serialize to a stream
    class _fims__SimpleFileLocatorType_containerMimeType
    {
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *containerMimeType              0;	///< Optional element.
    END OF INHERITED FROM fims__BMEssenceLocatorType */
/// @brief Location of the essence-containing single file, such as an MXF OP-1a file.
/// Element file of type xs:anyURI.
    xsd__anyURI*                         file                           0;	///< Optional element.
};

/// "http://base.fims.tv":ListFileLocatorType is a complexType with complexContent extension of "http://base.fims.tv":BMEssenceLocatorType.
/// @brief Location of essence represented by a list of files that represent a single rendition of the content.
/// class fims__ListFileLocatorType operations:
/// - soap_new_fims__ListFileLocatorType(soap*) allocate
/// - soap_new_fims__ListFileLocatorType(soap*, int num) allocate array
/// - soap_new_req_fims__ListFileLocatorType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__ListFileLocatorType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__ListFileLocatorType(soap*, fims__ListFileLocatorType*) deserialize from a stream
/// - int soap_write_fims__ListFileLocatorType(soap, fims__ListFileLocatorType*) serialize to a stream
class fims__ListFileLocatorType : public fims__BMEssenceLocatorType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/*  INHERITED FROM fims__BMEssenceLocatorType:
/// @brief Kind of storage for the essence, for example "online" or "hsm".
/// Element storageType of type "http://base.fims.tv":StorageType.
    fims__StorageType*                   storageType                    0;	///< Optional element.
/// @brief Describes the geographical location of the content, for example "New York".
/// Element locatorInfo of type xs:string.
    std::wstring*                        locatorInfo                    0;	///< Optional element.
/// @brief Multipurpose Internet Mail Extensions Media Type for the physical container used for the representation. Vendors are encouraged to register MIME types for the containers in use, such as a folder containing capture data from a camera. Where additional structural data is required, vendors are encouraged to extend one of the essence locator types (single file, list, folder).
/// class _fims__ListFileLocatorType_containerMimeType operations:
/// - soap_new__fims__ListFileLocatorType_containerMimeType(soap*) allocate
/// - soap_new__fims__ListFileLocatorType_containerMimeType(soap*, int num) allocate array
/// - soap_new_req__fims__ListFileLocatorType_containerMimeType(soap*, ...) allocate, set required members
/// - soap_new_set__fims__ListFileLocatorType_containerMimeType(soap*, ...) allocate, set all public members
/// - int soap_read__fims__ListFileLocatorType_containerMimeType(soap*, _fims__ListFileLocatorType_containerMimeType*) deserialize from a stream
/// - int soap_write__fims__ListFileLocatorType_containerMimeType(soap, _fims__ListFileLocatorType_containerMimeType*) serialize to a stream
    class _fims__ListFileLocatorType_containerMimeType
    {
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *containerMimeType              0;	///< Optional element.
    END OF INHERITED FROM fims__BMEssenceLocatorType */
/// @brief List of a collection of files that, taken together, represent an essence location. Note that the files are not necessarily stored in the folder, on the same disk resource or even on the same server.
/// Vector of xsd__anyURI with length 0..unbounded
    std::vector<xsd__anyURI            > file                           0;
};

/// "http://base.fims.tv":FolderLocatorType is a complexType with complexContent extension of "http://base.fims.tv":BMEssenceLocatorType.
/// @brief Root of a folder structure that, taken as a whole including its children, represents an essence location that stores the rendition of the content described by the parent content format.
/// class fims__FolderLocatorType operations:
/// - soap_new_fims__FolderLocatorType(soap*) allocate
/// - soap_new_fims__FolderLocatorType(soap*, int num) allocate array
/// - soap_new_req_fims__FolderLocatorType(soap*, ...) allocate, set required members
/// - soap_new_set_fims__FolderLocatorType(soap*, ...) allocate, set all public members
/// - int soap_read_fims__FolderLocatorType(soap*, fims__FolderLocatorType*) deserialize from a stream
/// - int soap_write_fims__FolderLocatorType(soap, fims__FolderLocatorType*) serialize to a stream
class fims__FolderLocatorType : public fims__BMEssenceLocatorType
{ public:
/*  INHERITED FROM fims__ResourceReferenceType:
/// @brief Locally distinct identifier for the resource that can be used to make reference to the resource. The reference may also be globally unique.
/// Element resourceID of type "http://base.fims.tv":ResourceIDType.
    fims__ResourceIDType                 resourceID                     1;	///< Required element.
/// @brief Identifier for the specific revision of the resource. Tracking the different versions of resources across systems enables different instances and versions of a resource to coexist at different locations and updated to be eventually consistent according to local policy.
/// Element revisionID of type "http://base.fims.tv":RevisionIDType.
    fims__RevisionIDType*                revisionID                     0;	///< Optional element.
/// @brief A Uniform Resource Location that points to a specific instance of a resource at a location.
/// Element location of type xs:anyURI.
    xsd__anyURI*                         location                       0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceReferenceType */
/*  INHERITED FROM fims__ResourceType:
/// @brief Date and time when this resource was created.
/// Element resourceCreationDate of type xs:dateTime.
    time_t*                              resourceCreationDate           0;	///< Optional element.
/// @brief Date and time when this resource was last modified. Modification date of the resource should be updated when any of the values of the resource's properties are updated.
/// Element resourceModifiedDate of type xs:dateTime.
    time_t*                              resourceModifiedDate           0;	///< Optional element.
/// @brief Endpoints where a service can send back a notification for a job completed or failed.
/// Element notifyAt of type "http://base.fims.tv":AsyncEndpointType.
    fims__AsyncEndpointType*             notifyAt                       0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionGroup of type "http://base.fims.tv":ExtensionGroup.
    fims__ExtensionGroup*                ExtensionGroup                 0;	///< Optional element.
/// @brief Extension point.
/// Element ExtensionAttributes of type "http://base.fims.tv":ExtensionAttributes.
    fims__ExtensionAttributes*           ExtensionAttributes            0;	///< Optional element.
    END OF INHERITED FROM fims__ResourceType */
/*  INHERITED FROM fims__BMEssenceLocatorType:
/// @brief Kind of storage for the essence, for example "online" or "hsm".
/// Element storageType of type "http://base.fims.tv":StorageType.
    fims__StorageType*                   storageType                    0;	///< Optional element.
/// @brief Describes the geographical location of the content, for example "New York".
/// Element locatorInfo of type xs:string.
    std::wstring*                        locatorInfo                    0;	///< Optional element.
/// @brief Multipurpose Internet Mail Extensions Media Type for the physical container used for the representation. Vendors are encouraged to register MIME types for the containers in use, such as a folder containing capture data from a camera. Where additional structural data is required, vendors are encouraged to extend one of the essence locator types (single file, list, folder).
/// class _fims__FolderLocatorType_containerMimeType operations:
/// - soap_new__fims__FolderLocatorType_containerMimeType(soap*) allocate
/// - soap_new__fims__FolderLocatorType_containerMimeType(soap*, int num) allocate array
/// - soap_new_req__fims__FolderLocatorType_containerMimeType(soap*, ...) allocate, set required members
/// - soap_new_set__fims__FolderLocatorType_containerMimeType(soap*, ...) allocate, set all public members
/// - int soap_read__fims__FolderLocatorType_containerMimeType(soap*, _fims__FolderLocatorType_containerMimeType*) deserialize from a stream
/// - int soap_write__fims__FolderLocatorType_containerMimeType(soap, _fims__FolderLocatorType_containerMimeType*) serialize to a stream
    class _fims__FolderLocatorType_containerMimeType
    {
/// __item wraps 'xs:string' simpleContent.
    std::wstring                         __item                        ;
/// Begin attributeGroup typeGroup.
/// @brief Free text. Example: H264 Main Profile @ Level 1. See EBU Tech 3293 for more information.
/// Attribute typeLabel of type xs:string.
   @std::wstring*                        typeLabel                      0;	///< Optional attribute.
/// @brief Free text for an optional definition. Example: the video compression scheme H264, main profile, level1 as specified by ISO/IEC. See EBU Tech 3293 for more information.
/// Attribute typeDefinition of type xs:string.
   @std::wstring*                        typeDefinition                 0;	///< Optional attribute.
/// @brief Link to a classification scheme. See EBU Tech 3293 for more information.
/// Attribute typeLink of type xs:anyURI.
   @xsd__anyURI*                         typeLink                       0;	///< Optional attribute.
/// End of attributeGroup typeGroup.
    }                                   *containerMimeType              0;	///< Optional element.
    END OF INHERITED FROM fims__BMEssenceLocatorType */
/// @brief Root of a folder structure where the root and its children are an essence representation.
/// Element folder of type xs:anyURI.
    xsd__anyURI*                         folder                         0;	///< Optional element.
};

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://temp/edlprovider                                                  *
 *                                                                            *
\******************************************************************************/


/// Top-level root element "http://temp/edlprovider":installedEdlsResponse of type "http://temp/edlprovider":ArrayOfstring.
/// @brief This element provides the list of edl types in the service.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://temp/edlprovider":getEdlRequest of type "http://temp/edlprovider":EdlCreateRequestType.
/// @brief This element represents the request made to create an EDL.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://temp/edlprovider":getEdlDoubleRequest of type "http://temp/edlprovider":EdlCreateRequestDoubleType.
/// @brief This element represents the request made to create an EDL using a frame rate represented in floating point.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://temp/edlprovider":getEdlResponse of type "http://temp/edlprovider":EdlCreateResponseType.
/// @brief This element represents the response when a EDL is created, containing the EDL contents.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://temp/edlprovider":edlProviderFault of type "http://temp/edlprovider":EdlProviderFaultType.
/// @brief This element represents the a fault that migh occur when requesting EDL's from the service.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://temp/edlprovider                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://base.fims.tv                                                      *
 *                                                                            *
\******************************************************************************/


/// Top-level root element "http://base.fims.tv":manageJobRequest of type "http://base.fims.tv":ManageJobRequestType.
/// @brief This element allows to submit jobs management requests, such as getting the status or pausing a job.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":manageJobResponse of type "http://base.fims.tv":ManageJobResponseType.
/// @brief This element provides the response to job management requests, which includes the current status of the job.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":manageQueueRequest of type "http://base.fims.tv":ManageQueueRequestType.
/// @brief This element allows to submit queue management requests, such as getting the status or locking a queue.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":manageQueueResponse of type "http://base.fims.tv":ManageQueueResponseType.
/// @brief This element provides the response to queue management requests, which includes the status and length of the queue.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":queryJobRequest of type "http://base.fims.tv":QueryJobRequestType.
/// @brief This element is used to request the list of jobs in a queue.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":queryJobResponse of type "http://base.fims.tv":QueryJobResponseType.
/// @brief This element provides the list of jobs in a queue.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":queryServiceDescriptionRequest of type "http://base.fims.tv":QueryServiceDescriptionRequestType.
/// @brief This element is used to request the service capability.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":queryServiceDescriptionResponse of type "http://base.fims.tv":QueryServiceDescriptionResponseType.
/// @brief Provides the requested service capability.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":fault of type "http://base.fims.tv":FaultType.
/// @brief Element used to carry a fault defined in the base schema, as detailed in the "ErrorCodeType" enumeration.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":resource of type "http://base.fims.tv":ResourceType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":resources of type "http://base.fims.tv":ResourcesType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":profile of type "http://base.fims.tv":ProfileType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":profiles of type "http://base.fims.tv":ProfilesType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":service of type "http://base.fims.tv":ServiceType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":services of type "http://base.fims.tv":ServicesType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":queue of type "http://base.fims.tv":QueueType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":queues of type "http://base.fims.tv":QueuesType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":job of type "http://base.fims.tv":JobType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":jobs of type "http://base.fims.tv":JobsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":videoFormat of type "http://base.fims.tv":VideoFormatType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":videoFormats of type "http://base.fims.tv":VideoFormatsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":audioFormat of type "http://base.fims.tv":AudioFormatType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":audioFormats of type "http://base.fims.tv":AudioFormatsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":containerFormat of type "http://base.fims.tv":ContainerFormatType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":containerFormats of type "http://base.fims.tv":ContainerFormatsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":dataFormat of type "http://base.fims.tv":DataFormatType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":dataFormats of type "http://base.fims.tv":DataFormatsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmObject of type "http://base.fims.tv":BMObjectType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmObjects of type "http://base.fims.tv":BMObjectsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmContent of type "http://base.fims.tv":BMContentType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmContents of type "http://base.fims.tv":BMContentsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmContentFormat of type "http://base.fims.tv":BMContentFormatType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmConentFormats of type "http://base.fims.tv":BMContentFormatsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmEssenceLocator of type "http://base.fims.tv":BMEssenceLocatorType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":bmEssenceLocators of type "http://base.fims.tv":BMEssenceLocatorsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":description of type "http://base.fims.tv":DescriptionType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://base.fims.tv":descriptions of type "http://base.fims.tv":DescriptionsType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://base.fims.tv                                                      *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://description.fims.tv                                               *
 *                                                                            *
\******************************************************************************/


/// Top-level root element "http://description.fims.tv":bmContentDescription of type "http://description.fims.tv":bmContentDescriptionType.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://description.fims.tv                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Services                                                                   *
 *                                                                            *
\******************************************************************************/

// This service supports SOAP 1.2 namespaces:
#import "soap12.h"

//gsoap edlprovider service name:	EdlProviderBinding 
//gsoap edlprovider service type:	EdlProviderService 
//gsoap edlprovider service port:	http://host/path/EDLProviderPort 
//gsoap edlprovider service namespace:	http://temp/edlprovider 
//gsoap edlprovider service transport:	http://schemas.xmlsoap.org/soap/http 

/** @mainpage EDLProvider Definitions

@section EDLProvider_bindings Service Bindings

  - @ref EdlProviderBinding

@section EDLProvider_more More Information

  - @ref page_notes "Usage Notes"

  - @ref page_XMLDataBinding "XML Data Binding"

  - @ref SOAP_ENV__Header "SOAP Header Content" (when applicable)

  - @ref SOAP_ENV__Detail "SOAP Fault Detail Content" (when applicable)


*/

/**

@page EdlProviderBinding Binding "EdlProviderBinding"

@section EdlProviderBinding_operations Operations of Binding  "EdlProviderBinding"

  - @ref __edlprovider__getInstalledEdls

  - @ref __edlprovider__getEdl

  - @ref __edlprovider__getEdlDouble

@section EdlProviderBinding_ports Endpoints of Binding  "EdlProviderBinding"

  - http://host/path/EDLProviderPort

Note: use wsdl2h option -Nname to change the service binding prefix name


*/

/******************************************************************************\
 *                                                                            *
 * SOAP Fault Detail                                                          *
 *                                                                            *
\******************************************************************************/

/**

The SOAP Fault is part of the gSOAP context and its content is accessed
through the soap.fault->detail variable (SOAP 1.1) or the
soap.fault->SOAP_ENV__Detail variable (SOAP 1.2).
Use wsdl2h option -j to omit these declarations.

*/
struct SOAP_ENV__Detail
{
// xsd:anyAttribute omitted: to parse attribute content of the Detail element into DOM anyAttribute, use wsdl2h option -d.
    _XML                                 __any                         ;	///< Catch any element content in XML string.
    edlprovider__EdlProviderFaultType*   edlprovider__edlProviderFault ;
///< SOAP Fault element ""http://temp/edlprovider":edlProviderFault" part "fault"
    int                                  __type                        ;	///< set to SOAP_TYPE_X for a serializable type X
    void                                *fault                         ;	///< points to serializable object X or NULL
};

/******************************************************************************\
 *                                                                            *
 * Service Binding                                                            *
 *   EdlProviderBinding                                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __edlprovider__getInstalledEdls                                          *
 *                                                                            *
\******************************************************************************/


/// Operation "__edlprovider__getInstalledEdls" of service binding "EdlProviderBinding"

/**

Operation details:
This operation gets all the edl types available in the service.

  - SOAP document/literal style messaging

  - Action: "http://temp/edlprovider/getInstalledEdls"

  - Addressing input action: "http://temp/edlprovider/getInstalledEdls"

  - Addressing output action: "http://temp/edlprovider/getInstalledEdlsResponse"

  - SOAP Output Fault: "http://temp/edlprovider":edlProviderFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___edlprovider__getInstalledEdls(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // input parameters:
    // output parameters:
    edlprovider__ArrayOfstring*         edlprovider__installedEdlsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __edlprovider__getInstalledEdls(
    struct soap *soap,
    // input parameters:
    // output parameters:
    edlprovider__ArrayOfstring*         edlprovider__installedEdlsResponse
  );
@endcode

C++ proxy class (defined in soapEdlProviderBindingProxy.h):
@code
  class EdlProviderBindingProxy;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapEdlProviderBindingService.h):
@code
  class EdlProviderBindingService;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use service classes;

*/

//gsoap edlprovider service method-protocol:	getInstalledEdls SOAP
//gsoap edlprovider service method-style:	getInstalledEdls document
//gsoap edlprovider service method-encoding:	getInstalledEdls literal
//gsoap edlprovider service method-input-action:	getInstalledEdls http://temp/edlprovider/getInstalledEdls
//gsoap edlprovider service method-output-action:	getInstalledEdls http://temp/edlprovider/getInstalledEdlsResponse
//gsoap edlprovider service method-fault:	getInstalledEdls edlprovider__edlProviderFault
int __edlprovider__getInstalledEdls(
///  out parameter: This message provides the response to getting all the edl types available in the service.
    edlprovider__ArrayOfstring*         edlprovider__installedEdlsResponse	///< Output parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __edlprovider__getEdl                                                    *
 *                                                                            *
\******************************************************************************/


/// Operation "__edlprovider__getEdl" of service binding "EdlProviderBinding"

/**

Operation details:
This operation gets all the edl types available in the service.

  - SOAP document/literal style messaging

  - Action: "http://temp/edlprovider/getEdl"

  - Addressing input action: "http://temp/edlprovider/getEdl"

  - Addressing output action: "http://temp/edlprovider/getEdlResponse"

  - SOAP Output Fault: "http://temp/edlprovider":edlProviderFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___edlprovider__getEdl(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // input parameters:
    edlprovider__EdlCreateRequestType*  edlprovider__getEdlRequest,
    // output parameters:
    edlprovider__EdlCreateResponseType* edlprovider__getEdlResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __edlprovider__getEdl(
    struct soap *soap,
    // input parameters:
    edlprovider__EdlCreateRequestType*  edlprovider__getEdlRequest,
    // output parameters:
    edlprovider__EdlCreateResponseType* edlprovider__getEdlResponse
  );
@endcode

C++ proxy class (defined in soapEdlProviderBindingProxy.h):
@code
  class EdlProviderBindingProxy;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapEdlProviderBindingService.h):
@code
  class EdlProviderBindingService;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use service classes;

*/

//gsoap edlprovider service method-protocol:	getEdl SOAP
//gsoap edlprovider service method-style:	getEdl document
//gsoap edlprovider service method-encoding:	getEdl literal
//gsoap edlprovider service method-input-action:	getEdl http://temp/edlprovider/getEdl
//gsoap edlprovider service method-output-action:	getEdl http://temp/edlprovider/getEdlResponse
//gsoap edlprovider service method-fault:	getEdl edlprovider__edlProviderFault
int __edlprovider__getEdl(
///  out parameter: This message represents the request to create an EDL with a specific type.
    edlprovider__EdlCreateRequestType*  edlprovider__getEdlRequest,	///< Input parameter
///  out parameter: This message provides the response to getting an EDL type from the service.
    edlprovider__EdlCreateResponseType* edlprovider__getEdlResponse	///< Output parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __edlprovider__getEdlDouble                                              *
 *                                                                            *
\******************************************************************************/


/// Operation "__edlprovider__getEdlDouble" of service binding "EdlProviderBinding"

/**

Operation details:
This operation gets all the edl types available in the service.

  - SOAP document/literal style messaging

  - Action: "http://temp/edlprovider/getEdlDouble"

  - Addressing input action: "http://temp/edlprovider/getEdlDouble"

  - Addressing output action: "http://temp/edlprovider/getEdlDoubleResponse"

  - SOAP Output Fault: "http://temp/edlprovider":edlProviderFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___edlprovider__getEdlDouble(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // input parameters:
    edlprovider__EdlCreateRequestDoubleType* edlprovider__getEdlDoubleRequest,
    // output parameters:
    edlprovider__EdlCreateResponseType* edlprovider__getEdlResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __edlprovider__getEdlDouble(
    struct soap *soap,
    // input parameters:
    edlprovider__EdlCreateRequestDoubleType* edlprovider__getEdlDoubleRequest,
    // output parameters:
    edlprovider__EdlCreateResponseType* edlprovider__getEdlResponse
  );
@endcode

C++ proxy class (defined in soapEdlProviderBindingProxy.h):
@code
  class EdlProviderBindingProxy;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapEdlProviderBindingService.h):
@code
  class EdlProviderBindingService;
@endcode
Important: use soapcpp2 option '-j' (or '-i') to generate greatly improved and easy-to-use service classes;

*/

//gsoap edlprovider service method-protocol:	getEdlDouble SOAP
//gsoap edlprovider service method-style:	getEdlDouble document
//gsoap edlprovider service method-encoding:	getEdlDouble literal
//gsoap edlprovider service method-input-action:	getEdlDouble http://temp/edlprovider/getEdlDouble
//gsoap edlprovider service method-output-action:	getEdlDouble http://temp/edlprovider/getEdlDoubleResponse
//gsoap edlprovider service method-fault:	getEdlDouble edlprovider__edlProviderFault
int __edlprovider__getEdlDouble(
///  out parameter: This message represents the request to create an EDL with a specific type.
    edlprovider__EdlCreateRequestDoubleType* edlprovider__getEdlDoubleRequest,	///< Input parameter
///  out parameter: This message provides the response to getting an EDL type from the service.
    edlprovider__EdlCreateResponseType* edlprovider__getEdlResponse	///< Output parameter
);

/**

@page EdlProviderBinding Binding "EdlProviderBinding"

@section EdlProviderBinding_policy_enablers Policy Enablers of Binding  "EdlProviderBinding"

Based on policies, this service imports

  - WS-Policy reminders and enablers:
    - WS-Addressing 1.0 (2005/08, accepts 2004/08):
	@code
	#import "wsa5.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsaapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	// See the user guide gsoap/doc/wsa/html/index.html
	@endcode
    - WS-Addressing (2004/08):
	@code
	#import "wsa.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsaapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	// See the user guide gsoap/doc/wsa/html/index.html
	@endcode
    - WS-ReliableMessaging 1.0:
	@code
	#import "wsrm5.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsrmapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	soap_register_plugin(soap, soap_wsrm); // register the wsrm plugin in your code
	// See the user guide gsoap/doc/wsrm/html/index.html
	@endcode
    - WS-ReliableMessaging 1.1:
	@code
	#import "wsrm.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsrmapi.h"
	soap_register_plugin(soap, soap_wsa); // register the wsa plugin in your code
	soap_register_plugin(soap, soap_wsrm); // register the wsrm plugin in your code
	// See the user guide gsoap/doc/wsrm/html/index.html
	@endcode
    - WS-Security (SOAP Message Security) 1.0 (accepts 1.1):
	@code
	#import "wsse.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsseapi.h"
	soap_register_plugin(soap, soap_wsse); // register the wsse plugin in your code
	// See the user guide gsoap/doc/wsse/html/index.html
	@endcode
    - WS-Security (SOAP Message Security) 1.1 (accepts 1.0):
	@code
	#import "wsse11.h" // to be added to this header file for the soapcpp2 build step
	@endcode
	@code
	#include "plugin/wsseapi.h"
	soap_register_plugin(soap, soap_wsse); // register the wsse plugin in your code
	// See the user guide gsoap/doc/wsse/html/index.html
	@endcode
    - HTTP Digest Authentication:
	@code
	#include "plugin/httpda.h"
	soap_register_plugin(soap, soap_http_da); // register the HTTP DA plugin in your code
	// See the user guide gsoap/doc/httpda/html/index.html
	@endcode
*/


/******************************************************************************\
 *                                                                            *
 * XML Data Binding                                                           *
 *                                                                            *
\******************************************************************************/


/**

@page page_XMLDataBinding XML Data Binding

SOAP/XML services use data bindings contractually bound by WSDL and auto-
generated by wsdl2h and soapcpp2 (see Service Bindings). Plain data bindings
are adopted from XML schemas as part of the WSDL types section or when running
wsdl2h on a set of schemas to produce non-SOAP-based XML data bindings.

The following readers and writers are C/C++ data type (de)serializers auto-
generated by wsdl2h and soapcpp2. Run soapcpp2 on this file to generate the
(de)serialization code, which is stored in soapC.c[pp]. Include "soapH.h" in
your code to import these data type and function declarations. Only use the
soapcpp2-generated files in your project build. Do not include the wsdl2h-
generated .h file in your code.

Data can be read in XML and deserialized from:
  - a file descriptor, using soap->recvfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->is = ...
  - a buffer, using the soap->frecv() callback

Data can be serialized in XML and written to:
  - a file descriptor, using soap->sendfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->os = ...
  - a buffer, using the soap->fsend() callback

The following options are available for (de)serialization control:
  - soap->encodingStyle = NULL; to remove SOAP 1.1/1.2 encodingStyle
  - soap_mode(soap, SOAP_XML_TREE); XML without id-ref (no cycles!)
  - soap_mode(soap, SOAP_XML_GRAPH); XML with id-ref (including cycles)
  - soap_set_namespaces(soap, struct Namespace *nsmap); to set xmlns bindings


@section edlprovider Top-level root elements of schema "http://temp/edlprovider"

  - <edlprovider:installedEdlsResponse> (use wsdl2h option -g to auto-generate)

  - <edlprovider:getEdlRequest> (use wsdl2h option -g to auto-generate)

  - <edlprovider:getEdlDoubleRequest> (use wsdl2h option -g to auto-generate)

  - <edlprovider:getEdlResponse> (use wsdl2h option -g to auto-generate)

  - <edlprovider:edlProviderFault> (use wsdl2h option -g to auto-generate)

@section fims Top-level root elements of schema "http://base.fims.tv"

  - <fims:manageJobRequest> (use wsdl2h option -g to auto-generate)

  - <fims:manageJobResponse> (use wsdl2h option -g to auto-generate)

  - <fims:manageQueueRequest> (use wsdl2h option -g to auto-generate)

  - <fims:manageQueueResponse> (use wsdl2h option -g to auto-generate)

  - <fims:queryJobRequest> (use wsdl2h option -g to auto-generate)

  - <fims:queryJobResponse> (use wsdl2h option -g to auto-generate)

  - <fims:queryServiceDescriptionRequest> (use wsdl2h option -g to auto-generate)

  - <fims:queryServiceDescriptionResponse> (use wsdl2h option -g to auto-generate)

  - <fims:fault> (use wsdl2h option -g to auto-generate)

  - <fims:resource> (use wsdl2h option -g to auto-generate)

  - <fims:resources> (use wsdl2h option -g to auto-generate)

  - <fims:profile> (use wsdl2h option -g to auto-generate)

  - <fims:profiles> (use wsdl2h option -g to auto-generate)

  - <fims:service> (use wsdl2h option -g to auto-generate)

  - <fims:services> (use wsdl2h option -g to auto-generate)

  - <fims:queue> (use wsdl2h option -g to auto-generate)

  - <fims:queues> (use wsdl2h option -g to auto-generate)

  - <fims:job> (use wsdl2h option -g to auto-generate)

  - <fims:jobs> (use wsdl2h option -g to auto-generate)

  - <fims:formatCollection> @ref _fims__formatCollection
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__fims__formatCollection(struct soap*, _fims__formatCollection*);
    // Writer (returns SOAP_OK on success):
    soap_write__fims__formatCollection(struct soap*, _fims__formatCollection*);
    @endcode

  - <fims:videoFormat> (use wsdl2h option -g to auto-generate)

  - <fims:videoFormats> (use wsdl2h option -g to auto-generate)

  - <fims:audioFormat> (use wsdl2h option -g to auto-generate)

  - <fims:audioFormats> (use wsdl2h option -g to auto-generate)

  - <fims:containerFormat> (use wsdl2h option -g to auto-generate)

  - <fims:containerFormats> (use wsdl2h option -g to auto-generate)

  - <fims:dataFormat> (use wsdl2h option -g to auto-generate)

  - <fims:dataFormats> (use wsdl2h option -g to auto-generate)

  - <fims:bmObject> (use wsdl2h option -g to auto-generate)

  - <fims:bmObjects> (use wsdl2h option -g to auto-generate)

  - <fims:bmContent> (use wsdl2h option -g to auto-generate)

  - <fims:bmContents> (use wsdl2h option -g to auto-generate)

  - <fims:bmContentFormat> (use wsdl2h option -g to auto-generate)

  - <fims:bmConentFormats> (use wsdl2h option -g to auto-generate)

  - <fims:bmEssenceLocator> (use wsdl2h option -g to auto-generate)

  - <fims:bmEssenceLocators> (use wsdl2h option -g to auto-generate)

  - <fims:description> (use wsdl2h option -g to auto-generate)

  - <fims:descriptions> (use wsdl2h option -g to auto-generate)

@section fimsdescription Top-level root elements of schema "http://description.fims.tv"

  - <fimsdescription:bmContentDescription> (use wsdl2h option -g to auto-generate)

*/

/* End of D:\Sandbox\EdlProvider\Soap\gsoap\src\EDLProviderInterface.h */

/* EDLProviderStub.h
   Generated by gSOAP 2.8.17r from D:\Sandbox\EdlProvider\Soap\gsoap\src\EDLProviderInterface.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef EDLProviderStub_H
#define EDLProviderStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_edlprovider	"http://temp/edlprovider"
#define SOAP_NAMESPACE_OF_fims	"http://base.fims.tv"
#define SOAP_NAMESPACE_OF_fimsdescription	"http://description.fims.tv"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20817
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_edlprovider__EdlProviderErrorCodeType
#define SOAP_TYPE_edlprovider__EdlProviderErrorCodeType (141)
/* edlprovider:EdlProviderErrorCodeType */
enum edlprovider__EdlProviderErrorCodeType { edlprovider__EdlProviderErrorCodeType__EXT_USCORES00_USCORE0001 = 0 };
#endif

#ifndef SOAP_TYPE_fims__QueueStatusType
#define SOAP_TYPE_fims__QueueStatusType (150)
/* fims:QueueStatusType */
enum fims__QueueStatusType { fims__QueueStatusType__started = 0, fims__QueueStatusType__stopped = 1, fims__QueueStatusType__locked = 2 };
#endif

#ifndef SOAP_TYPE_fims__PriorityType
#define SOAP_TYPE_fims__PriorityType (151)
/* fims:PriorityType */
enum fims__PriorityType { fims__PriorityType__low = 0, fims__PriorityType__medium = 1, fims__PriorityType__high = 2, fims__PriorityType__urgent = 3, fims__PriorityType__immediate = 4 };
#endif

#ifndef SOAP_TYPE_fims__StorageTypes
#define SOAP_TYPE_fims__StorageTypes (152)
/* fims:StorageTypes */
enum fims__StorageTypes { fims__StorageTypes__online = 0, fims__StorageTypes__offline = 1, fims__StorageTypes__hsm = 2, fims__StorageTypes__archive = 3, fims__StorageTypes__playout = 4, fims__StorageTypes__other = 5 };
#endif

#ifndef SOAP_TYPE_fims__QueueCommandType
#define SOAP_TYPE_fims__QueueCommandType (153)
/* fims:QueueCommandType */
enum fims__QueueCommandType { fims__QueueCommandType__status = 0, fims__QueueCommandType__clear = 1, fims__QueueCommandType__stop = 2, fims__QueueCommandType__start = 3, fims__QueueCommandType__lock = 4, fims__QueueCommandType__unlock = 5 };
#endif

#ifndef SOAP_TYPE_fims__JobCommandType
#define SOAP_TYPE_fims__JobCommandType (154)
/* fims:JobCommandType */
enum fims__JobCommandType { fims__JobCommandType__cancel = 0, fims__JobCommandType__pause = 1, fims__JobCommandType__resume = 2, fims__JobCommandType__restart = 3, fims__JobCommandType__stop = 4, fims__JobCommandType__cleanup = 5, fims__JobCommandType__modifyPriority = 6 };
#endif

#ifndef SOAP_TYPE_fims__HashFunctionTypes
#define SOAP_TYPE_fims__HashFunctionTypes (155)
/* fims:HashFunctionTypes */
enum fims__HashFunctionTypes { fims__HashFunctionTypes__CRC32 = 0, fims__HashFunctionTypes__CRC64 = 1, fims__HashFunctionTypes__MD5 = 2, fims__HashFunctionTypes__SHA1 = 3, fims__HashFunctionTypes__SHA256 = 4, fims__HashFunctionTypes__SHA384 = 5, fims__HashFunctionTypes__SHA512 = 6 };
#endif

#ifndef SOAP_TYPE_fims__JobStatusType
#define SOAP_TYPE_fims__JobStatusType (156)
/* fims:JobStatusType */
enum fims__JobStatusType { fims__JobStatusType__queued = 0, fims__JobStatusType__running = 1, fims__JobStatusType__paused = 2, fims__JobStatusType__completed = 3, fims__JobStatusType__canceled = 4, fims__JobStatusType__stopped = 5, fims__JobStatusType__failed = 6, fims__JobStatusType__cleaned = 7, fims__JobStatusType__unknown = 8 };
#endif

#ifndef SOAP_TYPE_fims__AudioSampleType
#define SOAP_TYPE_fims__AudioSampleType (157)
/* fims:AudioSampleType */
enum fims__AudioSampleType { fims__AudioSampleType__float_ = 0, fims__AudioSampleType__integer = 1 };
#endif

#ifndef SOAP_TYPE_fims__ScanningFormatType
#define SOAP_TYPE_fims__ScanningFormatType (158)
/* fims:ScanningFormatType */
enum fims__ScanningFormatType { fims__ScanningFormatType__interlaced = 0, fims__ScanningFormatType__progressive = 1 };
#endif

#ifndef SOAP_TYPE_fims__ScanningOrderType
#define SOAP_TYPE_fims__ScanningOrderType (159)
/* fims:ScanningOrderType */
enum fims__ScanningOrderType { fims__ScanningOrderType__top = 0, fims__ScanningOrderType__bottom = 1 };
#endif

#ifndef SOAP_TYPE_fims__BitRateModeType
#define SOAP_TYPE_fims__BitRateModeType (160)
/* fims:BitRateModeType */
enum fims__BitRateModeType { fims__BitRateModeType__constant = 0, fims__BitRateModeType__variable = 1 };
#endif

#ifndef SOAP_TYPE_fims__ErrorCodeType
#define SOAP_TYPE_fims__ErrorCodeType (161)
/* fims:ErrorCodeType */
enum fims__ErrorCodeType { fims__ErrorCodeType__INF_USCORES00_USCORE0001 = 0, fims__ErrorCodeType__INF_USCORES00_USCORE0002 = 1, fims__ErrorCodeType__INF_USCORES00_USCORE0003 = 2, fims__ErrorCodeType__INF_USCORES00_USCORE0004 = 3, fims__ErrorCodeType__INF_USCORES00_USCORE0005 = 4, fims__ErrorCodeType__INF_USCORES00_USCORE0006 = 5, fims__ErrorCodeType__SVC_USCORES00_USCORE0001 = 6, fims__ErrorCodeType__SVC_USCORES00_USCORE0002 = 7, fims__ErrorCodeType__SVC_USCORES00_USCORE0003 = 8, fims__ErrorCodeType__SVC_USCORES00_USCORE0004 = 9, fims__ErrorCodeType__SVC_USCORES00_USCORE0005 = 10, fims__ErrorCodeType__SVC_USCORES00_USCORE0006 = 11, fims__ErrorCodeType__SVC_USCORES00_USCORE0007 = 12, fims__ErrorCodeType__SVC_USCORES00_USCORE0008 = 13, fims__ErrorCodeType__SVC_USCORES00_USCORE0009 = 14, fims__ErrorCodeType__SVC_USCORES00_USCORE0010 = 15, fims__ErrorCodeType__SVC_USCORES00_USCORE0011 = 16, fims__ErrorCodeType__SVC_USCORES00_USCORE0012 = 17, fims__ErrorCodeType__SVC_USCORES00_USCORE0013 = 18, fims__ErrorCodeType__SVC_USCORES00_USCORE0014 = 19, fims__ErrorCodeType__SVC_USCORES00_USCORE0015 = 20, fims__ErrorCodeType__SVC_USCORES00_USCORE0016 = 21, fims__ErrorCodeType__SVC_USCORES00_USCORE0017 = 22, fims__ErrorCodeType__SVC_USCORES00_USCORE0018 = 23, fims__ErrorCodeType__DAT_USCORES00_USCORE0001 = 24, fims__ErrorCodeType__DAT_USCORES00_USCORE0002 = 25, fims__ErrorCodeType__DAT_USCORES00_USCORE0003 = 26, fims__ErrorCodeType__DAT_USCORES00_USCORE0004 = 27, fims__ErrorCodeType__DAT_USCORES00_USCORE0005 = 28, fims__ErrorCodeType__DAT_USCORES00_USCORE0006 = 29, fims__ErrorCodeType__DAT_USCORES00_USCORE0007 = 30, fims__ErrorCodeType__DAT_USCORES00_USCORE0008 = 31, fims__ErrorCodeType__DAT_USCORES00_USCORE0009 = 32, fims__ErrorCodeType__DAT_USCORES00_USCORE0010 = 33, fims__ErrorCodeType__EXT_USCORES00_USCORE0000 = 34 };
#endif

#ifndef SOAP_TYPE_fims__JobInfoSelectionType
#define SOAP_TYPE_fims__JobInfoSelectionType (162)
/* fims:JobInfoSelectionType */
enum fims__JobInfoSelectionType { fims__JobInfoSelectionType__mandatory = 0, fims__JobInfoSelectionType__all = 1 };
#endif

#ifndef SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType
#define SOAP_TYPE__fims__QueryServiceDescriptionRequestType_responseType (198)
/* fims:QueryServiceDescriptionRequestType-responseType */
enum _fims__QueryServiceDescriptionRequestType_responseType { _fims__QueryServiceDescriptionRequestType_responseType__ref = 0, _fims__QueryServiceDescriptionRequestType_responseType__value = 1 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (16)
typedef LONG64 xsd__duration;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (17)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE_xsd__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_edlprovider__ArrayOfstring
#define SOAP_TYPE_edlprovider__ArrayOfstring (30)
/* edlprovider:ArrayOfstring */
class SOAP_CMAC edlprovider__ArrayOfstring
{
public:
	std::vector<std::wstring >string;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE_edlprovider__ArrayOfstring */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__ArrayOfstring() { edlprovider__ArrayOfstring::soap_default(NULL); }
	virtual ~edlprovider__ArrayOfstring() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__ArrayOfClips
#define SOAP_TYPE_edlprovider__ArrayOfClips (31)
/* edlprovider:ArrayOfClips */
class SOAP_CMAC edlprovider__ArrayOfClips
{
public:
	std::vector<class edlprovider__ClipType * >clips;	/* optional element of type edlprovider:ClipType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_edlprovider__ArrayOfClips */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__ArrayOfClips() { edlprovider__ArrayOfClips::soap_default(NULL); }
	virtual ~edlprovider__ArrayOfClips() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__ClipType
#define SOAP_TYPE_edlprovider__ClipType (32)
/* edlprovider:ClipType */
class SOAP_CMAC edlprovider__ClipType
{
public:
	class fims__TimeType *markIn;	/* required element of type fims:TimeType */
	fims__TimeType *markOut;	/* required element of type fims:TimeType */
	class fims__BMObjectType *clipInfo;	/* required element of type fims:BMObjectType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_edlprovider__ClipType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__ClipType() { edlprovider__ClipType::soap_default(NULL); }
	virtual ~edlprovider__ClipType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__MapItemType
#define SOAP_TYPE_edlprovider__MapItemType (33)
/* edlprovider:MapItemType */
class SOAP_CMAC edlprovider__MapItemType
{
public:
	std::wstring edlType;	/* required element of type xsd:string */
	std::wstring edlExtension;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE_edlprovider__MapItemType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__MapItemType() { edlprovider__MapItemType::soap_default(NULL); }
	virtual ~edlprovider__MapItemType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateRequestBaseType
#define SOAP_TYPE_edlprovider__EdlCreateRequestBaseType (34)
/* edlprovider:EdlCreateRequestBaseType */
class SOAP_CMAC edlprovider__EdlCreateRequestBaseType
{
public:
	std::wstring edlType;	/* required element of type xsd:string */
	edlprovider__ArrayOfClips *clips;	/* optional element of type edlprovider:ArrayOfClips */
	std::wstring *edlSequenceName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateRequestBaseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateRequestBaseType() { edlprovider__EdlCreateRequestBaseType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateRequestBaseType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateResponseType
#define SOAP_TYPE_edlprovider__EdlCreateResponseType (37)
/* edlprovider:EdlCreateResponseType */
class SOAP_CMAC edlprovider__EdlCreateResponseType
{
public:
	xsd__base64Binary *getEdlResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateResponseType() { edlprovider__EdlCreateResponseType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateResponseType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__InstalledEdlsResponseType
#define SOAP_TYPE_edlprovider__InstalledEdlsResponseType (38)
/* edlprovider:InstalledEdlsResponseType */
class SOAP_CMAC edlprovider__InstalledEdlsResponseType
{
public:
	class _edlprovider__Map *edlprovider__Map;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type edlprovider:Map */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_edlprovider__InstalledEdlsResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__InstalledEdlsResponseType() { edlprovider__InstalledEdlsResponseType::soap_default(NULL); }
	virtual ~edlprovider__InstalledEdlsResponseType() { }
};
#endif

#ifndef SOAP_TYPE__edlprovider__Map
#define SOAP_TYPE__edlprovider__Map (40)
/* edlprovider:Map */
class SOAP_CMAC _edlprovider__Map
{
public:
	std::vector<edlprovider__MapItemType * >item;	/* optional element of type edlprovider:MapItemType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE__edlprovider__Map */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _edlprovider__Map() { _edlprovider__Map::soap_default(NULL); }
	virtual ~_edlprovider__Map() { }
};
#endif

#ifndef SOAP_TYPE_fims__ExtensionGroup
#define SOAP_TYPE_fims__ExtensionGroup (41)
/* fims:ExtensionGroup */
class SOAP_CMAC fims__ExtensionGroup
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_fims__ExtensionGroup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ExtensionGroup() { fims__ExtensionGroup::soap_default(NULL); }
	virtual ~fims__ExtensionGroup() { }
};
#endif

#ifndef SOAP_TYPE_fims__ExtensionAttributes
#define SOAP_TYPE_fims__ExtensionAttributes (42)
/* fims:ExtensionAttributes */
class SOAP_CMAC fims__ExtensionAttributes
{
public:
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE_fims__ExtensionAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ExtensionAttributes() { fims__ExtensionAttributes::soap_default(NULL); }
	virtual ~fims__ExtensionAttributes() { }
};
#endif

#ifndef SOAP_TYPE_fims__ResourceReferenceType
#define SOAP_TYPE_fims__ResourceReferenceType (43)
/* fims:ResourceReferenceType */
class SOAP_CMAC fims__ResourceReferenceType
{
public:
	std::wstring resourceID;	/* required element of type fims:ResourceIDType */
	std::wstring *revisionID;	/* optional element of type fims:RevisionIDType */
	std::wstring *location;	/* optional element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE_fims__ResourceReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ResourceReferenceType() { fims__ResourceReferenceType::soap_default(NULL); }
	virtual ~fims__ResourceReferenceType() { }
};
#endif

#ifndef SOAP_TYPE_fims__AsyncEndpointType
#define SOAP_TYPE_fims__AsyncEndpointType (45)
/* fims:AsyncEndpointType */
class SOAP_CMAC fims__AsyncEndpointType
{
public:
	std::wstring replyTo;	/* required element of type xsd:anyURI */
	std::wstring faultTo;	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_fims__AsyncEndpointType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AsyncEndpointType() { fims__AsyncEndpointType::soap_default(NULL); }
	virtual ~fims__AsyncEndpointType() { }
};
#endif

#ifndef SOAP_TYPE_fims__AncillaryDataFormatType
#define SOAP_TYPE_fims__AncillaryDataFormatType (55)
/* fims:AncillaryDataFormatType */
class SOAP_CMAC fims__AncillaryDataFormatType
{
public:
	std::wstring *DID;	/* optional element of type xsd:integer */
	std::wstring *SDID;	/* optional element of type xsd:integer */
	std::wstring *lineNumber;	/* optional element of type xsd:integer */
	std::wstring *wrappingType;	/* optional element of type xsd:integer */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE_fims__AncillaryDataFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AncillaryDataFormatType() { fims__AncillaryDataFormatType::soap_default(NULL); }
	virtual ~fims__AncillaryDataFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMTrackType
#define SOAP_TYPE_fims__BMTrackType (57)
/* fims:BMTrackType */
class SOAP_CMAC fims__BMTrackType
{
public:
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	std::wstring *trackID;	/* optional attribute */
	std::wstring *trackName;	/* optional attribute */
	std::wstring *language;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE_fims__BMTrackType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMTrackType() { fims__BMTrackType::soap_default(NULL); }
	virtual ~fims__BMTrackType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CodecType
#define SOAP_TYPE_fims__CodecType (58)
/* fims:CodecType */
class SOAP_CMAC fims__CodecType
{
public:
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *vendor;	/* optional element of type xsd:string */
	std::wstring *version;	/* optional element of type xsd:string */
	std::wstring *family;	/* optional element of type xsd:string */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE_fims__CodecType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CodecType() { fims__CodecType::soap_default(NULL); }
	virtual ~fims__CodecType() { }
};
#endif

#ifndef SOAP_TYPE_fims__TransferAtomType
#define SOAP_TYPE_fims__TransferAtomType (67)
/* fims:TransferAtomType */
class SOAP_CMAC fims__TransferAtomType
{
public:
	std::wstring destination;	/* required element of type xsd:anyURI */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique type id SOAP_TYPE_fims__TransferAtomType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__TransferAtomType() { fims__TransferAtomType::soap_default(NULL); }
	virtual ~fims__TransferAtomType() { }
};
#endif

#ifndef SOAP_TYPE_fims__TransformAtomType
#define SOAP_TYPE_fims__TransformAtomType (68)
/* fims:TransformAtomType */
class SOAP_CMAC fims__TransformAtomType
{
public:
	class fims__VideoFormatType *videoFormat;	/* optional element of type fims:VideoFormatType */
	class fims__AudioFormatType *audioFormat;	/* optional element of type fims:AudioFormatType */
	class fims__ContainerFormatType *containerFormat;	/* optional element of type fims:ContainerFormatType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique type id SOAP_TYPE_fims__TransformAtomType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__TransformAtomType() { fims__TransformAtomType::soap_default(NULL); }
	virtual ~fims__TransformAtomType() { }
};
#endif

#ifndef SOAP_TYPE_fims__HashType
#define SOAP_TYPE_fims__HashType (72)
/* fims:HashType */
class SOAP_CMAC fims__HashType
{
public:
	class fims__HashFunctionType *hashFunction;	/* required element of type fims:HashFunctionType */
	xsd__hexBinary value;	/* required element of type xsd:hexBinary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique type id SOAP_TYPE_fims__HashType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__HashType() { fims__HashType::soap_default(NULL); }
	virtual ~fims__HashType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProcessedInfoType
#define SOAP_TYPE_fims__ProcessedInfoType (74)
/* fims:ProcessedInfoType */
class SOAP_CMAC fims__ProcessedInfoType
{
public:
	std::wstring percentageProcessedCompleted;	/* required element of type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique type id SOAP_TYPE_fims__ProcessedInfoType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProcessedInfoType() { fims__ProcessedInfoType::soap_default(NULL); }
	virtual ~fims__ProcessedInfoType() { }
};
#endif

#ifndef SOAP_TYPE__fims__union_DurationType
#define SOAP_TYPE__fims__union_DurationType (189)
/* xsd:choice */
union _fims__union_DurationType
{
#define SOAP_UNION__fims__union_DurationType_timecode	(1)
	std::wstring *timecode;
#define SOAP_UNION__fims__union_DurationType_normalPlayTime	(2)
	LONG64 *normalPlayTime;
#define SOAP_UNION__fims__union_DurationType_editUnitNumber	(3)
	class fims__EditUnitNumberType *editUnitNumber;
};
#endif

#ifndef SOAP_TYPE_fims__DurationType
#define SOAP_TYPE_fims__DurationType (77)
/* Choice: */
class SOAP_CMAC fims__DurationType
{
public:
	int __union_DurationType;	/* union discriminant (of union defined below) */
	union _fims__union_DurationType union_DurationType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique type id SOAP_TYPE_fims__DurationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DurationType() { fims__DurationType::soap_default(NULL); }
	virtual ~fims__DurationType() { }
};
#endif

#ifndef SOAP_TYPE__fims__union_TimeType
#define SOAP_TYPE__fims__union_TimeType (192)
/* xsd:choice */
union _fims__union_TimeType
{
#define SOAP_UNION__fims__union_TimeType_timecode	(1)
	std::wstring *timecode;
#define SOAP_UNION__fims__union_TimeType_normalPlayTime	(2)
	std::wstring *normalPlayTime;
#define SOAP_UNION__fims__union_TimeType_editUnitNumber	(3)
	fims__EditUnitNumberType *editUnitNumber;
};
#endif

#ifndef SOAP_TYPE_fims__TimeType
#define SOAP_TYPE_fims__TimeType (78)
/* Choice: */
class SOAP_CMAC fims__TimeType
{
public:
	int __union_TimeType;	/* union discriminant (of union defined below) */
	union _fims__union_TimeType union_TimeType;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE_fims__TimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__TimeType() { fims__TimeType::soap_default(NULL); }
	virtual ~fims__TimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessType
#define SOAP_TYPE_fims__StartProcessType (81)
/* fims:StartProcessType */
class SOAP_CMAC fims__StartProcessType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique type id SOAP_TYPE_fims__StartProcessType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessType() { fims__StartProcessType::soap_default(NULL); }
	virtual ~fims__StartProcessType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessType
#define SOAP_TYPE_fims__StopProcessType (86)
/* fims:StopProcessType */
class SOAP_CMAC fims__StopProcessType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique type id SOAP_TYPE_fims__StopProcessType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessType() { fims__StopProcessType::soap_default(NULL); }
	virtual ~fims__StopProcessType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobType
#define SOAP_TYPE_fims__StartJobType (92)
/* fims:StartJobType */
class SOAP_CMAC fims__StartJobType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique type id SOAP_TYPE_fims__StartJobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobType() { fims__StartJobType::soap_default(NULL); }
	virtual ~fims__StartJobType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageJobRequestType
#define SOAP_TYPE_fims__ManageJobRequestType (96)
/* fims:ManageJobRequestType */
class SOAP_CMAC fims__ManageJobRequestType
{
public:
	std::wstring jobID;	/* required element of type fims:UID */
	enum fims__JobCommandType jobCommand;	/* required element of type fims:JobCommandType */
	enum fims__PriorityType *priority;	/* optional element of type fims:PriorityType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique type id SOAP_TYPE_fims__ManageJobRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageJobRequestType() { fims__ManageJobRequestType::soap_default(NULL); }
	virtual ~fims__ManageJobRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageJobResponseType
#define SOAP_TYPE_fims__ManageJobResponseType (97)
/* fims:ManageJobResponseType */
class SOAP_CMAC fims__ManageJobResponseType
{
public:
	class fims__JobType *job;	/* required element of type fims:JobType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique type id SOAP_TYPE_fims__ManageJobResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageJobResponseType() { fims__ManageJobResponseType::soap_default(NULL); }
	virtual ~fims__ManageJobResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageQueueRequestType
#define SOAP_TYPE_fims__ManageQueueRequestType (98)
/* fims:ManageQueueRequestType */
class SOAP_CMAC fims__ManageQueueRequestType
{
public:
	std::wstring *queueID;	/* optional element of type fims:UID */
	enum fims__QueueCommandType queueCommand;	/* required element of type fims:QueueCommandType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique type id SOAP_TYPE_fims__ManageQueueRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageQueueRequestType() { fims__ManageQueueRequestType::soap_default(NULL); }
	virtual ~fims__ManageQueueRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ManageQueueResponseType
#define SOAP_TYPE_fims__ManageQueueResponseType (99)
/* fims:ManageQueueResponseType */
class SOAP_CMAC fims__ManageQueueResponseType
{
public:
	class fims__QueueType *queue;	/* required element of type fims:QueueType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique type id SOAP_TYPE_fims__ManageQueueResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ManageQueueResponseType() { fims__ManageQueueResponseType::soap_default(NULL); }
	virtual ~fims__ManageQueueResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobRequestType
#define SOAP_TYPE_fims__QueryJobRequestType (100)
/* fims:QueryJobRequestType */
class SOAP_CMAC fims__QueryJobRequestType
{
public:
	enum fims__JobInfoSelectionType jobInfoSelection;	/* required element of type fims:JobInfoSelectionType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique type id SOAP_TYPE_fims__QueryJobRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobRequestType() { fims__QueryJobRequestType::soap_default(NULL); }
	virtual ~fims__QueryJobRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobResponseType
#define SOAP_TYPE_fims__QueryJobResponseType (103)
/* fims:QueryJobResponseType */
class SOAP_CMAC fims__QueryJobResponseType
{
public:
	class fims__JobsType *jobs;	/* optional element of type fims:JobsType */
	std::wstring *notReportedResultsNumber;	/* optional element of type xsd:nonNegativeInteger */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique type id SOAP_TYPE_fims__QueryJobResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobResponseType() { fims__QueryJobResponseType::soap_default(NULL); }
	virtual ~fims__QueryJobResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryServiceDescriptionRequestType
#define SOAP_TYPE_fims__QueryServiceDescriptionRequestType (104)
/* fims:QueryServiceDescriptionRequestType */
class SOAP_CMAC fims__QueryServiceDescriptionRequestType
{
public:
	enum _fims__QueryServiceDescriptionRequestType_responseType responseType;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique type id SOAP_TYPE_fims__QueryServiceDescriptionRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryServiceDescriptionRequestType() { fims__QueryServiceDescriptionRequestType::soap_default(NULL); }
	virtual ~fims__QueryServiceDescriptionRequestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryServiceDescriptionResponseType
#define SOAP_TYPE_fims__QueryServiceDescriptionResponseType (105)
/* fims:QueryServiceDescriptionResponseType */
class SOAP_CMAC fims__QueryServiceDescriptionResponseType
{
public:
	class fims__ServiceType *service;	/* required element of type fims:ServiceType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique type id SOAP_TYPE_fims__QueryServiceDescriptionResponseType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryServiceDescriptionResponseType() { fims__QueryServiceDescriptionResponseType::soap_default(NULL); }
	virtual ~fims__QueryServiceDescriptionResponseType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ListFilterType
#define SOAP_TYPE_fims__ListFilterType (106)
/* fims:ListFilterType */
class SOAP_CMAC fims__ListFilterType
{
public:
	time_t *fromDate;	/* optional element of type xsd:dateTime */
	time_t *toDate;	/* optional element of type xsd:dateTime */
	bool includeQueued;	/* required element of type xsd:boolean */
	bool includeActive;	/* required element of type xsd:boolean */
	bool includeFinished;	/* required element of type xsd:boolean */
	bool includeFailed;	/* required element of type xsd:boolean */
	std::wstring *maxNumberResults;	/* optional element of type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique type id SOAP_TYPE_fims__ListFilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ListFilterType() { fims__ListFilterType::soap_default(NULL); }
	virtual ~fims__ListFilterType() { }
};
#endif

#ifndef SOAP_TYPE_fims__FaultType
#define SOAP_TYPE_fims__FaultType (107)
/* fims:FaultType */
class SOAP_CMAC fims__FaultType
{
public:
	enum fims__ErrorCodeType code;	/* required element of type fims:ErrorCodeType */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *detail;	/* optional element of type xsd:string */
	std::vector<class fims__InnerFaultType * >innerFault;	/* optional element of type fims:InnerFaultType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique type id SOAP_TYPE_fims__FaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__FaultType() { fims__FaultType::soap_default(NULL); }
	virtual ~fims__FaultType() { }
};
#endif

#ifndef SOAP_TYPE_fims__InnerFaultType
#define SOAP_TYPE_fims__InnerFaultType (108)
/* fims:InnerFaultType */
class SOAP_CMAC fims__InnerFaultType
{
public:
	std::wstring code;	/* required element of type xsd:string */
	std::wstring *description;	/* optional element of type xsd:string */
	std::wstring *detail;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique type id SOAP_TYPE_fims__InnerFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__InnerFaultType() { fims__InnerFaultType::soap_default(NULL); }
	virtual ~fims__InnerFaultType() { }
};
#endif

#ifndef SOAP_TYPE___fims__ResourcesType_sequence
#define SOAP_TYPE___fims__ResourcesType_sequence (205)
/* Operation wrapper: */
class SOAP_CMAC __fims__ResourcesType_sequence
{
public:
	class fims__ResourceType *resource;	/* required element of type fims:ResourceType */
public:
	virtual int soap_type() const { return 205; } /* = unique type id SOAP_TYPE___fims__ResourcesType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__ResourcesType_sequence() { __fims__ResourcesType_sequence::soap_default(NULL); }
	virtual ~__fims__ResourcesType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__ResourcesType
#define SOAP_TYPE_fims__ResourcesType (109)
/* fims:ResourcesType */
class SOAP_CMAC fims__ResourcesType
{
public:
	std::vector<__fims__ResourcesType_sequence >__ResourcesType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique type id SOAP_TYPE_fims__ResourcesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ResourcesType() { fims__ResourcesType::soap_default(NULL); }
	virtual ~fims__ResourcesType() { }
};
#endif

#ifndef SOAP_TYPE___fims__ProfilesType_sequence
#define SOAP_TYPE___fims__ProfilesType_sequence (208)
/* Operation wrapper: */
class SOAP_CMAC __fims__ProfilesType_sequence
{
public:
	class fims__ProfileType *profile;	/* required element of type fims:ProfileType */
public:
	virtual int soap_type() const { return 208; } /* = unique type id SOAP_TYPE___fims__ProfilesType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__ProfilesType_sequence() { __fims__ProfilesType_sequence::soap_default(NULL); }
	virtual ~__fims__ProfilesType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProfilesType
#define SOAP_TYPE_fims__ProfilesType (110)
/* fims:ProfilesType */
class SOAP_CMAC fims__ProfilesType
{
public:
	std::vector<__fims__ProfilesType_sequence >__ProfilesType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique type id SOAP_TYPE_fims__ProfilesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProfilesType() { fims__ProfilesType::soap_default(NULL); }
	virtual ~fims__ProfilesType() { }
};
#endif

#ifndef SOAP_TYPE___fims__ServicesType_sequence
#define SOAP_TYPE___fims__ServicesType_sequence (211)
/* Operation wrapper: */
class SOAP_CMAC __fims__ServicesType_sequence
{
public:
	fims__ServiceType *service;	/* required element of type fims:ServiceType */
public:
	virtual int soap_type() const { return 211; } /* = unique type id SOAP_TYPE___fims__ServicesType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__ServicesType_sequence() { __fims__ServicesType_sequence::soap_default(NULL); }
	virtual ~__fims__ServicesType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__ServicesType
#define SOAP_TYPE_fims__ServicesType (111)
/* fims:ServicesType */
class SOAP_CMAC fims__ServicesType
{
public:
	std::vector<__fims__ServicesType_sequence >__ServicesType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique type id SOAP_TYPE_fims__ServicesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ServicesType() { fims__ServicesType::soap_default(NULL); }
	virtual ~fims__ServicesType() { }
};
#endif

#ifndef SOAP_TYPE___fims__QueuesType_sequence
#define SOAP_TYPE___fims__QueuesType_sequence (213)
/* Operation wrapper: */
class SOAP_CMAC __fims__QueuesType_sequence
{
public:
	fims__QueueType *queue;	/* required element of type fims:QueueType */
public:
	virtual int soap_type() const { return 213; } /* = unique type id SOAP_TYPE___fims__QueuesType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__QueuesType_sequence() { __fims__QueuesType_sequence::soap_default(NULL); }
	virtual ~__fims__QueuesType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueuesType
#define SOAP_TYPE_fims__QueuesType (112)
/* fims:QueuesType */
class SOAP_CMAC fims__QueuesType
{
public:
	std::vector<__fims__QueuesType_sequence >__QueuesType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique type id SOAP_TYPE_fims__QueuesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueuesType() { fims__QueuesType::soap_default(NULL); }
	virtual ~fims__QueuesType() { }
};
#endif

#ifndef SOAP_TYPE___fims__JobsType_sequence
#define SOAP_TYPE___fims__JobsType_sequence (215)
/* Operation wrapper: */
class SOAP_CMAC __fims__JobsType_sequence
{
public:
	fims__JobType *job;	/* required element of type fims:JobType */
public:
	virtual int soap_type() const { return 215; } /* = unique type id SOAP_TYPE___fims__JobsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__JobsType_sequence() { __fims__JobsType_sequence::soap_default(NULL); }
	virtual ~__fims__JobsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__JobsType
#define SOAP_TYPE_fims__JobsType (113)
/* fims:JobsType */
class SOAP_CMAC fims__JobsType
{
public:
	std::vector<__fims__JobsType_sequence >__JobsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique type id SOAP_TYPE_fims__JobsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__JobsType() { fims__JobsType::soap_default(NULL); }
	virtual ~fims__JobsType() { }
};
#endif

#ifndef SOAP_TYPE___fims__VideoFormatsType_sequence
#define SOAP_TYPE___fims__VideoFormatsType_sequence (217)
/* Operation wrapper: */
class SOAP_CMAC __fims__VideoFormatsType_sequence
{
public:
	fims__VideoFormatType *videoFormat;	/* required element of type fims:VideoFormatType */
public:
	virtual int soap_type() const { return 217; } /* = unique type id SOAP_TYPE___fims__VideoFormatsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__VideoFormatsType_sequence() { __fims__VideoFormatsType_sequence::soap_default(NULL); }
	virtual ~__fims__VideoFormatsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__VideoFormatsType
#define SOAP_TYPE_fims__VideoFormatsType (114)
/* fims:VideoFormatsType */
class SOAP_CMAC fims__VideoFormatsType
{
public:
	std::vector<__fims__VideoFormatsType_sequence >__VideoFormatsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique type id SOAP_TYPE_fims__VideoFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__VideoFormatsType() { fims__VideoFormatsType::soap_default(NULL); }
	virtual ~fims__VideoFormatsType() { }
};
#endif

#ifndef SOAP_TYPE___fims__AudioFormatsType_sequence
#define SOAP_TYPE___fims__AudioFormatsType_sequence (219)
/* Operation wrapper: */
class SOAP_CMAC __fims__AudioFormatsType_sequence
{
public:
	fims__AudioFormatType *audioFormat;	/* required element of type fims:AudioFormatType */
public:
	virtual int soap_type() const { return 219; } /* = unique type id SOAP_TYPE___fims__AudioFormatsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__AudioFormatsType_sequence() { __fims__AudioFormatsType_sequence::soap_default(NULL); }
	virtual ~__fims__AudioFormatsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__AudioFormatsType
#define SOAP_TYPE_fims__AudioFormatsType (115)
/* fims:AudioFormatsType */
class SOAP_CMAC fims__AudioFormatsType
{
public:
	std::vector<__fims__AudioFormatsType_sequence >__AudioFormatsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique type id SOAP_TYPE_fims__AudioFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AudioFormatsType() { fims__AudioFormatsType::soap_default(NULL); }
	virtual ~fims__AudioFormatsType() { }
};
#endif

#ifndef SOAP_TYPE___fims__ContainerFormatsType_sequence
#define SOAP_TYPE___fims__ContainerFormatsType_sequence (221)
/* Operation wrapper: */
class SOAP_CMAC __fims__ContainerFormatsType_sequence
{
public:
	fims__ContainerFormatType *containerFormat;	/* required element of type fims:ContainerFormatType */
public:
	virtual int soap_type() const { return 221; } /* = unique type id SOAP_TYPE___fims__ContainerFormatsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__ContainerFormatsType_sequence() { __fims__ContainerFormatsType_sequence::soap_default(NULL); }
	virtual ~__fims__ContainerFormatsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContainerFormatsType
#define SOAP_TYPE_fims__ContainerFormatsType (116)
/* fims:ContainerFormatsType */
class SOAP_CMAC fims__ContainerFormatsType
{
public:
	std::vector<__fims__ContainerFormatsType_sequence >__ContainerFormatsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique type id SOAP_TYPE_fims__ContainerFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContainerFormatsType() { fims__ContainerFormatsType::soap_default(NULL); }
	virtual ~fims__ContainerFormatsType() { }
};
#endif

#ifndef SOAP_TYPE___fims__DataFormatsType_sequence
#define SOAP_TYPE___fims__DataFormatsType_sequence (223)
/* Operation wrapper: */
class SOAP_CMAC __fims__DataFormatsType_sequence
{
public:
	class fims__DataFormatType *dataFormat;	/* required element of type fims:DataFormatType */
public:
	virtual int soap_type() const { return 223; } /* = unique type id SOAP_TYPE___fims__DataFormatsType_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __fims__DataFormatsType_sequence() { __fims__DataFormatsType_sequence::soap_default(NULL); }
	virtual ~__fims__DataFormatsType_sequence() { }
};
#endif

#ifndef SOAP_TYPE_fims__DataFormatsType
#define SOAP_TYPE_fims__DataFormatsType (117)
/* fims:DataFormatsType */
class SOAP_CMAC fims__DataFormatsType
{
public:
	std::vector<__fims__DataFormatsType_sequence >__DataFormatsType_sequence;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique type id SOAP_TYPE_fims__DataFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DataFormatsType() { fims__DataFormatsType::soap_default(NULL); }
	virtual ~fims__DataFormatsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMObjectsType
#define SOAP_TYPE_fims__BMObjectsType (118)
/* fims:BMObjectsType */
class SOAP_CMAC fims__BMObjectsType
{
public:
	std::vector<fims__BMObjectType * >bmObject;	/* required element of type fims:BMObjectType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique type id SOAP_TYPE_fims__BMObjectsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMObjectsType() { fims__BMObjectsType::soap_default(NULL); }
	virtual ~fims__BMObjectsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentsType
#define SOAP_TYPE_fims__BMContentsType (119)
/* fims:BMContentsType */
class SOAP_CMAC fims__BMContentsType
{
public:
	std::vector<class fims__BMContentType * >bmContent;	/* required element of type fims:BMContentType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique type id SOAP_TYPE_fims__BMContentsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentsType() { fims__BMContentsType::soap_default(NULL); }
	virtual ~fims__BMContentsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentFormatsType
#define SOAP_TYPE_fims__BMContentFormatsType (120)
/* fims:BMContentFormatsType */
class SOAP_CMAC fims__BMContentFormatsType
{
public:
	std::vector<class fims__BMContentFormatType * >bmContentFormat;	/* required element of type fims:BMContentFormatType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique type id SOAP_TYPE_fims__BMContentFormatsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentFormatsType() { fims__BMContentFormatsType::soap_default(NULL); }
	virtual ~fims__BMContentFormatsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMEssenceLocatorsType
#define SOAP_TYPE_fims__BMEssenceLocatorsType (121)
/* fims:BMEssenceLocatorsType */
class SOAP_CMAC fims__BMEssenceLocatorsType
{
public:
	std::vector<class fims__BMEssenceLocatorType * >bmEssenceLocator;	/* required element of type fims:BMEssenceLocatorType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique type id SOAP_TYPE_fims__BMEssenceLocatorsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMEssenceLocatorsType() { fims__BMEssenceLocatorsType::soap_default(NULL); }
	virtual ~fims__BMEssenceLocatorsType() { }
};
#endif

#ifndef SOAP_TYPE_fims__DescriptionsType
#define SOAP_TYPE_fims__DescriptionsType (122)
/* fims:DescriptionsType */
class SOAP_CMAC fims__DescriptionsType
{
public:
	std::vector<class fims__DescriptionType * >description;	/* required element of type fims:DescriptionType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique type id SOAP_TYPE_fims__DescriptionsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DescriptionsType() { fims__DescriptionsType::soap_default(NULL); }
	virtual ~fims__DescriptionsType() { }
};
#endif

#ifndef SOAP_TYPE__fims__formatCollection
#define SOAP_TYPE__fims__formatCollection (123)
/* fims:formatCollection */
class SOAP_CMAC _fims__formatCollection
{
public:
	fims__VideoFormatType *videoFormat;	/* optional element of type fims:VideoFormatType */
	fims__AudioFormatType *audioFormat;	/* optional element of type fims:AudioFormatType */
	fims__DataFormatType *dataFormat;	/* optional element of type fims:DataFormatType */
	fims__ContainerFormatType *containerFormat;	/* optional element of type fims:ContainerFormatType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique type id SOAP_TYPE__fims__formatCollection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__formatCollection() { _fims__formatCollection::soap_default(NULL); }
	virtual ~_fims__formatCollection() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__bmContentDescriptionType
#define SOAP_TYPE_fimsdescription__bmContentDescriptionType (124)
/* fimsdescription:bmContentDescriptionType */
class SOAP_CMAC fimsdescription__bmContentDescriptionType
{
public:
	std::vector<class fimsdescription__textElementType * >title;	/* optional element of type fimsdescription:textElementType */
	std::vector<class fimsdescription__titleType * >alternativeTitle;	/* optional element of type fimsdescription:titleType */
	std::vector<class fimsdescription__entityType * >creator;	/* optional element of type fimsdescription:entityType */
	std::vector<class fimsdescription__subjectType * >subject;	/* optional element of type fimsdescription:subjectType */
	std::vector<class fimsdescription__descriptionType * >description;	/* optional element of type fimsdescription:descriptionType */
	std::vector<fimsdescription__entityType * >publisher;	/* optional element of type fimsdescription:entityType */
	std::vector<fimsdescription__entityType * >contributor;	/* optional element of type fimsdescription:entityType */
	std::vector<class fimsdescription__dateType * >date;	/* optional element of type fimsdescription:dateType */
	std::vector<class fimsdescription__typeType * >type;	/* optional element of type fimsdescription:typeType */
	std::vector<class fimsdescription__identifierType * >identifier;	/* optional element of type fimsdescription:identifierType */
	std::vector<class fimsdescription__languageType * >language;	/* optional element of type fimsdescription:languageType */
	std::vector<class fimsdescription__coverageType * >coverage;	/* optional element of type fimsdescription:coverageType */
	std::vector<class fimsdescription__rightsType * >rights;	/* optional element of type fimsdescription:rightsType */
	std::wstring *version;	/* optional element of type xsd:string */
	std::wstring *xml__lang;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique type id SOAP_TYPE_fimsdescription__bmContentDescriptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__bmContentDescriptionType() { fimsdescription__bmContentDescriptionType::soap_default(NULL); }
	virtual ~fimsdescription__bmContentDescriptionType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__typeType_genre
#define SOAP_TYPE__fimsdescription__typeType_genre (258)
/* fimsdescription:typeType-genre */
class SOAP_CMAC _fimsdescription__typeType_genre
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 258; } /* = unique type id SOAP_TYPE__fimsdescription__typeType_genre */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__typeType_genre() { _fimsdescription__typeType_genre::soap_default(NULL); }
	virtual ~_fimsdescription__typeType_genre() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__typeType_objectType
#define SOAP_TYPE__fimsdescription__typeType_objectType (261)
/* fimsdescription:typeType-objectType */
class SOAP_CMAC _fimsdescription__typeType_objectType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 261; } /* = unique type id SOAP_TYPE__fimsdescription__typeType_objectType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__typeType_objectType() { _fimsdescription__typeType_objectType::soap_default(NULL); }
	virtual ~_fimsdescription__typeType_objectType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__typeType_targetAudience
#define SOAP_TYPE__fimsdescription__typeType_targetAudience (264)
/* fimsdescription:typeType-targetAudience */
class SOAP_CMAC _fimsdescription__typeType_targetAudience
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 264; } /* = unique type id SOAP_TYPE__fimsdescription__typeType_targetAudience */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__typeType_targetAudience() { _fimsdescription__typeType_targetAudience::soap_default(NULL); }
	virtual ~_fimsdescription__typeType_targetAudience() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__typeType
#define SOAP_TYPE_fimsdescription__typeType (128)
/* fimsdescription:typeType */
class SOAP_CMAC fimsdescription__typeType
{
public:
	std::vector<_fimsdescription__typeType_genre >*genre;	/* optional element of type fimsdescription:typeType-genre */
	std::vector<_fimsdescription__typeType_objectType >*objectType;	/* optional element of type fimsdescription:typeType-objectType */
	std::vector<_fimsdescription__typeType_targetAudience >*targetAudience;	/* optional element of type fimsdescription:typeType-targetAudience */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 128; } /* = unique type id SOAP_TYPE_fimsdescription__typeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__typeType() { fimsdescription__typeType::soap_default(NULL); }
	virtual ~fimsdescription__typeType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_temporal
#define SOAP_TYPE__fimsdescription__coverageType_temporal (267)
/* fimsdescription:coverageType-temporal */
class SOAP_CMAC _fimsdescription__coverageType_temporal
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 267; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_temporal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_temporal() { _fimsdescription__coverageType_temporal::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_temporal() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_spatial_locationName
#define SOAP_TYPE__fimsdescription__coverageType_spatial_locationName (270)
/* fimsdescription:coverageType-spatial-locationName */
class SOAP_CMAC _fimsdescription__coverageType_spatial_locationName
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 270; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_spatial_locationName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_spatial_locationName() { _fimsdescription__coverageType_spatial_locationName::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_spatial_locationName() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates
#define SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates (271)
/* fimsdescription:coverageType-spatial-coordinates */
class SOAP_CMAC _fimsdescription__coverageType_spatial_coordinates
{
public:
	float posy;	/* required element of type xsd:float */
	float posx;	/* required element of type xsd:float */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	std::wstring *formatLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 271; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_spatial_coordinates */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_spatial_coordinates() { _fimsdescription__coverageType_spatial_coordinates::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_spatial_coordinates() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__coverageType_spatial
#define SOAP_TYPE__fimsdescription__coverageType_spatial (269)
/* fimsdescription:coverageType-spatial */
class SOAP_CMAC _fimsdescription__coverageType_spatial
{
public:
	_fimsdescription__coverageType_spatial_locationName locationName;	/* required element of type fimsdescription:coverageType-spatial-locationName */
	_fimsdescription__coverageType_spatial_coordinates *coordinates;	/* optional element of type fimsdescription:coverageType-spatial-coordinates */
public:
	virtual int soap_type() const { return 269; } /* = unique type id SOAP_TYPE__fimsdescription__coverageType_spatial */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__coverageType_spatial() { _fimsdescription__coverageType_spatial::soap_default(NULL); }
	virtual ~_fimsdescription__coverageType_spatial() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__coverageType
#define SOAP_TYPE_fimsdescription__coverageType (130)
/* fimsdescription:coverageType */
class SOAP_CMAC fimsdescription__coverageType
{
public:
	_fimsdescription__coverageType_temporal *temporal;	/* optional element of type fimsdescription:coverageType-temporal */
	_fimsdescription__coverageType_spatial *spatial;	/* optional element of type fimsdescription:coverageType-spatial */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 130; } /* = unique type id SOAP_TYPE_fimsdescription__coverageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__coverageType() { fimsdescription__coverageType::soap_default(NULL); }
	virtual ~fimsdescription__coverageType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__rightsType
#define SOAP_TYPE_fimsdescription__rightsType (131)
/* fimsdescription:rightsType */
class SOAP_CMAC fimsdescription__rightsType
{
public:
	std::vector<fimsdescription__textElementType * >rightsExpression;	/* optional element of type fimsdescription:textElementType */
	std::wstring *rightsLink;	/* optional element of type xsd:anyURI */
	fimsdescription__entityType *rightsHolder;	/* optional element of type fimsdescription:entityType */
	fimsdescription__textElementType *exploitationIssues;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__coverageType *coverage;	/* optional element of type fimsdescription:coverageType */
	bool *rightsClearanceFlag;	/* optional element of type xsd:boolean */
	std::vector<fimsdescription__textElementType * >disclaimer;	/* optional element of type fimsdescription:textElementType */
	std::vector<fimsdescription__identifierType * >rightsId;	/* optional element of type fimsdescription:identifierType */
	std::vector<class fimsdescription__contactDetailsType * >contactDetails;	/* optional element of type fimsdescription:contactDetailsType */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 131; } /* = unique type id SOAP_TYPE_fimsdescription__rightsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__rightsType() { fimsdescription__rightsType::soap_default(NULL); }
	virtual ~fimsdescription__rightsType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_created
#define SOAP_TYPE__fimsdescription__dateType_created (278)
/* fimsdescription:dateType-created */
class SOAP_CMAC _fimsdescription__dateType_created
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
public:
	virtual int soap_type() const { return 278; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_created */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_created() { _fimsdescription__dateType_created::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_created() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_modified
#define SOAP_TYPE__fimsdescription__dateType_modified (282)
/* fimsdescription:dateType-modified */
class SOAP_CMAC _fimsdescription__dateType_modified
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
public:
	virtual int soap_type() const { return 282; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_modified */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_modified() { _fimsdescription__dateType_modified::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_modified() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_issued
#define SOAP_TYPE__fimsdescription__dateType_issued (284)
/* fimsdescription:dateType-issued */
class SOAP_CMAC _fimsdescription__dateType_issued
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
public:
	virtual int soap_type() const { return 284; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_issued */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_issued() { _fimsdescription__dateType_issued::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_issued() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__dateType_alternative
#define SOAP_TYPE__fimsdescription__dateType_alternative (286)
/* fimsdescription:dateType-alternative */
class SOAP_CMAC _fimsdescription__dateType_alternative
{
public:
	std::wstring *startYear;	/* optional attribute */
	std::wstring *startDate;	/* optional attribute */
	std::wstring *startTime;	/* optional attribute */
	std::wstring *endYear;	/* optional attribute */
	std::wstring *endDate;	/* optional attribute */
	std::wstring *endTime;	/* optional attribute */
	std::wstring *period;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 286; } /* = unique type id SOAP_TYPE__fimsdescription__dateType_alternative */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__dateType_alternative() { _fimsdescription__dateType_alternative::soap_default(NULL); }
	virtual ~_fimsdescription__dateType_alternative() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__dateType
#define SOAP_TYPE_fimsdescription__dateType (133)
/* fimsdescription:dateType */
class SOAP_CMAC fimsdescription__dateType
{
public:
	_fimsdescription__dateType_created *created;	/* optional element of type fimsdescription:dateType-created */
	_fimsdescription__dateType_modified *modified;	/* optional element of type fimsdescription:dateType-modified */
	_fimsdescription__dateType_issued *issued;	/* optional element of type fimsdescription:dateType-issued */
	_fimsdescription__dateType_alternative *alternative;	/* optional element of type fimsdescription:dateType-alternative */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 133; } /* = unique type id SOAP_TYPE_fimsdescription__dateType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__dateType() { fimsdescription__dateType::soap_default(NULL); }
	virtual ~fimsdescription__dateType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__entityType_role
#define SOAP_TYPE__fimsdescription__entityType_role (290)
/* fimsdescription:entityType-role */
class SOAP_CMAC _fimsdescription__entityType_role
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 290; } /* = unique type id SOAP_TYPE__fimsdescription__entityType_role */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__entityType_role() { _fimsdescription__entityType_role::soap_default(NULL); }
	virtual ~_fimsdescription__entityType_role() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__entityType
#define SOAP_TYPE_fimsdescription__entityType (134)
/* fimsdescription:entityType */
class SOAP_CMAC fimsdescription__entityType
{
public:
	std::vector<fimsdescription__contactDetailsType * >contactDetails;	/* optional element of type fimsdescription:contactDetailsType */
	std::vector<class fimsdescription__organisationDetailsType * >organisationDetails;	/* optional element of type fimsdescription:organisationDetailsType */
	std::vector<_fimsdescription__entityType_role >*role;	/* optional element of type fimsdescription:entityType-role */
	std::wstring *entityId;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 134; } /* = unique type id SOAP_TYPE_fimsdescription__entityType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__entityType() { fimsdescription__entityType::soap_default(NULL); }
	virtual ~fimsdescription__entityType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__contactDetailsType
#define SOAP_TYPE_fimsdescription__contactDetailsType (135)
/* fimsdescription:contactDetailsType */
class SOAP_CMAC fimsdescription__contactDetailsType
{
public:
	std::wstring *name;	/* optional element of type xsd:string */
	std::wstring *givenName;	/* optional element of type xsd:string */
	std::wstring *familyName;	/* optional element of type xsd:string */
	std::vector<std::wstring >otherGivenName;	/* optional element of type xsd:string */
	std::wstring *suffix;	/* optional element of type xsd:string */
	std::wstring *salutation;	/* optional element of type xsd:string */
	std::vector<fimsdescription__textElementType * >username;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__textElementType *occupation;	/* optional element of type fimsdescription:textElementType */
	std::vector<class fimsdescription__detailsType * >details;	/* optional element of type fimsdescription:detailsType */
	std::vector<fimsdescription__textElementType * >stageName;	/* optional element of type fimsdescription:textElementType */
	std::vector<fimsdescription__entityType * >relatedContacts;	/* optional element of type fimsdescription:entityType */
	std::wstring *contactId;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 135; } /* = unique type id SOAP_TYPE_fimsdescription__contactDetailsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__contactDetailsType() { fimsdescription__contactDetailsType::soap_default(NULL); }
	virtual ~fimsdescription__contactDetailsType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment
#define SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment (296)
/* fimsdescription:organisationDetailsType-organisationDepartment */
class SOAP_CMAC _fimsdescription__organisationDetailsType_organisationDepartment
{
public:
	std::wstring *departmentId;	/* optional attribute */
public:
	virtual int soap_type() const { return 296; } /* = unique type id SOAP_TYPE__fimsdescription__organisationDetailsType_organisationDepartment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__organisationDetailsType_organisationDepartment() { _fimsdescription__organisationDetailsType_organisationDepartment::soap_default(NULL); }
	virtual ~_fimsdescription__organisationDetailsType_organisationDepartment() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__organisationDetailsType
#define SOAP_TYPE_fimsdescription__organisationDetailsType (136)
/* fimsdescription:organisationDetailsType */
class SOAP_CMAC fimsdescription__organisationDetailsType
{
public:
	std::vector<fimsdescription__textElementType * >organisationName;	/* optional element of type fimsdescription:textElementType */
	std::vector<std::wstring >organisationCode;	/* optional element of type xsd:anyURI */
	_fimsdescription__organisationDetailsType_organisationDepartment *organisationDepartment;	/* optional element of type fimsdescription:organisationDetailsType-organisationDepartment */
	std::vector<fimsdescription__detailsType * >details;	/* optional element of type fimsdescription:detailsType */
	std::vector<fimsdescription__entityType * >contacts;	/* optional element of type fimsdescription:entityType */
	std::wstring *organisationId;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 136; } /* = unique type id SOAP_TYPE_fimsdescription__organisationDetailsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__organisationDetailsType() { fimsdescription__organisationDetailsType::soap_default(NULL); }
	virtual ~fimsdescription__organisationDetailsType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__detailsType
#define SOAP_TYPE_fimsdescription__detailsType (137)
/* fimsdescription:detailsType */
class SOAP_CMAC fimsdescription__detailsType
{
public:
	std::vector<std::wstring >emailAddress;	/* optional element of type xsd:string */
	std::wstring *webAddress;	/* optional element of type xsd:string */
	class fimsdescription__addressType *address;	/* optional element of type fimsdescription:addressType */
	std::wstring *telephoneNumber;	/* optional element of type xsd:string */
	std::wstring *mobileTelephoneNumber;	/* optional element of type xsd:string */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 137; } /* = unique type id SOAP_TYPE_fimsdescription__detailsType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__detailsType() { fimsdescription__detailsType::soap_default(NULL); }
	virtual ~fimsdescription__detailsType() { }
};
#endif

#ifndef SOAP_TYPE__fimsdescription__addressType_country
#define SOAP_TYPE__fimsdescription__addressType_country (299)
/* fimsdescription:addressType-country */
class SOAP_CMAC _fimsdescription__addressType_country
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 299; } /* = unique type id SOAP_TYPE__fimsdescription__addressType_country */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fimsdescription__addressType_country() { _fimsdescription__addressType_country::soap_default(NULL); }
	virtual ~_fimsdescription__addressType_country() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__addressType
#define SOAP_TYPE_fimsdescription__addressType (138)
/* fimsdescription:addressType */
class SOAP_CMAC fimsdescription__addressType
{
public:
	std::vector<fimsdescription__textElementType * >addressLine;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__textElementType *addressTownCity;	/* optional element of type fimsdescription:textElementType */
	fimsdescription__textElementType *addressCountyState;	/* optional element of type fimsdescription:textElementType */
	std::wstring *addressDeliveryCode;	/* optional element of type xsd:string */
	_fimsdescription__addressType_country *country;	/* optional element of type fimsdescription:addressType-country */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique type id SOAP_TYPE_fimsdescription__addressType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__addressType() { fimsdescription__addressType::soap_default(NULL); }
	virtual ~fimsdescription__addressType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__languageType
#define SOAP_TYPE_fimsdescription__languageType (139)
/* fimsdescription:languageType */
class SOAP_CMAC fimsdescription__languageType
{
public:
	std::wstring *xml__lang;	/* optional attribute */
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 139; } /* = unique type id SOAP_TYPE_fimsdescription__languageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__languageType() { fimsdescription__languageType::soap_default(NULL); }
	virtual ~fimsdescription__languageType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateRequestType
#define SOAP_TYPE_edlprovider__EdlCreateRequestType (35)
/* edlprovider:EdlCreateRequestType */
class SOAP_CMAC edlprovider__EdlCreateRequestType : public edlprovider__EdlCreateRequestBaseType
{
public:
	class fims__RationalType *edlFramesPerSecond;	/* required element of type fims:RationalType */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateRequestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateRequestType() { edlprovider__EdlCreateRequestType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateRequestType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType
#define SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType (36)
/* edlprovider:EdlCreateRequestDoubleType */
class SOAP_CMAC edlprovider__EdlCreateRequestDoubleType : public edlprovider__EdlCreateRequestBaseType
{
public:
	double edlFramesPerSecond;	/* required element of type xsd:double */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE_edlprovider__EdlCreateRequestDoubleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlCreateRequestDoubleType() { edlprovider__EdlCreateRequestDoubleType::soap_default(NULL); }
	virtual ~edlprovider__EdlCreateRequestDoubleType() { }
};
#endif

#ifndef SOAP_TYPE_edlprovider__EdlProviderFaultType
#define SOAP_TYPE_edlprovider__EdlProviderFaultType (39)
/* edlprovider:EdlProviderFaultType */
class SOAP_CMAC edlprovider__EdlProviderFaultType : public fims__FaultType
{
public:
	enum edlprovider__EdlProviderErrorCodeType *extendedCode;	/* optional element of type edlprovider:EdlProviderErrorCodeType */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_edlprovider__EdlProviderFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         edlprovider__EdlProviderFaultType() { edlprovider__EdlProviderFaultType::soap_default(NULL); }
	virtual ~edlprovider__EdlProviderFaultType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ResourceType
#define SOAP_TYPE_fims__ResourceType (44)
/* fims:ResourceType */
class SOAP_CMAC fims__ResourceType : public fims__ResourceReferenceType
{
public:
	time_t *resourceCreationDate;	/* optional element of type xsd:dateTime */
	time_t *resourceModifiedDate;	/* optional element of type xsd:dateTime */
	fims__AsyncEndpointType *notifyAt;	/* optional element of type fims:AsyncEndpointType */
	fims__ExtensionGroup *ExtensionGroup;	/* optional element of type fims:ExtensionGroup */
	fims__ExtensionAttributes *ExtensionAttributes;	/* optional element of type fims:ExtensionAttributes */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_fims__ResourceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ResourceType() { fims__ResourceType::soap_default(NULL); }
	virtual ~fims__ResourceType() { }
};
#endif

#ifndef SOAP_TYPE_fims__CaptioningFormatType
#define SOAP_TYPE_fims__CaptioningFormatType (54)
/* Primitive fims:CaptioningFormatType schema type: */
class SOAP_CMAC fims__CaptioningFormatType
{
public:
	std::wstring __item;
	std::wstring *captioningSourceUri;	/* optional attribute */
	std::wstring *language;	/* optional attribute */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE_fims__CaptioningFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__CaptioningFormatType() { fims__CaptioningFormatType::soap_default(NULL); }
	virtual ~fims__CaptioningFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__TechnicalAttributeType
#define SOAP_TYPE_fims__TechnicalAttributeType (69)
/* Primitive fims:TechnicalAttributeType schema type: */
class SOAP_CMAC fims__TechnicalAttributeType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique type id SOAP_TYPE_fims__TechnicalAttributeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__TechnicalAttributeType() { fims__TechnicalAttributeType::soap_default(NULL); }
	virtual ~fims__TechnicalAttributeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__LengthType
#define SOAP_TYPE_fims__LengthType (70)
/* Primitive fims:LengthType schema type: */
class SOAP_CMAC fims__LengthType
{
public:
	std::wstring __item;
	std::wstring *unit;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique type id SOAP_TYPE_fims__LengthType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__LengthType() { fims__LengthType::soap_default(NULL); }
	virtual ~fims__LengthType() { }
};
#endif

#ifndef SOAP_TYPE_fims__RationalType
#define SOAP_TYPE_fims__RationalType (71)
/* Primitive fims:RationalType schema type: */
class SOAP_CMAC fims__RationalType
{
public:
	LONG64 __item;
	std::wstring numerator;	/* required attribute */
	std::wstring denominator;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE_fims__RationalType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__RationalType() { fims__RationalType::soap_default(NULL); }
	virtual ~fims__RationalType() { }
};
#endif

#ifndef SOAP_TYPE_fims__EditUnitNumberType
#define SOAP_TYPE_fims__EditUnitNumberType (73)
/* Primitive fims:EditUnitNumberType schema type: */
class SOAP_CMAC fims__EditUnitNumberType
{
public:
	LONG64 __item;
	std::wstring editRate;	/* required attribute */
	std::wstring factorNumerator;	/* required attribute */
	std::wstring factorDenominator;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique type id SOAP_TYPE_fims__EditUnitNumberType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__EditUnitNumberType() { fims__EditUnitNumberType::soap_default(NULL); }
	virtual ~fims__EditUnitNumberType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProcessedInfoByBytesType
#define SOAP_TYPE_fims__ProcessedInfoByBytesType (75)
/* fims:ProcessedInfoByBytesType */
class SOAP_CMAC fims__ProcessedInfoByBytesType : public fims__ProcessedInfoType
{
public:
	ULONG64 processedBytesCount;	/* required element of type xsd:unsignedLong */
public:
	virtual int soap_type() const { return 75; } /* = unique type id SOAP_TYPE_fims__ProcessedInfoByBytesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProcessedInfoByBytesType() { fims__ProcessedInfoByBytesType::soap_default(NULL); }
	virtual ~fims__ProcessedInfoByBytesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProcessedInfoByFramesType
#define SOAP_TYPE_fims__ProcessedInfoByFramesType (76)
/* fims:ProcessedInfoByFramesType */
class SOAP_CMAC fims__ProcessedInfoByFramesType : public fims__ProcessedInfoType
{
public:
	std::wstring processedFramesCount;	/* required element of type xsd:nonNegativeInteger */
public:
	virtual int soap_type() const { return 76; } /* = unique type id SOAP_TYPE_fims__ProcessedInfoByFramesType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProcessedInfoByFramesType() { fims__ProcessedInfoByFramesType::soap_default(NULL); }
	virtual ~fims__ProcessedInfoByFramesType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByNoWaitType
#define SOAP_TYPE_fims__StartProcessByNoWaitType (82)
/* fims:StartProcessByNoWaitType */
class SOAP_CMAC fims__StartProcessByNoWaitType : public fims__StartProcessType
{
public:
	time_t *actualStartTime;	/* optional element of type xsd:dateTime */
	fims__TimeType *actualStartMark;	/* optional element of type fims:TimeType */
public:
	virtual int soap_type() const { return 82; } /* = unique type id SOAP_TYPE_fims__StartProcessByNoWaitType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByNoWaitType() { fims__StartProcessByNoWaitType::soap_default(NULL); }
	virtual ~fims__StartProcessByNoWaitType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByTimeType
#define SOAP_TYPE_fims__StartProcessByTimeType (83)
/* fims:StartProcessByTimeType */
class SOAP_CMAC fims__StartProcessByTimeType : public fims__StartProcessType
{
public:
	time_t time;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 83; } /* = unique type id SOAP_TYPE_fims__StartProcessByTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByTimeType() { fims__StartProcessByTimeType::soap_default(NULL); }
	virtual ~fims__StartProcessByTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByTimeMarkType
#define SOAP_TYPE_fims__StartProcessByTimeMarkType (84)
/* fims:StartProcessByTimeMarkType */
class SOAP_CMAC fims__StartProcessByTimeMarkType : public fims__StartProcessType
{
public:
	fims__TimeType *timeMark;	/* required element of type fims:TimeType */
public:
	virtual int soap_type() const { return 84; } /* = unique type id SOAP_TYPE_fims__StartProcessByTimeMarkType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByTimeMarkType() { fims__StartProcessByTimeMarkType::soap_default(NULL); }
	virtual ~fims__StartProcessByTimeMarkType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType
#define SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType (85)
/* fims:StartProcessByServiceDefinedTimeType */
class SOAP_CMAC fims__StartProcessByServiceDefinedTimeType : public fims__StartProcessType
{
public:
	time_t *actualStartTime;	/* optional element of type xsd:dateTime */
	fims__TimeType *actualStartMark;	/* optional element of type fims:TimeType */
public:
	virtual int soap_type() const { return 85; } /* = unique type id SOAP_TYPE_fims__StartProcessByServiceDefinedTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartProcessByServiceDefinedTimeType() { fims__StartProcessByServiceDefinedTimeType::soap_default(NULL); }
	virtual ~fims__StartProcessByServiceDefinedTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByTimeType
#define SOAP_TYPE_fims__StopProcessByTimeType (87)
/* fims:StopProcessByTimeType */
class SOAP_CMAC fims__StopProcessByTimeType : public fims__StopProcessType
{
public:
	time_t time;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 87; } /* = unique type id SOAP_TYPE_fims__StopProcessByTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByTimeType() { fims__StopProcessByTimeType::soap_default(NULL); }
	virtual ~fims__StopProcessByTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByDurationType
#define SOAP_TYPE_fims__StopProcessByDurationType (88)
/* fims:StopProcessByDurationType */
class SOAP_CMAC fims__StopProcessByDurationType : public fims__StopProcessType
{
public:
	fims__DurationType *duration;	/* required element of type fims:DurationType */
public:
	virtual int soap_type() const { return 88; } /* = unique type id SOAP_TYPE_fims__StopProcessByDurationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByDurationType() { fims__StopProcessByDurationType::soap_default(NULL); }
	virtual ~fims__StopProcessByDurationType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByTimeMarkType
#define SOAP_TYPE_fims__StopProcessByTimeMarkType (89)
/* fims:StopProcessByTimeMarkType */
class SOAP_CMAC fims__StopProcessByTimeMarkType : public fims__StopProcessType
{
public:
	fims__TimeType *timeMark;	/* required element of type fims:TimeType */
public:
	virtual int soap_type() const { return 89; } /* = unique type id SOAP_TYPE_fims__StopProcessByTimeMarkType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByTimeMarkType() { fims__StopProcessByTimeMarkType::soap_default(NULL); }
	virtual ~fims__StopProcessByTimeMarkType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType
#define SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType (90)
/* fims:StopProcessByServiceDefinedTimeType */
class SOAP_CMAC fims__StopProcessByServiceDefinedTimeType : public fims__StopProcessType
{
public:
	time_t *actualStopTime;	/* optional element of type xsd:dateTime */
	fims__TimeType *actualStopMark;	/* optional element of type fims:TimeType */
public:
	virtual int soap_type() const { return 90; } /* = unique type id SOAP_TYPE_fims__StopProcessByServiceDefinedTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByServiceDefinedTimeType() { fims__StopProcessByServiceDefinedTimeType::soap_default(NULL); }
	virtual ~fims__StopProcessByServiceDefinedTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StopProcessByOpenEndType
#define SOAP_TYPE_fims__StopProcessByOpenEndType (91)
/* fims:StopProcessByOpenEndType */
class SOAP_CMAC fims__StopProcessByOpenEndType : public fims__StopProcessType
{
public:
	time_t *actualStopTime;	/* optional element of type xsd:dateTime */
	fims__TimeType *actualStopMark;	/* optional element of type fims:TimeType */
public:
	virtual int soap_type() const { return 91; } /* = unique type id SOAP_TYPE_fims__StopProcessByOpenEndType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StopProcessByOpenEndType() { fims__StopProcessByOpenEndType::soap_default(NULL); }
	virtual ~fims__StopProcessByOpenEndType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobByNoWaitType
#define SOAP_TYPE_fims__StartJobByNoWaitType (93)
/* fims:StartJobByNoWaitType */
class SOAP_CMAC fims__StartJobByNoWaitType : public fims__StartJobType
{
public:
	virtual int soap_type() const { return 93; } /* = unique type id SOAP_TYPE_fims__StartJobByNoWaitType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobByNoWaitType() { fims__StartJobByNoWaitType::soap_default(NULL); }
	virtual ~fims__StartJobByNoWaitType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobByTimeType
#define SOAP_TYPE_fims__StartJobByTimeType (94)
/* fims:StartJobByTimeType */
class SOAP_CMAC fims__StartJobByTimeType : public fims__StartJobType
{
public:
	time_t time;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 94; } /* = unique type id SOAP_TYPE_fims__StartJobByTimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobByTimeType() { fims__StartJobByTimeType::soap_default(NULL); }
	virtual ~fims__StartJobByTimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StartJobByLatestType
#define SOAP_TYPE_fims__StartJobByLatestType (95)
/* fims:StartJobByLatestType */
class SOAP_CMAC fims__StartJobByLatestType : public fims__StartJobType
{
public:
	virtual int soap_type() const { return 95; } /* = unique type id SOAP_TYPE_fims__StartJobByLatestType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StartJobByLatestType() { fims__StartJobByLatestType::soap_default(NULL); }
	virtual ~fims__StartJobByLatestType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobRequestByIDType
#define SOAP_TYPE_fims__QueryJobRequestByIDType (101)
/* fims:QueryJobRequestByIDType */
class SOAP_CMAC fims__QueryJobRequestByIDType : public fims__QueryJobRequestType
{
public:
	std::vector<std::wstring >jobID;	/* required element of type fims:UID */
public:
	virtual int soap_type() const { return 101; } /* = unique type id SOAP_TYPE_fims__QueryJobRequestByIDType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobRequestByIDType() { fims__QueryJobRequestByIDType::soap_default(NULL); }
	virtual ~fims__QueryJobRequestByIDType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueryJobRequestByFilterType
#define SOAP_TYPE_fims__QueryJobRequestByFilterType (102)
/* fims:QueryJobRequestByFilterType */
class SOAP_CMAC fims__QueryJobRequestByFilterType : public fims__QueryJobRequestType
{
public:
	fims__ListFilterType *listFilter;	/* required element of type fims:ListFilterType */
public:
	virtual int soap_type() const { return 102; } /* = unique type id SOAP_TYPE_fims__QueryJobRequestByFilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueryJobRequestByFilterType() { fims__QueryJobRequestByFilterType::soap_default(NULL); }
	virtual ~fims__QueryJobRequestByFilterType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__identifierType
#define SOAP_TYPE_fimsdescription__identifierType (126)
/* Primitive fimsdescription:identifierType schema type: */
class SOAP_CMAC fimsdescription__identifierType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
	std::wstring *formatLanguage;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 126; } /* = unique type id SOAP_TYPE_fimsdescription__identifierType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__identifierType() { fimsdescription__identifierType::soap_default(NULL); }
	virtual ~fimsdescription__identifierType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__textElementType
#define SOAP_TYPE_fimsdescription__textElementType (132)
/* Primitive fimsdescription:textElementType schema type: */
class SOAP_CMAC fimsdescription__textElementType
{
public:
	std::wstring __item;
	std::wstring *xml__lang;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique type id SOAP_TYPE_fimsdescription__textElementType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__textElementType() { fimsdescription__textElementType::soap_default(NULL); }
	virtual ~fimsdescription__textElementType() { }
};
#endif

#ifndef SOAP_TYPE__fims__ServiceType_serviceDescription
#define SOAP_TYPE__fims__ServiceType_serviceDescription (310)
/* fims:ServiceType-serviceDescription */
class SOAP_CMAC _fims__ServiceType_serviceDescription
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 310; } /* = unique type id SOAP_TYPE__fims__ServiceType_serviceDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__ServiceType_serviceDescription() { _fims__ServiceType_serviceDescription::soap_default(NULL); }
	virtual ~_fims__ServiceType_serviceDescription() { }
};
#endif

#ifndef SOAP_TYPE_fims__ServiceType
#define SOAP_TYPE_fims__ServiceType (46)
/* fims:ServiceType */
class SOAP_CMAC fims__ServiceType : public fims__ResourceType
{
public:
	std::wstring *providerName;	/* optional element of type xsd:string */
	std::wstring *providerEndPoint;	/* optional element of type xsd:anyURI */
	_fims__ServiceType_serviceDescription *serviceDescription;	/* optional element of type fims:ServiceType-serviceDescription */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE_fims__ServiceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ServiceType() { fims__ServiceType::soap_default(NULL); }
	virtual ~fims__ServiceType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ProfileType
#define SOAP_TYPE_fims__ProfileType (47)
/* fims:ProfileType */
class SOAP_CMAC fims__ProfileType : public fims__ResourceType
{
public:
	fims__ServiceType *service;	/* optional element of type fims:ServiceType */
	std::wstring *name;	/* optional attribute */
	std::wstring *description;	/* optional attribute */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_fims__ProfileType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ProfileType() { fims__ProfileType::soap_default(NULL); }
	virtual ~fims__ProfileType() { }
};
#endif

#ifndef SOAP_TYPE_fims__QueueType
#define SOAP_TYPE_fims__QueueType (48)
/* fims:QueueType */
class SOAP_CMAC fims__QueueType : public fims__ResourceType
{
public:
	enum fims__QueueStatusType *status;	/* optional element of type fims:QueueStatusType */
	std::wstring *statusDescription;	/* optional element of type xsd:string */
	std::wstring *length;	/* optional element of type xsd:nonNegativeInteger */
	bool *availability;	/* optional element of type xsd:boolean */
	LONG64 *estimatedTotalCompletionDuration;	/* optional element of type xsd:duration */
	fims__JobsType *jobs;	/* optional element of type fims:JobsType */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_fims__QueueType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__QueueType() { fims__QueueType::soap_default(NULL); }
	virtual ~fims__QueueType() { }
};
#endif

#ifndef SOAP_TYPE_fims__JobType
#define SOAP_TYPE_fims__JobType (49)
/* fims:JobType */
class SOAP_CMAC fims__JobType : public fims__ResourceType
{
public:
	enum fims__JobStatusType *status;	/* optional element of type fims:JobStatusType */
	std::wstring *statusDescription;	/* optional element of type xsd:string */
	std::wstring *serviceProviderJobID;	/* optional element of type xsd:string */
	fims__QueueType *queueReference;	/* optional element of type fims:QueueType */
	fims__JobsType *tasks;	/* optional element of type fims:JobsType */
	std::wstring *operationName;	/* optional element of type xsd:string */
	fims__BMObjectsType *bmObjects;	/* optional element of type fims:BMObjectsType */
	enum fims__PriorityType *priority;	/* optional element of type fims:PriorityType */
	fims__StartJobType *startJob;	/* optional element of type fims:StartJobType */
	time_t *finishBefore;	/* optional element of type xsd:dateTime */
	LONG64 *estimatedCompletionDuration;	/* optional element of type xsd:duration */
	std::wstring *currentQueuePosition;	/* optional element of type xsd:nonNegativeInteger */
	time_t *jobStartedTime;	/* optional element of type xsd:dateTime */
	LONG64 *jobElapsedTime;	/* optional element of type xsd:duration */
	time_t *jobCompletedTime;	/* optional element of type xsd:dateTime */
	fims__ProcessedInfoType *processed;	/* optional element of type fims:ProcessedInfoType */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE_fims__JobType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__JobType() { fims__JobType::soap_default(NULL); }
	virtual ~fims__JobType() { }
};
#endif

#ifndef SOAP_TYPE_fims__FormatType
#define SOAP_TYPE_fims__FormatType (50)
/* fims:FormatType */
class SOAP_CMAC fims__FormatType : public fims__ResourceType
{
public:
	std::vector<fims__TechnicalAttributeType * >technicalAttribute;	/* optional element of type fims:TechnicalAttributeType */
public:
	virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_fims__FormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__FormatType() { fims__FormatType::soap_default(NULL); }
	virtual ~fims__FormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMObjectType
#define SOAP_TYPE_fims__BMObjectType (59)
/* fims:BMObjectType */
class SOAP_CMAC fims__BMObjectType : public fims__ResourceType
{
public:
	fims__BMContentsType *bmContents;	/* optional element of type fims:BMContentsType */
public:
	virtual int soap_type() const { return 59; } /* = unique type id SOAP_TYPE_fims__BMObjectType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMObjectType() { fims__BMObjectType::soap_default(NULL); }
	virtual ~fims__BMObjectType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentType
#define SOAP_TYPE_fims__BMContentType (60)
/* fims:BMContentType */
class SOAP_CMAC fims__BMContentType : public fims__ResourceType
{
public:
	fims__BMContentFormatsType *bmContentFormats;	/* optional element of type fims:BMContentFormatsType */
	fims__DescriptionsType *descriptions;	/* optional element of type fims:DescriptionsType */
public:
	virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE_fims__BMContentType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentType() { fims__BMContentType::soap_default(NULL); }
	virtual ~fims__BMContentType() { }
};
#endif

#ifndef SOAP_TYPE_fims__DescriptionType
#define SOAP_TYPE_fims__DescriptionType (61)
/* fims:DescriptionType */
class SOAP_CMAC fims__DescriptionType : public fims__ResourceType
{
public:
	fimsdescription__bmContentDescriptionType *fimsdescription__bmContentDescription;	/* optional element of type fimsdescription:bmContentDescriptionType */
public:
	virtual int soap_type() const { return 61; } /* = unique type id SOAP_TYPE_fims__DescriptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DescriptionType() { fims__DescriptionType::soap_default(NULL); }
	virtual ~fims__DescriptionType() { }
};
#endif

#ifndef SOAP_TYPE__fims__BMContentFormatType_mimeType
#define SOAP_TYPE__fims__BMContentFormatType_mimeType (327)
/* Primitive fims:BMContentFormatType-mimeType schema type: */
class SOAP_CMAC _fims__BMContentFormatType_mimeType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 327; } /* = unique type id SOAP_TYPE__fims__BMContentFormatType_mimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__BMContentFormatType_mimeType() { _fims__BMContentFormatType_mimeType::soap_default(NULL); }
	virtual ~_fims__BMContentFormatType_mimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMContentFormatType
#define SOAP_TYPE_fims__BMContentFormatType (62)
/* fims:BMContentFormatType */
class SOAP_CMAC fims__BMContentFormatType : public fims__ResourceType
{
public:
	fims__BMEssenceLocatorsType *bmEssenceLocators;	/* optional element of type fims:BMEssenceLocatorsType */
	_fims__formatCollection *formatCollection;	/* optional element of type fims:formatCollection */
	fims__DurationType *duration;	/* optional element of type fims:DurationType */
	fims__HashType *hash;	/* optional element of type fims:HashType */
	ULONG64 *packageSize;	/* optional element of type xsd:unsignedLong */
	_fims__BMContentFormatType_mimeType *mimeType;	/* optional element of type fims:BMContentFormatType-mimeType */
public:
	virtual int soap_type() const { return 62; } /* = unique type id SOAP_TYPE_fims__BMContentFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMContentFormatType() { fims__BMContentFormatType::soap_default(NULL); }
	virtual ~fims__BMContentFormatType() { }
};
#endif

#ifndef SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType
#define SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType (330)
/* Primitive fims:BMEssenceLocatorType-containerMimeType schema type: */
class SOAP_CMAC _fims__BMEssenceLocatorType_containerMimeType
{
public:
	std::wstring __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 330; } /* = unique type id SOAP_TYPE__fims__BMEssenceLocatorType_containerMimeType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__BMEssenceLocatorType_containerMimeType() { _fims__BMEssenceLocatorType_containerMimeType::soap_default(NULL); }
	virtual ~_fims__BMEssenceLocatorType_containerMimeType() { }
};
#endif

#ifndef SOAP_TYPE_fims__BMEssenceLocatorType
#define SOAP_TYPE_fims__BMEssenceLocatorType (63)
/* fims:BMEssenceLocatorType */
class SOAP_CMAC fims__BMEssenceLocatorType : public fims__ResourceType
{
public:
	class fims__StorageType *storageType;	/* optional element of type fims:StorageType */
	std::wstring *locatorInfo;	/* optional element of type xsd:string */
	_fims__BMEssenceLocatorType_containerMimeType *containerMimeType;	/* optional element of type fims:BMEssenceLocatorType-containerMimeType */
public:
	virtual int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_fims__BMEssenceLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__BMEssenceLocatorType() { fims__BMEssenceLocatorType::soap_default(NULL); }
	virtual ~fims__BMEssenceLocatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__StorageType
#define SOAP_TYPE_fims__StorageType (79)
/* Primitive fims:StorageType schema type: */
class SOAP_CMAC fims__StorageType
{
public:
	enum fims__StorageTypes __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique type id SOAP_TYPE_fims__StorageType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__StorageType() { fims__StorageType::soap_default(NULL); }
	virtual ~fims__StorageType() { }
};
#endif

#ifndef SOAP_TYPE_fims__HashFunctionType
#define SOAP_TYPE_fims__HashFunctionType (80)
/* Primitive fims:HashFunctionType schema type: */
class SOAP_CMAC fims__HashFunctionType
{
public:
	enum fims__HashFunctionTypes __item;
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique type id SOAP_TYPE_fims__HashFunctionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__HashFunctionType() { fims__HashFunctionType::soap_default(NULL); }
	virtual ~fims__HashFunctionType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__titleType
#define SOAP_TYPE_fimsdescription__titleType (125)
/* Primitive fimsdescription:titleType schema type: */
class SOAP_CMAC fimsdescription__titleType : public fimsdescription__textElementType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 125; } /* = unique type id SOAP_TYPE_fimsdescription__titleType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__titleType() { fimsdescription__titleType::soap_default(NULL); }
	virtual ~fimsdescription__titleType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__subjectType
#define SOAP_TYPE_fimsdescription__subjectType (127)
/* Primitive fimsdescription:subjectType schema type: */
class SOAP_CMAC fimsdescription__subjectType : public fimsdescription__textElementType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 127; } /* = unique type id SOAP_TYPE_fimsdescription__subjectType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__subjectType() { fimsdescription__subjectType::soap_default(NULL); }
	virtual ~fimsdescription__subjectType() { }
};
#endif

#ifndef SOAP_TYPE_fimsdescription__descriptionType
#define SOAP_TYPE_fimsdescription__descriptionType (129)
/* Primitive fimsdescription:descriptionType schema type: */
class SOAP_CMAC fimsdescription__descriptionType : public fimsdescription__textElementType
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
	std::wstring *typeLanguage;	/* optional attribute */
public:
	virtual int soap_type() const { return 129; } /* = unique type id SOAP_TYPE_fimsdescription__descriptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fimsdescription__descriptionType() { fimsdescription__descriptionType::soap_default(NULL); }
	virtual ~fimsdescription__descriptionType() { }
};
#endif

#ifndef SOAP_TYPE_fims__VideoFormatType
#define SOAP_TYPE_fims__VideoFormatType (51)
/* fims:VideoFormatType */
class SOAP_CMAC fims__VideoFormatType : public fims__FormatType
{
public:
	fims__LengthType *displayWidth;	/* optional element of type fims:LengthType */
	fims__LengthType *displayHeight;	/* optional element of type fims:LengthType */
	fims__RationalType *frameRate;	/* optional element of type fims:RationalType */
	fims__RationalType *aspectRatio;	/* optional element of type fims:RationalType */
	fims__CodecType *videoEncoding;	/* optional element of type fims:CodecType */
	std::vector<fims__BMTrackType * >videoTrack;	/* optional element of type fims:BMTrackType */
	std::wstring *bitRate;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__BitRateModeType *bitRateMode;	/* optional element of type fims:BitRateModeType */
	std::wstring *lines;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__ScanningFormatType *scanningFormat;	/* optional element of type fims:ScanningFormatType */
	enum fims__ScanningOrderType *scanningOrder;	/* optional element of type fims:ScanningOrderType */
	bool *noiseFilter;	/* optional element of type xsd:boolean */
public:
	virtual int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_fims__VideoFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__VideoFormatType() { fims__VideoFormatType::soap_default(NULL); }
	virtual ~fims__VideoFormatType() { }
};
#endif

#ifndef SOAP_TYPE__fims__AudioFormatType_trackConfiguration
#define SOAP_TYPE__fims__AudioFormatType_trackConfiguration (340)
/* fims:AudioFormatType-trackConfiguration */
class SOAP_CMAC _fims__AudioFormatType_trackConfiguration
{
public:
	std::wstring *typeLabel;	/* optional attribute */
	std::wstring *typeDefinition;	/* optional attribute */
	std::wstring *typeLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 340; } /* = unique type id SOAP_TYPE__fims__AudioFormatType_trackConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__AudioFormatType_trackConfiguration() { _fims__AudioFormatType_trackConfiguration::soap_default(NULL); }
	virtual ~_fims__AudioFormatType_trackConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_fims__AudioFormatType
#define SOAP_TYPE_fims__AudioFormatType (52)
/* fims:AudioFormatType */
class SOAP_CMAC fims__AudioFormatType : public fims__FormatType
{
public:
	std::wstring *samplingRate;	/* optional element of type xsd:decimal */
	fims__CodecType *audioEncoding;	/* optional element of type fims:CodecType */
	_fims__AudioFormatType_trackConfiguration *trackConfiguration;	/* optional element of type fims:AudioFormatType-trackConfiguration */
	std::vector<fims__BMTrackType * >audioTrack;	/* optional element of type fims:BMTrackType */
	std::wstring *channels;	/* optional element of type xsd:nonNegativeInteger */
	std::wstring *bitRate;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__BitRateModeType *bitRateMode;	/* optional element of type fims:BitRateModeType */
	std::wstring *sampleSize;	/* optional element of type xsd:nonNegativeInteger */
	enum fims__AudioSampleType *sampleType;	/* optional element of type fims:AudioSampleType */
public:
	virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_fims__AudioFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__AudioFormatType() { fims__AudioFormatType::soap_default(NULL); }
	virtual ~fims__AudioFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__DataFormatType
#define SOAP_TYPE_fims__DataFormatType (53)
/* fims:DataFormatType */
class SOAP_CMAC fims__DataFormatType : public fims__FormatType
{
public:
	std::vector<fims__CaptioningFormatType * >captioningFormat;	/* optional element of type fims:CaptioningFormatType */
	std::vector<fims__AncillaryDataFormatType * >ancillaryDataFormat;	/* optional element of type fims:AncillaryDataFormatType */
public:
	virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE_fims__DataFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__DataFormatType() { fims__DataFormatType::soap_default(NULL); }
	virtual ~fims__DataFormatType() { }
};
#endif

#ifndef SOAP_TYPE__fims__ContainerFormatType_containerFormat
#define SOAP_TYPE__fims__ContainerFormatType_containerFormat (347)
/* Primitive fims:ContainerFormatType-containerFormat schema type: */
class SOAP_CMAC _fims__ContainerFormatType_containerFormat
{
public:
	std::wstring __item;
	std::wstring *formatLabel;	/* optional attribute */
	std::wstring *formatDefinition;	/* optional attribute */
	std::wstring *formatLink;	/* optional attribute */
public:
	virtual int soap_type() const { return 347; } /* = unique type id SOAP_TYPE__fims__ContainerFormatType_containerFormat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _fims__ContainerFormatType_containerFormat() { _fims__ContainerFormatType_containerFormat::soap_default(NULL); }
	virtual ~_fims__ContainerFormatType_containerFormat() { }
};
#endif

#ifndef SOAP_TYPE_fims__ContainerFormatType
#define SOAP_TYPE_fims__ContainerFormatType (56)
/* fims:ContainerFormatType */
class SOAP_CMAC fims__ContainerFormatType : public fims__FormatType
{
public:
	_fims__ContainerFormatType_containerFormat *containerFormat;	/* optional element of type fims:ContainerFormatType-containerFormat */
public:
	virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE_fims__ContainerFormatType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ContainerFormatType() { fims__ContainerFormatType::soap_default(NULL); }
	virtual ~fims__ContainerFormatType() { }
};
#endif

#ifndef SOAP_TYPE_fims__SimpleFileLocatorType
#define SOAP_TYPE_fims__SimpleFileLocatorType (64)
/* fims:SimpleFileLocatorType */
class SOAP_CMAC fims__SimpleFileLocatorType : public fims__BMEssenceLocatorType
{
public:
	std::wstring *file;	/* optional element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_fims__SimpleFileLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__SimpleFileLocatorType() { fims__SimpleFileLocatorType::soap_default(NULL); }
	virtual ~fims__SimpleFileLocatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__ListFileLocatorType
#define SOAP_TYPE_fims__ListFileLocatorType (65)
/* fims:ListFileLocatorType */
class SOAP_CMAC fims__ListFileLocatorType : public fims__BMEssenceLocatorType
{
public:
	std::vector<std::wstring >file;	/* optional element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_fims__ListFileLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__ListFileLocatorType() { fims__ListFileLocatorType::soap_default(NULL); }
	virtual ~fims__ListFileLocatorType() { }
};
#endif

#ifndef SOAP_TYPE_fims__FolderLocatorType
#define SOAP_TYPE_fims__FolderLocatorType (66)
/* fims:FolderLocatorType */
class SOAP_CMAC fims__FolderLocatorType : public fims__BMEssenceLocatorType
{
public:
	std::wstring *folder;	/* optional element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_fims__FolderLocatorType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         fims__FolderLocatorType() { fims__FolderLocatorType::soap_default(NULL); }
	virtual ~fims__FolderLocatorType() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (349)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	edlprovider__EdlProviderFaultType *edlprovider__edlProviderFault;	/* optional element of type edlprovider:EdlProviderFaultType */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 349; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef SOAP_TYPE___edlprovider__getInstalledEdls
#define SOAP_TYPE___edlprovider__getInstalledEdls (355)
/* Operation wrapper: */
struct __edlprovider__getInstalledEdls
{
public:
	int soap_type() const { return 355; } /* = unique type id SOAP_TYPE___edlprovider__getInstalledEdls */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE___edlprovider__getEdl
#define SOAP_TYPE___edlprovider__getEdl (359)
/* Operation wrapper: */
struct __edlprovider__getEdl
{
public:
	edlprovider__EdlCreateRequestType *edlprovider__getEdlRequest;	/* optional element of type edlprovider:EdlCreateRequestType */
public:
	int soap_type() const { return 359; } /* = unique type id SOAP_TYPE___edlprovider__getEdl */
};
#endif

#ifndef SOAP_TYPE___edlprovider__getEdlDouble
#define SOAP_TYPE___edlprovider__getEdlDouble (362)
/* Operation wrapper: */
struct __edlprovider__getEdlDouble
{
public:
	edlprovider__EdlCreateRequestDoubleType *edlprovider__getEdlDoubleRequest;	/* optional element of type edlprovider:EdlCreateRequestDoubleType */
public:
	int soap_type() const { return 362; } /* = unique type id SOAP_TYPE___edlprovider__getEdlDouble */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (363)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 363; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (364)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 364; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (366)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 366; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (367)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 367; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__NMTOKEN
#define SOAP_TYPE_xsd__NMTOKEN (19)
typedef std::wstring xsd__NMTOKEN;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (20)
typedef std::wstring xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (21)
typedef std::wstring xsd__date;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (22)
typedef std::wstring xsd__decimal;
#endif

#ifndef SOAP_TYPE_xsd__gYear
#define SOAP_TYPE_xsd__gYear (23)
typedef std::wstring xsd__gYear;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (24)
typedef std::wstring xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__language
#define SOAP_TYPE_xsd__language (25)
typedef std::wstring xsd__language;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (26)
typedef std::wstring xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (27)
typedef std::wstring xsd__positiveInteger;
#endif

#ifndef SOAP_TYPE_xsd__time
#define SOAP_TYPE_xsd__time (28)
typedef std::wstring xsd__time;
#endif

#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (29)
typedef std::wstring _xml__lang;
#endif

#ifndef SOAP_TYPE_fims__UID
#define SOAP_TYPE_fims__UID (140)
typedef std::wstring fims__UID;
#endif

#ifndef SOAP_TYPE_fims__UUID
#define SOAP_TYPE_fims__UUID (142)
typedef std::wstring fims__UUID;
#endif

#ifndef SOAP_TYPE_fims__UMID
#define SOAP_TYPE_fims__UMID (143)
typedef std::wstring fims__UMID;
#endif

#ifndef SOAP_TYPE_fims__UL
#define SOAP_TYPE_fims__UL (144)
typedef std::wstring fims__UL;
#endif

#ifndef SOAP_TYPE_fims__EmptyID
#define SOAP_TYPE_fims__EmptyID (145)
typedef std::wstring fims__EmptyID;
#endif

#ifndef SOAP_TYPE_fims__ResourceIDType
#define SOAP_TYPE_fims__ResourceIDType (146)
typedef std::wstring fims__ResourceIDType;
#endif

#ifndef SOAP_TYPE_fims__RevisionIDType
#define SOAP_TYPE_fims__RevisionIDType (147)
typedef std::wstring fims__RevisionIDType;
#endif

#ifndef SOAP_TYPE_fims__Timecode
#define SOAP_TYPE_fims__Timecode (148)
typedef std::wstring fims__Timecode;
#endif

#ifndef SOAP_TYPE_fims__TimecodeDuration
#define SOAP_TYPE_fims__TimecodeDuration (149)
typedef std::wstring fims__TimecodeDuration;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of EDLProviderStub.h */
